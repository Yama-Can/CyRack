<html>
	<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8" />
		<title>  Keys - Mithril.js</title>
		<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' />
		<link href="lib/prism/prism.css" rel="stylesheet" />
		<link href="style.css" rel="stylesheet" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	</head>
	<body>
		<header>
			<section>
				<a class="hamburger" href="javascript:;">≡</a>
				<h1><img src="logo.svg">  Mithril <small>1.0.1</small></h1>
				<nav>
					<a href="index.html">ガイド</a> <a href="api.html">API</a> <a href="https://gitter.im/lhorie/mithril.js">チャット</a> <a href="https://github.com/lhorie/mithril.js">Github</a>
				</nav>
			</section>
		</header>
		<main>
			<section>
				<h1 id="keys">キー</h1>
<ul>
<li>チュートリアル<ul>
<li><a href="installation.html">インストール</a></li>
<li><a href="index.html">イントロダクション</a></li>
<li><a href="simple-application.html">チュートリアル</a></li>
</ul>
</li>
<li>リソース<ul>
<li><a href="jsx.html">JSX</a></li>
<li><a href="es6.html">ES6</a></li>
<li><a href="css.html">CSS</a></li>
<li><a href="animation.html">アニメーション</a></li>
<li><a href="testing.html">テスト</a></li>
<li><a href="examples.html">サンプル</a></li>
</ul>
</li>
<li>重要なコンセプト<ul>
<li><a href="vnodes.html">Vノード</a></li>
<li><a href="components.html">コンポーネント</a></li>
<li><a href="lifecycle-methods.html">ライフサイクルメソッド</a></li>
<li><strong><a href="keys.html">キー</a></strong><ul>
<li><a href="#what-are-keys">What are keys</a></li>
<li><a href="#how-to-use">How to use</a></li>
<li><a href="#debugging-key-related-issues">Debugging key related issues</a></li>
</ul>
</li>
<li><a href="autoredraw.html">自動再描画システム</a></li>
</ul>
</li>
<li>ソーシャル<ul>
<li><a href="https://github.com/lhorie/mithril.js/wiki/JOBS">Mithrilの求人</a></li>
<li><a href="contributing.html">貢献の仕方</a></li>
<li><a href="credits.html">クレジット</a></li>
</ul>
</li>
<li>その他<ul>
<li><a href="framework-comparison.html">フレームワークの比較</a></li>
<li><a href="change-log.html">変更履歴/移行</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="what-are-keys">What are keys</h3>
<p>Keys are a mechanism that allows re-ordering DOM elements within a NodeList, and mapping specific data items in a list to the respective DOM elements that are derived from them, as the data items move within the list.</p>
<p>In other words, a <code>key</code> is a way of saying "this DOM element is for the data object with this id".</p>
<p>Typically, a <code>key</code> property should be the unique identifier field of the objects in the data array.</p>
<pre><code class="lang-javascript">var users = [
    {id: 1, name: "ジョン"},
    {id: 2, name: "メアリー"},
]

function userInputs(users) {
    return users.map(function(u) {
        return m("input", {key: u.id}, u.name)
    })
}

m.render(document.body, userInputs(users))
</code></pre>
<p>キーを持つと、<code>users</code>配列がシャッフルされてビューが再描画されても、inputタグも同じ順序で正しくシャッフルされ、フォーカスとDOMの状態が維持されます。</p>
<hr>
<h3 id="how-to-use">How to use</h3>
<p>A common pattern is to have data comprised of an array of objects and to generate a list of vnodes that map to each object in the array. For example, consider the following code:</p>
<pre><code class="lang-javascript">var people = [
    {id: 1, name: "ジョン"},
    {id: 2, name: "Mary"},
]

function userList(users) {
    return users.map(function(u) {
        return m("button", u.name) // &lt;button&gt;John&lt;/button&gt;
                                   // &lt;button&gt;Mary&lt;/button&gt;
    })
}

m.render(document.body, userList(people))
</code></pre>
<p>Let's suppose the <code>people</code> variable was changed to this:</p>
<pre><code class="lang-javascript">people = [{id: 2, name: "Mary"}]
</code></pre>
<p>The problem is that from the point of view of the <code>userList</code> function, there's no way to tell if it was the first object that was removed, or if it was the second object that was removed <em>in addition to the first object's properties being modified</em>. If the first button was focused and the rendering engine removes it, then focus goes back to <code>&lt;body&gt;</code> as expected, but if the rendering engine removes the second button and modifies the text content of the first, then the focus will be on the wrong button after the update.</p>
<p>Worse still, if there were stateful jQuery plugins attached to these buttons, they could potentially have incorrect internal state after the update.</p>
<p>Even though in this particular example, we humans intuitively guess that the first item in the list was the one being removed, it's actually impossible for a computer to automatically solve this problem for all possible inputs.</p>
<p>Therefore, in the cases when a list of vnodes is derived from a dynamic array of data, you should add a <code>key</code> property to each virtual node that maps to a uniquely identifiable field in the source data. This will allow Mithril to intelligently re-order the DOM to maintain each DOM element correctly mapped to its respective item in the data source.</p>
<pre><code class="lang-javascript">function correctUserList(users) {
    return users.map(function(u) {
        return m("button", {key: u.id}, u.name)
    })
}
</code></pre>
<hr>
<h3 id="debugging-key-related-issues">Debugging key related issues</h3>
<p>Keys can cause confusing issues if they are misunderstood. A typical symptom of key related issues is that application state appears to become corrupted after a few user interactions (usually involving a deletion).</p>
<h4 id="avoid-wrapper-elements-around-keyed-elements">Avoid wrapper elements around keyed elements</h4>
<p>Keys must be placed on the virtual node that is an immediate child of the array. This means that if you wrap the <code>button</code> in an <code>div</code> in the example above, the key must be moved to the <code>div</code>.</p>
<pre><code class="lang-javascript">// AVOID
users.map(function(u) {
    return m("div", [ // key should be in `div`
        m("button", {key: u.id}, u.name)
    ])
})
</code></pre>
<h4 id="avoid-hiding-keys-in-component-root-elements">Avoid hiding keys in component root elements</h4>
<p>If you refactor the code and put the button inside a component, the key must be moved out of the component and placed back where the component took the place of the button.</p>
<pre><code class="lang-javascript">// AVOID
var Button = {
    view: function(vnode) {
        return m("button", {key: vnode.attrs.id}, u.name)
    }
}

// PREFER
users.map(function(u) {
    return m("div", [
        m(Button, {key: u.id}, u.name) // key should be here, not in component
    ])
})
</code></pre>
<h4 id="avoid-wrapping-keyed-elements-in-arrays">Avoid wrapping keyed elements in arrays</h4>
<p>Arrays are <a href="vnodes.html">vnodes</a>, and therefore keyable. You should not wrap arrays around keyed elements</p>
<pre><code class="lang-javascript">// AVOID
users.map(function(u) {
    return [ // fragment is a vnode, and therefore keyable
        m("button", {key: u.id}, u.name)
    ]
})

// PREFER
users.map(function(u) {
    return m("button", {key: u.id}, u.name)
})

// PREFER
users.map(function(u) {
    return m.fragment({key: u.id}, m("button", u.name))
})
</code></pre>
<h4 id="avoid-variable-types">Avoid variable types</h4>
<p>Keys must be strings if present or they will be cast to strings if they are not. Therefore, <code>"1"</code> (string) and <code>1</code> (number) are considered the same key.</p>
<p>You should use either strings or numbers as keys in one array, but not mix both.</p>
<pre><code class="lang-javascript">// AVOID
var things = [
    {id: "1", name: "Book"},
    {id: 1, name: "Cup"},
]
</code></pre>
<h4 id="avoid-mixing-keyed-and-non-keyed-vnodes-in-the-same-array">Avoid mixing keyed and non-keyed vnodes in the same array</h4>
<p>An array of vnodes must have only keyed vnodes or non-keyed vnodes, but not both. If you need to mix them, create a nested array.</p>
<pre><code class="lang-javascript">// AVOID
m("div", [
    m("div", "a"),
    m("div", {key: 1}, "b"),
])

// PREFER
m("div", [
    m("div", {key: 0}, "a"),
    m("div", {key: 1}, "b"),
])


// PREFER
m("div", [
    m("div", "a"),
    [
        m("div", {key: 1}, "b"),
    ]
])
</code></pre>

				<hr />
				<small>License: MIT. © Leo Horie.</small>
			</section>
		</main>
		<script src="lib/prism/prism.js"></script>
		<script>
		document.querySelector(".hamburger").onclick = function() {
			document.body.className = document.body.className === "navigating" ? "" : "navigating"
			document.querySelector("h1 + ul").onclick = function() {
				document.body.className = ''
			}
		}
		</script>
	</body>
</html>
