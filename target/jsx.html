<html>
	<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8" />
		<title>  JSX - Mithril.js</title>
		<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' />
		<link href="lib/prism/prism.css" rel="stylesheet" />
		<link href="style.css" rel="stylesheet" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	</head>
	<body>
		<header>
			<section>
				<a class="hamburger" href="javascript:;">≡</a>
				<h1><img src="logo.svg">  Mithril <small>1.0.1</small></h1>
				<nav>
					<a href="index.html">ガイド</a> <a href="api.html">API</a> <a href="https://gitter.im/lhorie/mithril.js">チャット</a> <a href="https://github.com/lhorie/mithril.js">Github</a>
				</nav>
			</section>
		</header>
		<main>
			<section>
				<h1 id="jsx">JSX</h1>
<ul>
<li>チュートリアル<ul>
<li><a href="installation.html">インストール</a></li>
<li><a href="index.html">イントロダクション</a></li>
<li><a href="simple-application.html">チュートリアル</a></li>
</ul>
</li>
<li>リソース<ul>
<li><strong><a href="jsx.html">JSX</a></strong><ul>
<li><a href="#description">説明</a></li>
<li><a href="#setup">セットアップ</a></li>
<li><a href="#using-babel-with-webpack">WebPackとBabelを使用する</a></li>
<li><a href="#jsx-vs-hyperscript">JSX vs hyperscript</a></li>
<li><a href="#converting-html">HTMLの変換</a></li>
</ul>
</li>
<li><a href="es6.html">ES6</a></li>
<li><a href="css.html">CSS</a></li>
<li><a href="animation.html">アニメーション</a></li>
<li><a href="testing.html">テスト</a></li>
<li><a href="examples.html">サンプル</a></li>
</ul>
</li>
<li>重要なコンセプト<ul>
<li><a href="vnodes.html">Vノード</a></li>
<li><a href="components.html">コンポーネント</a></li>
<li><a href="lifecycle-methods.html">ライフサイクルメソッド</a></li>
<li><a href="keys.html">キー</a></li>
<li><a href="autoredraw.html">自動再描画システム</a></li>
</ul>
</li>
<li>ソーシャル<ul>
<li><a href="https://github.com/lhorie/mithril.js/wiki/JOBS">Mithrilの求人</a></li>
<li><a href="contributing.html">貢献の仕方</a></li>
<li><a href="credits.html">クレジット</a></li>
</ul>
</li>
<li>その他<ul>
<li><a href="framework-comparison.html">フレームワークの比較</a></li>
<li><a href="change-log.html">変更履歴/移行</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="description">説明</h3>
<p>JSX is a syntax extension that enables you to write HTML tags interspersed with Javascript. It's not part of any Javascript standards and it's not required for building applications, but it may be more pleasing to use depending on your team's preferences.</p>
<pre><code class="lang-jsx">var MyComponent = {
  view: function() {
    return m("main", [
      m("h1", "Hello world"),
    ])
  }
}

// can be written as:
var MyComponent = {
  view: function() {
    return (
      &lt;main&gt;
        &lt;h1&gt;Hello world&lt;/h1&gt;
      &lt;/main&gt;
    )
  }
}
</code></pre>
<p>When using JSX, it's possible to interpolate Javascript expressions within JSX tags by using curly braces:</p>
<pre><code class="lang-jsx">var greeting = "Hello"
var url = "http://google.com"
var link = &lt;a href={url}&gt;{greeting + "!"}&lt;/a&gt;
// yields &lt;a href="http://google.com"&gt;Hello&lt;/a&gt;
</code></pre>
<p>Components can be used by using a convention of uppercasing the first letter of the component name:</p>
<pre><code class="lang-jsx">m.mount(document.body, &lt;MyComponent /&gt;)
// equivalent to m.mount(document.body, m(MyComponent))
</code></pre>
<hr>
<h3 id="setup">セットアップ</h3>
<p>The simplest way to use JSX is via a <a href="https://babeljs.io/">Babel</a> plugin.</p>
<p>Babelは<a href="https://nodejs.org/en/">Node.js</a>をインストールすると維持でインストールされるnpmが必要です。npmがインストールされたら、プロジェクトフォルダを作り、次のコマンドを入力しましょう:</p>
<pre><code class="lang-bash">npm init -y
</code></pre>
<p>もしWebPackとBabelを同時に使いたいのであれば、<a href="#using-babel-with-webpack">次のセクション</a>まで飛ばしてください。</p>
<p>Babelをスタンドアロンツールとして導入するには次のコマンドを実行します:</p>
<pre><code class="lang-bash">npm install babel-cli babel-preset-es2015 babel-plugin-transform-react-jsx --save-dev
</code></pre>
<p><code>.babelrc</code>ファイルを作成します:</p>
<pre><code>{
    "presets": ["es2015"],
    "plugins": [
        ["transform-react-jsx", {
            "pragma": "m"
        }]
    ]
}
</code></pre><p>スタンドアロンツールとしてBabelを実行するには、次のように起動します:</p>
<pre><code class="lang-bash">babel src --out-dir bin --source-maps
</code></pre>
<h4 id="using-babel-with-webpack">WebPackとBabelを使用する</h4>
<p>もしソースコードのバンドルにWebPackをすでに使っているのであれば、次のように設定することでBabelをWebPackに統合できます。</p>
<pre><code class="lang-bash">npm install babel-core babel-loader babel-preset-es2015 babel-plugin-transform-react-jsx --save-dev
</code></pre>
<p><code>.babelrc</code>ファイルを作成します:</p>
<pre><code>{
    "presets": ["es2015"],
    "plugins": [
        ["transform-react-jsx", {
            "pragma": "m"
        }]
    ]
}
</code></pre><p>次に、<code>webpack.config.js</code>というファイルを作成します</p>
<pre><code class="lang-javascript">module.exports = {
    entry: './src/index.js',
    output: {
        path: './bin',
        filename: 'app.js',
    },
    module: {
        loaders: [{
            test: /\.js$/,
            exclude: /node_modules/,
            loader: 'babel-loader'
        }]
    }
}
</code></pre>
<p>この設定ファイルでは、アプリケーションのエントリポイントが<code>src/index.js</code>にあり、出力先が<code>bin/app.js</code>にあることを想定しています。</p>
<p>バンドラーを実行するにはnpmスクリプトの設定を行います。<code>package.json</code>ファイルを開き、<code>"scripts"</code>以下に次のstart節を追加します:</p>
<pre><code>{
    "name": "my-project",
    "scripts": {
        "start": "webpack -d --watch"
    }
}
</code></pre><p>これでバンドラーをコマンドラインツールから実行できるようになりました:</p>
<pre><code class="lang-bash">npm start
</code></pre>
<h4 id="production-build">本番ビルド</h4>
<p>ミニファイされたファイルを生成するには、<code>package.json</code>を開き、<code>build</code>という新しいnpmスクリプトの項目を追加します:</p>
<pre><code>{
    "name": "my-project",
    "scripts": {
        "start": "webpack -d --watch",
        "build": "webpack -p",
    }
}
</code></pre><p>本番環境ではフックを使ってスクリプトの本番ビルドを自動でビルドさせることができます。次のコードは<a href="https://www.heroku.com/">Heroku</a>を使うサンプルです:</p>
<pre><code>{
    "name": "my-project",
    "scripts": {
        "start": "webpack -d --watch",
        "build": "webpack -p",
        "heroku-postbuild": "webpack -p"
    }
}
</code></pre><hr>
<h3 id="jsx-vs-hyperscript">JSX vs hyperscript</h3>
<p>JSX is essentially a trade-off: it introduces a non-standard syntax that cannot be run without appropriate tooling, in order to allow a developer to write HTML code using curly braces. The main benefit of using JSX instead of regular HTML is that the JSX specification is much stricter and yields syntax errors when appropriate, whereas HTML is far too forgiving and can make syntax issues difficult to spot.</p>
<p>Unlike HTML, JSX is case-sensitive. This means <code>&lt;div className="test"&gt;&lt;/div&gt;</code> is different from <code>&lt;div classname="test"&gt;&lt;/div&gt;</code> (all lower case). The former compiles to <code>m("div", {className: "test"})</code> and the latter compiles to <code>m("div", {classname: "test"})</code>, which is not a valid way of creating a class attribute. Fortunately, Mithril supports standard HTML attribute names, and thus, this example can be written like regular HTML: <code>&lt;div class="test"&gt;&lt;/div&gt;</code>.</p>
<p>JSX is useful for teams where HTML is primarily written by someone without Javascript experience, but it requires a significant amount of tooling to maintain (whereas plain HTML can, for the most part, simply be opened in a browser)</p>
<p>Hyperscript is the compiled representation of JSX. It's designed to be readable and can also be used as-is, instead of JSX (as is done in most of the documentation). Hyperscript tends to be terser than JSX for a couple of reasons:</p>
<ul>
<li>it does not require repeating the tag name in closing tags (e.g. <code>m("div")</code> vs <code>&lt;div&gt;&lt;/div&gt;</code>)</li>
<li>static attributes can be written using CSS selector syntax (i.e. <code>m("a.button")</code> vs <code>&lt;div class="button"&gt;&lt;/div&gt;</code></li>
</ul>
<p>In addition, since hyperscript is plain Javascript, it's often more natural to indent than JSX:</p>
<pre><code class="lang-jsx">//JSX
var BigComponent = {
  activate: function() {/*...*/},
  deactivate: function() {/*...*/},
  update: function() {/*...*/},
  view: function(vnode) {
    return [
      {vnode.attrs.items.map(function(item) {
        return &lt;div&gt;{item.name}&lt;/div&gt;
      })}
      &lt;div
        ondragover={this.activate}
        ondragleave={this.deactivate}
        ondragend={this.deactivate}
        ondrop={this.update}
        onblur={this.deactivate}
      &gt;&lt;/div&gt;
    ]
  }
}

// hyperscript
var BigComponent = {
  activate: function() {/*...*/},
  deactivate: function() {/*...*/},
  update: function() {/*...*/},
  view: function(vnode) {
    return [
      vnode.attrs.items.map(function(item) {
        return m("div", item.name)
      }),
      m("div", {
        ondragover: this.activate,
        ondragleave: this.deactivate,
        ondragend: this.deactivate,
        ondrop: this.update,
        onblur: this.deactivate,
      })
    ]
  }
}
</code></pre>
<p>In non-trivial applications, it's possible for components to have more control flow and component configuration code than markup, making a Javascript-first approach more readable than an HTML-first approach.</p>
<p>Needless to say, since hyperscript is pure Javascript, there's no need to run a compilation step to produce runnable code.</p>
<hr>
<h3 id="converting-html">HTMLの変換</h3>
<p>Mithrilでは、正しく書かれたHTMLはJSXとしてそのまま使えます。コピーアンドペースト程度の労力を払えば、独立して作られたHTMLファイルを元にしてJSXを使ってプロジェクトに組み込むことができます。</p>
<p>hyperscriptを使う時は、実行前にHTMLからhyperscriptの文法に変換する必要があります。When using hyperscript, it's necessary to convert HTML to hyperscript syntax before the code can be run. <a href="http://arthurclemens.github.io/mithril-template-converter/index.html">HTML-to-Mithrilテンプレートコンバーター</a>を使って変換できます。</p>

				<hr />
				<small>License: MIT. © Leo Horie.</small>
			</section>
		</main>
		<script src="lib/prism/prism.js"></script>
		<script>
		document.querySelector(".hamburger").onclick = function() {
			document.body.className = document.body.className === "navigating" ? "" : "navigating"
			document.querySelector("h1 + ul").onclick = function() {
				document.body.className = ''
			}
		}
		</script>
	</body>
</html>
