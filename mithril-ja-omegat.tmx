<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.6.0_1_r8695:8697" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"/blog/:date...": Component1, //for the default path in the line above, this route matches first!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135234Z" creationid="shibukawa.yoshiki" creationdate="20150502T135234Z">
        <seg>"/blog/:date...": Component1, //上記のデフォルトパスはこのラウトに先にマッチします!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//the routes should be flipped around to get `m.route.param("year") == "2014"`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135300Z" creationid="shibukawa.yoshiki" creationdate="20150502T135300Z">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//`m.route.param("year") == "2014"`が成立するように、ラウト定義の順番を変えること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/home": Home, // defines `http://localhost/#!/home`
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T112040Z" creationid="shibukawa.yoshiki" creationdate="20170206T112040Z">
        <seg>"/home": Home, // `http://localhost/#!/home` の定義
})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"Asynchronously" means that Javascript continues running other code while it waits for the response from server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143644Z" creationid="shibukawa.yoshiki" creationdate="20170219T143644Z">
        <seg>「非同期」とは、サーバーからレスポンスが返ってくるのを待つ間に、JavaScriptの他のコードの実行が継続されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"CSS-in-JS" is another type of CSS system that is growing in popularity, which basically consists of scoping CSS via transpilation tooling.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T035512Z" creationid="shibukawa.yoshiki" creationdate="20170221T035512Z">
        <seg>"CSS-in-JS"は最近人気を伸ばしている他のCSSシステムです。基本的にトランスパイルによってスコープを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(An execution thread is basically any amount of code that runs before other asynchronous threads start to run.)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135558Z" creationid="shibukawa.yoshiki" creationdate="20150412T135548Z">
        <seg>(実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(function(value) {console.log(value)}) //logs "hello world" after 1 second</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050134Z" creationid="shibukawa.yoshiki" creationdate="20170201T050134Z">
        <seg>.then(function(value) {console.log(value)}) // 1秒後に "hello world" のログ出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(function(value) {console.log(value)}); //logs "hello world" after 1 second</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135104Z" creationid="shibukawa.yoshiki" creationdate="20150415T135104Z">
        <seg>.then(function(value) {console.log(value)}); //1秒後に"hello world"と表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(null, error) //handle the application error: bind to a getter-setter for diplaying it on the template</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173433Z" creationid="shibukawa.yoshiki" creationdate="20150415T173433Z">
        <seg>.then(null, error) //アプリケーションのエラーをテンプレートで表示するためにsetter-getterにバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(users, error); //on success, `users` will be populated, otherwise `error` will be populated
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135118Z" creationid="shibukawa.yoshiki" creationdate="20150414T135118Z">
        <seg>.then(users, error); //成功時には`users`が変更され、それ以外では`error`が変更される
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* draws stuff */
}

var view = [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123532Z" creationid="shibukawa.yoshiki" creationdate="20150413T123532Z">
        <seg>/* 描画コード */
}

var view = [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//    Note: The config is never run server side.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132852Z" creationid="shibukawa.yoshiki" creationdate="20160101T132852Z">
        <seg>// 注意: configはサーバサイドでは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//    Returns a select box</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T131529Z" creationid="shibukawa.yoshiki" creationdate="20160101T131529Z">
        <seg>// 選択ボックスを返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//    Set selected option</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132122Z" creationid="shibukawa.yoshiki" creationdate="20160101T132122Z">
        <seg>// 選択されているオプションを設定します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//  Has to use a prop for the current user</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T133133Z" creationid="shibukawa.yoshiki" creationdate="20160101T133100Z">
        <seg>// 現在のユーザはpropに格納します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// AVOID
var users = m.request("/api/v1/users")
console.log("list of users:", users)
// `users` is NOT a list of users, it's a promise

// PREFER
m.request("/api/v1/users").then(function(users) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T053555Z" creationid="shibukawa.yoshiki" creationdate="20170220T053525Z">
        <seg>// 避けるべき実装
var users = m.request("/api/v1/users")
console.log("ユーザーのリスト:", users)
// `users`はユーザーのリストではなく、Promise

// 望ましい実装
m.request("/api/v1/users").then(function(users) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called after the DOM node is created</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035154Z" creationid="shibukawa.yoshiki" creationdate="20170131T035154Z">
        <seg>// DOMノードが作成された後に呼ばれる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called after the node is updated</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035254Z" creationid="shibukawa.yoshiki" creationdate="20170131T035254Z">
        <seg>// ノードが更新された後に呼ばれる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called before the DOM node is created</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035143Z" creationid="shibukawa.yoshiki" creationdate="20170131T035143Z">
        <seg>// DOMノードが作成される前に呼ばれる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called before the node is removed, but after onbeforeremove calls done()</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035440Z" creationid="shibukawa.yoshiki" creationdate="20170131T035440Z">
        <seg>// ノードが削除される前で、onbeforeremoveが完了した後に呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called before the node is removed, return a Promise that resolves when</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035350Z" creationid="shibukawa.yoshiki" creationdate="20170131T035350Z">
        <seg>// ノードが削除されたときに呼ばれる。DOMからノードを削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called before the node is updated, return false to cancel</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035239Z" creationid="shibukawa.yoshiki" creationdate="20170131T035239Z">
        <seg>// DOMノードが更新前に呼ばれ、falseを返すと更新をキャンセルする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Getting the current route
m.route()

// Setting a new route
m.route("/other/route")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141842Z" creationid="shibukawa.yoshiki" creationdate="20170131T141842Z">
        <seg>// 現在のラウトを取得
m.route()

// 新しいラウトを設定
m.route("/other/route")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Getting the current route
m.route.get()

// Setting a new route
m.route.set("/other/route")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141918Z" creationid="shibukawa.yoshiki" creationdate="20170131T141858Z">
        <seg>// 現在のラウトを取得
m.route.get()

// 新しいラウトを設定
m.route.set("/other/route")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// HTML syntax via Babel's JSX plugin
&lt;main&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030451Z" creationid="shibukawa.yoshiki" creationdate="20170131T030451Z">
        <seg>// BabelのJSXをプラグインを使ったHTML文法
&lt;main&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TODO add code here</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121628Z" creationid="shibukawa.yoshiki" creationdate="20170220T121628Z">
        <seg>// TODO: ここにコードを追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TODO implement view</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120039Z" creationid="shibukawa.yoshiki" creationdate="20170221T120039Z">
        <seg>// TODO: ビューを実装する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TODO: make XHR call</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055543Z" creationid="shibukawa.yoshiki" creationdate="20170220T055543Z">
        <seg>// TODO: XHR呼び出しをする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// These are equivalent
m.component(component)
m(component)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034904Z" creationid="shibukawa.yoshiki" creationdate="20170131T034904Z">
        <seg>// 次の行は同じ
m.component(component)
m(component)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Use vnode.attrs instead of options</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T135509Z" creationid="shibukawa.yoshiki" creationdate="20170131T122215Z">
        <seg>// optionsの代わりにvnode.attrsを使います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Use vnode.state instead of ctrl</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T135521Z" creationid="shibukawa.yoshiki" creationdate="20170131T122157Z">
        <seg>// ctrlの代わりにvnode.stateを使います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// User-specified namespace on the `href` attribute</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050537Z" creationid="shibukawa.yoshiki" creationdate="20170201T050537Z">
        <seg>// `href`属性にユーザー指定の名前空間を付与する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// When clicked this link will load the "/path" route instead of navigating
m("a", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141642Z" creationid="shibukawa.yoshiki" creationdate="20170131T141635Z">
        <seg>// リンクをクリックしたときに、ナビゲーションを行うのではなく、"/path"のラウターをロードする
m("a", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Your tests here...
}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161345Z" creationid="shibukawa.yoshiki" creationdate="20150416T161345Z">
        <seg>//テストはこちら
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a redraw happens after this function runs
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121042Z" creationid="shibukawa.yoshiki" creationdate="20170206T121042Z">
        <seg>// この関数の実行後に再描画が発生
})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a redraw happens asynchronously after the route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121301Z" creationid="shibukawa.yoshiki" creationdate="20170206T121301Z">
        <seg>// ラウと変更後に同期的に再描画が実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a redraw happens synchronously after this function runs
}

m.mount(document.body, MyComponent)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120844Z" creationid="shibukawa.yoshiki" creationdate="20170206T120844Z">
        <seg>// この関数の実行直後に同期的に再描画が行われる
}

m.mount(document.body, MyComponent)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// changed the next line</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030900Z" creationid="shibukawa.yoshiki" creationdate="20170131T030900Z">
        <seg>// この行を変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// does not trigger a redraw
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121126Z" creationid="shibukawa.yoshiki" creationdate="20170206T121126Z">
        <seg>// 再描画は行われない
})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// example 1
m.route(document.body, "/", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T070950Z" creationid="shibukawa.yoshiki" creationdate="20170208T070950Z">
        <seg>// 例 1
m.route(document.body, "/", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// example 2
m.route(document.body, "/", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073106Z" creationid="shibukawa.yoshiki" creationdate="20170208T073106Z">
        <seg>// 例 2
m.route(document.body, "/", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// functionally equivalent to example 1
var Anon1 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073414Z" creationid="shibukawa.yoshiki" creationdate="20170208T073414Z">
        <seg>//例 1と機能的に同じ
var Anon1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// isInitialized is a boolean representing if the node has been added to the DOM</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035051Z" creationid="shibukawa.yoshiki" creationdate="20170131T035051Z">
        <seg>// isInitializedはブール値で、ノードがDOMに追加されるときにtrueになる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// naive implementation for the sake of keeping example simple</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005019Z" creationid="shibukawa.yoshiki" creationdate="20170220T005019Z">
        <seg>// このコードはサンプルを短くするための簡易実装です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// navigate away</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061854Z" creationid="shibukawa.yoshiki" creationdate="20170208T061854Z">
        <seg>// 別のページに遷移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no longer triggers a redraw when the div is clicked
}

m.mount(document.body, MyComponent)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120940Z" creationid="shibukawa.yoshiki" creationdate="20170206T120940Z">
        <seg>// このdivがクリックされても再描画は行われない
}

m.mount(document.body, MyComponent)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ready for the node to be removed from the DOM</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035403Z" creationid="shibukawa.yoshiki" creationdate="20170131T035403Z">
        <seg>// する準備が整ったときに解決されるPromiseを返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// runs on each redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035024Z" creationid="shibukawa.yoshiki" creationdate="20170131T035024Z">
        <seg>// 毎回の再描画時に呼ばれる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// save the state for this route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061835Z" creationid="shibukawa.yoshiki" creationdate="20170208T061835Z">
        <seg>// 現在のラウトの状態を保持しておく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set to pathname strategy
m.route.prefix("")

// set to querystring strategy
m.route.prefix("?")

// set to hash without bang
m.route.prefix("#")

// set to pathname strategy on a non-root URL
// e.g. if the app lives under `http://localhost/my-app` and something else lives under `http://localhost`
m.route.prefix("/my-app")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064621Z" creationid="shibukawa.yoshiki" creationdate="20170208T064432Z">
        <seg>// パス名戦略を使用
m.route.prefix("")

// クエリー文字列戦略を使用
m.route.prefix("?")

// 感嘆符なしのハッシュを使用
m.route.prefix("#")

// URLのルートで稼働しないパス名戦略を使うアプリケーションの設定
// 他のページがhttp://localhostにあり、アプリケーションがhttp://localhost/my-app以下にある場合
m.route.prefix("/my-app")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the `href` attribute is namespaced automatically</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050508Z" creationid="shibukawa.yoshiki" creationdate="20170201T050508Z">
        <seg>// `href`属性は自動で名前空間が付与される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this is equivalent to `history.replaceState({term: state.term}, null, location.href)`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061843Z" creationid="shibukawa.yoshiki" creationdate="20170208T061843Z">
        <seg>// これは`history.replaceState({term: state.term}, null, location.href)`と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// using Webpack async code splitting</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T090212Z" creationid="shibukawa.yoshiki" creationdate="20170208T090212Z">
        <seg>// WebPackの非同期コード分割を使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// wrap the component in a m() call for m.render
m.render(document.body, m(MyComponent))

// don't wrap the component for m.mount
m.mount(document.body, MyComponent)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T132757Z" creationid="shibukawa.yoshiki" creationdate="20170206T132757Z">
        <seg>// m.renderのためにコンポーネントをm()でラップする
m.render(document.body, m(MyComponent))

// m.mountはコンポーネントをそのまま使用できる
m.mount(document.body, MyComponent)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Calling .map doesn't throw an error because we defined the initial value to be an empty array, instead of undefined</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161403Z" creationid="shibukawa.yoshiki" creationdate="20150415T001934Z">
        <seg>//初期値としてundefinedに代わりに空の配列を定義したため、この.mapはエラーにならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Create a Select2 progrssively enhanced SELECT element</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132050Z" creationid="shibukawa.yoshiki" creationdate="20160101T132050Z">
        <seg>//SELECTエレメントの拡張であるSelect2を作成します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Note that the '#' is not required in `href`, thanks to the `config` setting.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013325Z" creationid="shibukawa.yoshiki" creationdate="20150410T013325Z">
        <seg>//`config`の設定を使うことで、`href`内に'#'を書かなくてもよくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Set the value to the selected option</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132916Z" creationid="shibukawa.yoshiki" creationdate="20160101T132916Z">
        <seg>// 選択されているオプションを設定します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//This is a simplication for the sake of the example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062229Z" creationid="shibukawa.yoshiki" creationdate="20150502T062229Z">
        <seg>//これはサンプル用として単純化している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//This view gets rendered before the request above completes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161147Z" creationid="shibukawa.yoshiki" creationdate="20150415T001852Z">
        <seg>//このビューはデータが利用可能になる前にレンダリングされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Typically, values are modified via model methods,</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071245Z" creationid="shibukawa.yoshiki" creationdate="20150502T071245Z">
        <seg>//通常はモデルのメソッドを使って値を変更する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//`background` option example
var component = m.component({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114008Z" creationid="shibukawa.yoshiki" creationdate="20150502T114008Z">
        <seg>//`background`オプションのサンプル
var component = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a FP-friendly console.log
var log = function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161428Z" creationid="shibukawa.yoshiki" creationdate="20150414T175127Z">
        <seg>//関数プログラミングと相性の良いconsole.log
var log = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a component without a controller
var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072107Z" creationid="shibukawa.yoshiki" creationdate="20150502T072107Z">
        <seg>//コントローラなしのコンポーネント
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a contrived example of bi-directional data binding
var User = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125823Z" creationid="shibukawa.yoshiki" creationdate="20150502T125823Z">
        <seg>//双方向データバインディングのサンプル
var User = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a data store
var name = m.prop("")

//binding the data store in a view
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014141Z" creationid="shibukawa.yoshiki" creationdate="20150413T014125Z">
        <seg>//データストア
var name = m.prop("")

//データをビューにバインド
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a menu template
var menu = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134837Z" creationid="shibukawa.yoshiki" creationdate="20150413T134837Z">
        <seg>//メニューテンプレート
var menu = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a running list of todos</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161604Z" creationid="shibukawa.yoshiki" creationdate="20150407T161555Z">
        <seg>//アクティブなToDoのリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a sample component
var Dashboard = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135145Z" creationid="shibukawa.yoshiki" creationdate="20150502T135145Z">
        <seg>//サンプルコンポーネント
var Dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a sample module
var dashboard = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003122Z" creationid="shibukawa.yoshiki" creationdate="20150410T003122Z">
        <seg>//サンプルモジュール
var dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a simple MVC example

//a sample model that exposes a value
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062209Z" creationid="shibukawa.yoshiki" creationdate="20150502T062135Z">
        <seg>//シンプルなMVCモデル

//値を公開するサンプルのモデル
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a slot to store the name of a new todo before it is created</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161736Z" creationid="shibukawa.yoshiki" creationdate="20150407T161736Z">
        <seg>//新しいToDoを作成する前の、入力中のToDoの名前を保持するスロット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//add one more user to the response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175149Z" creationid="shibukawa.yoshiki" creationdate="20150414T175149Z">
        <seg>//レスポンスにユーザをもう一人追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//adds a todo to the list, and clears the description field for user convenience</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161944Z" creationid="shibukawa.yoshiki" creationdate="20150407T161944Z">
        <seg>//ToDoをリストに登録し、ユーザが使いやすいようにdescriptionフィールドをクリアする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//alerts the title of the body element when it's clicked</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140700Z" creationid="shibukawa.yoshiki" creationdate="20150414T140700Z">
        <seg>//bodyエレメントのタイトルがクリックされたらアラートを出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//an empty Mithril component
var myComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040256Z" creationid="shibukawa.yoshiki" creationdate="20150502T040256Z">
        <seg>//空のMithrilコンポーネント
var myModule = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//an expensive-to-initialize DOM element</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134955Z" creationid="shibukawa.yoshiki" creationdate="20150413T134955Z">
        <seg>//最初期化が非常に高価(つもり)のDOMエレメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume the file comes from an HTML5 drag-n-drop event
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175511Z" creationid="shibukawa.yoshiki" creationdate="20150414T175511Z">
        <seg>//ファイルはHTML5のドラッグアンドドロップイベントで渡されたとする
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume the variable `link` came from a web service
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //yields &lt;a href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002350Z" creationid="shibukawa.yoshiki" creationdate="20150413T002336Z">
        <seg>//この`link`変数の値はウェブサービスから返ってきた値という想定
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //&lt;a href="http://google.com"&gt;Google&lt;/a&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume this content comes from the server
var content = "&lt;h1&gt;Error: invalid user&lt;/h1&gt;";

m.render("body", [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015415Z" creationid="shibukawa.yoshiki" creationdate="20150416T015355Z">
        <seg>//サーバから送られてきたコンテンツとする
var content = "&lt;h1&gt;エラー: ユーザ名が違います&lt;/h1&gt;";

m.render("body", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//asynchronous service
var greetAsync = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135205Z" creationid="shibukawa.yoshiki" creationdate="20150415T135205Z">
        <seg>//非同期サービス
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//avoid using this idiom
m("li", selected ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144408Z" creationid="shibukawa.yoshiki" creationdate="20150413T144340Z">
        <seg>//このイディオムは避けること
m("li", selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//binding a model value to an input in a template
m("input", {value: todo.vm.description()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014920Z" creationid="shibukawa.yoshiki" creationdate="20150408T014920Z">
        <seg>//モデルの値と、テンプレート内のテキスト入力を結びつける
m("input", {value: todo.vm.description()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//by default `e` would be caught by Mithril's promise exception monitor and rethrown to the console</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181341Z" creationid="shibukawa.yoshiki" creationdate="20150414T181341Z">
        <seg>//デフォルトでは`e`はMithrilのpromiseの例外モニタがキャッチして、コンソールに向けて再度投げる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//controller
var controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124657Z" creationid="shibukawa.yoshiki" creationdate="20150410T124657Z">
        <seg>//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//declare a component
var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075737Z" creationid="shibukawa.yoshiki" creationdate="20150502T075737Z">
        <seg>//コンポーネント宣言
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var a_name = m.prop("John");

//read the value
var a = a_name(); //a == "John"

//set the value to `Mary`
a_name("Mary"); //Mary

//read the value
var b = a_name(); //b == "Mary"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040805Z" creationid="shibukawa.yoshiki" creationdate="20150407T150547Z">
        <seg>//'John'を初期値として、getter-setterを定義する
var a_name = m.prop("John");

//値を取得する
var a = a_name(); //a == "John"

//値を`Mary`に設定する
a_name("Mary"); //Mary

//値を取得する
var b = a_name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var name = m.prop("John");

//read the value
var a = name(); //a == "John"

//set the value to `Mary`
name("Mary"); //Mary

//read the value
var b = name(); //b == "Mary"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134314Z" creationid="shibukawa.yoshiki" creationdate="20150414T134217Z">
        <seg>/`John`という値でgetter-setterを初期化
var name = m.prop("John");

//値を取得する
var a = name(); //a == "John"

//値を`Mary`に設定する
name("Mary"); //Mary

//値を取得する
var b = name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define some helper functions to be called from the view</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081234Z" creationid="shibukawa.yoshiki" creationdate="20150502T081234Z">
        <seg>//ビューから呼ばれるヘルパー関数をいくつか定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define the view-model
todo.vm = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161524Z" creationid="shibukawa.yoshiki" creationdate="20150407T161524Z">
        <seg>//ビュー・モデルの定義
todo.vm = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = m.component({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114130Z" creationid="shibukawa.yoshiki" creationdate="20150502T114130Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130834Z" creationid="shibukawa.yoshiki" creationdate="20150502T130834Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//don't redraw if we did once already</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123518Z" creationid="shibukawa.yoshiki" creationdate="20150413T123518Z">
        <seg>//一度描画したら再描画はしない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//don't wait for this service; redraw right away</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135932Z" creationid="shibukawa.yoshiki" creationdate="20150415T135932Z">
        <seg>//サービスを待たずに即座に再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//dynamic variables are not updated here</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124628Z" creationid="shibukawa.yoshiki" creationdate="20150416T124628Z">
        <seg>//ここの動的変数は更新されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//dynamic variables here still update on every redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124654Z" creationid="shibukawa.yoshiki" creationdate="20150416T124654Z">
        <seg>//ここの動的変数は再描画のたびに更新される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//here's the view
m("table", [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152907Z" creationid="shibukawa.yoshiki" creationdate="20150408T152907Z">
        <seg>//これがビュー
m("table", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//if the location bar is "http://example.com/?/foo/bar"
//and m.route.mode is `search`
//then `currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172156Z" creationid="shibukawa.yoshiki" creationdate="20150414T172156Z">
        <seg>//もしロケーションバーが"http://example.com/?/foo/bar"
//で、m.route.modeが`search`の場合は、
//`currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//in the first redraw, there's no user, so ensure we don't throw an error</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134843Z" creationid="shibukawa.yoshiki" creationdate="20150502T134843Z">
        <seg>//最初の描画時はユーザがいないが、エラーにはならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//in this case, it simply assumes data has changed the first time, and never changes after that.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124552Z" creationid="shibukawa.yoshiki" creationdate="20150416T124552Z">
        <seg>//この場合、初回だけ変更されてその後は変更されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//initialize our view-model
todo.vm.init();

todo.vm.description(); //[empty string]

//try adding a to-do
todo.vm.add(todo.vm.description);
todo.vm.list.length; //0, because you can't add a to-do with an empty description

//add it properly
todo.vm.description("Write code");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163852Z" creationid="shibukawa.yoshiki" creationdate="20150407T163731Z">
        <seg>//ビュー・モデルの初期化
todo.vm.init();

todo.vm.description(); //[空文字列]

//Todoを登録してみる
todo.vm.add(todo.vm.description);
todo.vm.list.length; //空のdescriptionは登録できないので、0

//正しく登録できた
todo.vm.description("コードを書く");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//list of users to show</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021945Z" creationid="shibukawa.yoshiki" creationdate="20150412T021945Z">
        <seg>//ユーザ一覧のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model
var Page = {
	list: function() {
		return m.request({method: "GET", url: "pages.json"});
	}
};

var Demo = {
	//controller
	controller: function() {
		var pages = Page.list();
		return {
			pages: pages,
			rotate: function() {
				pages().push(pages().shift());
			}
		}
	},

	//view
	view: function(ctrl) {
		return m("div", [
			ctrl.pages().map(function(page) {
				return m("a", {href: page.url}, page.title);
			}),
			m("button", {onclick: ctrl.rotate}, "Rotate links")
		]);
	}
};


//initialize
m.mount(document.getElementById("example"), Demo);</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T115728Z" creationid="shibukawa.yoshiki" creationdate="20160101T115718Z">
        <seg>//モデル
var Page = {
	list: function() {
		return m.request({method: "GET", url: "pages.json"});
	}
};

var Demo = {
	//controller
	controller: function() {
		var pages = Page.list();
		return {
			pages: pages,
			rotate: function() {
				pages().push(pages().shift());
			}
		}
	},

	//view
	view: function(ctrl) {
		return m("div", [
			ctrl.pages().map(function(page) {
				return m("a", {href: page.url}, page.title);
			}),
			m("button", {onclick: ctrl.rotate}, "Rotate links")
		]);
	}
};


//初期化
m.mount(document.getElementById("example"), Demo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model
var User = {}

User.listEven = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124209Z" creationid="shibukawa.yoshiki" creationdate="20150410T124209Z">
        <seg>//モデル
var User = {}

User.listEven = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model
var saved = false
function save(e) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144851Z" creationid="shibukawa.yoshiki" creationdate="20150416T144851Z">
        <seg>//モデル
var saved = false
function save(e) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model layer observer
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031145Z" creationid="shibukawa.yoshiki" creationdate="20150502T031145Z">
        <seg>//モデルレイヤのオブザーバ
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//nested component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080106Z" creationid="shibukawa.yoshiki" creationdate="20150502T080106Z">
        <seg>//ネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//note how the controller does not handle the input arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081219Z" creationid="shibukawa.yoshiki" creationdate="20150502T081216Z">
        <seg>//このコントローラは引数には触れない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//note that we are not updating the value of the `name` getter-setter via an event handler
//redraws will always overwrite the current UI value with the value of `name()`
m("input", {value: name()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015357Z" creationid="shibukawa.yoshiki" creationdate="20150413T015357Z">
        <seg>//このサンプルではイベントハンドラが`name` getter-setterの値を変更することはない
//再描画があるたびに現在のUI上の値が`name()`の値を使って書き換えられる
m("input", {value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//now `deferred.resolve` has been called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135304Z" creationid="shibukawa.yoshiki" creationdate="20150415T135304Z">
        <seg>//ここで `deferred.resolve` が呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//only runs once, even if you move back and forth between `/` and `/contact`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135135Z" creationid="shibukawa.yoshiki" creationdate="20150413T135135Z">
        <seg>// `/` と`/contact` の間を何度行き来しても、一度だけ実行される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//onunload's preventDefault was called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092405Z" creationid="shibukawa.yoshiki" creationdate="20150502T092405Z">
        <seg>//onunloadのpreventDefaultが呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//pressing the button reverses the list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080401Z" creationid="shibukawa.yoshiki" creationdate="20150502T080401Z">
        <seg>//ボタンを押すとリストの順序が逆転する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//private store
var description;

//public getter-setter
this.description = function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002509Z" creationid="shibukawa.yoshiki" creationdate="20150409T002456Z">
        <seg>//プライベート変数
var description;

//パブリックなgetter-setter
this.description = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//rather than modified directly</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071253Z" creationid="shibukawa.yoshiki" creationdate="20150502T071253Z">
        <seg>//ここでは直接変更している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//redraw again</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135940Z" creationid="shibukawa.yoshiki" creationdate="20150415T135940Z">
        <seg>//再び再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//refactor the binding to a simple helper
var binds = function(prop) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015537Z" creationid="shibukawa.yoshiki" creationdate="20150413T015537Z">
        <seg>//バインディングをヘルパ関数にリファクタリング
var binds = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//refactor the binding to a simple helper
var input = function(prop) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015642Z" creationid="shibukawa.yoshiki" creationdate="20150413T015642Z">
        <seg>//バインディングをシンプルなヘルパにリファクタリング
var input = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//setting `background` allows the component to redraw immediately, without waiting for the request to complete</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114043Z" creationid="shibukawa.yoshiki" creationdate="20150502T114043Z">
        <seg>//`background`を設定すると、リクエストの完了を待たずにすぐに再描画を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//simply pass the FormData object intact to the underlying XMLHttpRequest, instead of JSON.stringify'ing it</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034320Z" creationid="shibukawa.yoshiki" creationdate="20150502T034320Z">
        <seg>//JSON.stringifyをしないで、FormDataをそのままバックエンドのXMLHttpRequestに渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//standalone usage
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140641Z" creationid="shibukawa.yoshiki" creationdate="20150414T140641Z">
        <seg>//単独での使用
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//standalone usage
var greetAsync = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135043Z" creationid="shibukawa.yoshiki" creationdate="20150415T135043Z">
        <seg>//単体での利用
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//swallow all errors
m.deferred.onerror = function() {}

//only log errors
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174841Z" creationid="shibukawa.yoshiki" creationdate="20150415T174826Z">
        <seg>//すべてのエラーを無視する
m.deferred.onerror = function() {}

//エラーを単にログに出力する
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//tell Mithril to wait for this service to complete before redrawing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135537Z" creationid="shibukawa.yoshiki" creationdate="20150415T135537Z">
        <seg>//Mithrilにサービス呼び出しが終わるまで再描画を待つように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//test a transformation function in the controller
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//test the template
var tpl = TemperatureConverter.view(ctrl, {value: 273.15})
assert(tpl.children[1] == 0)

//test with real DOM
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(ctrl, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142610Z" creationid="shibukawa.yoshiki" creationdate="20160412T142535Z">
        <seg>//コントローラのtransformation関数のテスト
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//テンプレートのテスト
var tpl = TemperatureConverter.view(ctrl, {value: 273.15})
assert(tpl.children[1] == 0)

//実際のDOMを使ったテスト
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(ctrl, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//the key ensures the components aren't recreated from scratch, if they merely exchanged places</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080435Z" creationid="shibukawa.yoshiki" creationdate="20150502T080435Z">
        <seg>//キーがあると、場所の移動時にDOMが再生成されるのを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//the service is done, tell Mithril that it may redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135600Z" creationid="shibukawa.yoshiki" creationdate="20150415T135600Z">
        <seg>//サービスが完了したら、Mithrilに再描画するように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//the two lines below are equivalent</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T133918Z" creationid="shibukawa.yoshiki" creationdate="20160101T133918Z">
        <seg>//以下の2行は等価です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this allows config contexts to live across route changes, if its element does not need to be recreated by the diff</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143800Z" creationid="shibukawa.yoshiki" creationdate="20150416T143800Z">
        <seg>//これにより、エレメントの再生成が不要な時は、configコンテキストがラウト変更時にも破棄されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this causes a redraw, since event handlers active auto-redrawing by default</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144817Z" creationid="shibukawa.yoshiki" creationdate="20150416T144817Z">
        <seg>//デフォルトでイベントハンドラは自動再描画を起動するため再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this component will attempt to diff its template when routing, as opposed to re-creating the view from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130645Z" creationid="shibukawa.yoshiki" creationdate="20150502T130645Z">
        <seg>//このコンポーネントはラウトの変更時にもゼロからビューを作りなおすのではなく、差分検知を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this link can use any of Mithril's routing system modes
//(i.e. it can use either the hash, the querystring or the pathname as the router implementation)
//without needing to hard-code any syntax (`#` or `?`) in the `href` attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124305Z" creationid="shibukawa.yoshiki" creationdate="20150413T124131Z">
        <seg>//このリンクはどのMithrilのラウティングシステムのモードでも使用できる。
//ラウティングのモードにはhash, querystring, pathnameがあるが、
//`href`属性で、ラウティングの文法(`#`, `?`)をハードコードする必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this new error follows Promises/A+ specifications and triggers a rejection in the downstream promises without hitting the console.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181833Z" creationid="shibukawa.yoshiki" creationdate="20150414T181833Z">
        <seg>//このエラーはPromises/A+の仕様にしたがって下流のpromiseのリジェクトに渡される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this only runs once in order to boost performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124613Z" creationid="shibukawa.yoshiki" creationdate="20150416T124613Z">
        <seg>//パフォーマンスの最適化のために、一度しか実行されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this service waits 1 second, logs "hello" and then notifies the view that
//it may start redrawing (if no other asynchronous operations are pending)
var doStuff = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192927Z" creationid="shibukawa.yoshiki" creationdate="20150411T192927Z">
        <seg>//このサービスは1秒間待ってログに"hello"と出力し、その後ビューに
//再描画を行うように知らせています (他の非同期処理により延期されないかぎり)
var doStuff = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this view renders twice (once immediately, and once after the request above completes)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012109Z" creationid="shibukawa.yoshiki" creationdate="20150415T012109Z">
        <seg>//このビューは初回と上記のリクエストの完了後の2回再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//usage demo 1: standalone multipart/form-data upload when files are dropped into the component
var Demo1 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034723Z" creationid="shibukawa.yoshiki" creationdate="20150502T034723Z">
        <seg>//デモ1: コンポーネントにファイルがドロップされた時にmultipart/form-dataでアップロード
var Demo1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//usage demo 2: upload as base-64 encoded data url from a parent form
var Demo2 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034820Z" creationid="shibukawa.yoshiki" creationdate="20150502T034820Z">
        <seg>//デモ2: base64のデータURLとしてデータをアップロード
var Demo2 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//we don't care about other keys, so don't redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144836Z" creationid="shibukawa.yoshiki" creationdate="20150416T144836Z">
        <seg>//他のキーについては無視したいので、再描画も行わない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//we only want to make this call once</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084510Z" creationid="shibukawa.yoshiki" creationdate="20150502T084510Z">
        <seg>//このコードは一度しか呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a href="/item1"&gt;item 1&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002523Z" creationid="shibukawa.yoshiki" creationdate="20150413T002523Z">
        <seg>&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;fetch()&lt;/c1&gt;&lt;/a0&gt; is a newer Web API for fetching resources from servers, similar to &lt;c2&gt;XMLHttpRequest&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024910Z" creationid="shibukawa.yoshiki" creationdate="20170220T024910Z">
        <seg>&lt;a0&gt;&lt;c1&gt;fetch()&lt;/c1&gt;&lt;/a0&gt;はサーバーからリソースを取得してくるための、新しいウェブのAPIです。&lt;c2&gt;XMLHttpRequest&lt;/c2&gt;と似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;m.mount&lt;/c1&gt;&lt;/a0&gt; (if your app only has one page)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071721Z" creationid="shibukawa.yoshiki" creationdate="20150502T071721Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.mount&lt;/c1&gt;&lt;/a0&gt; (ページを1つしか持たない場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt; is a simple but surprisingly versatile tool: it's functionally composable, it enables &lt;a2&gt;uniform data access&lt;/a2&gt; and allows a higher degree of decoupling when major refactoring is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114149Z" creationid="shibukawa.yoshiki" creationdate="20150409T001957Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt;はシンプルですが、とても幅広く使えるツールです。関数型のパラダイムを使えるようにしたり、&lt;a2&gt;データアクセスの統一化&lt;/a2&gt;をしたり、リファクタリングが必要になったときに簡単に行えるように高度な疎結合化をするのに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt; is simply a factory for a getter-setter function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150505Z" creationid="shibukawa.yoshiki" creationdate="20150407T150505Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt;はgetter-setter関数を作るための、単純なファクトリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt; (if you are integrating Mithril's rendering engine into a larger framework and wish to manage redrawing yourself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071757Z" creationid="shibukawa.yoshiki" creationdate="20150502T071757Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt; (Mithrilのレンダリングエンジンを他のシステムに統合し、レンダリングを自分で制御したい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt; (if you are building a single-page application that has multiple pages)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071657Z" creationid="shibukawa.yoshiki" creationdate="20150502T071657Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt; (複数ページ持つシングルページアプリケーションを作りたい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;s1&gt;○&lt;/s1&gt; Mithril&lt;/a0&gt; &lt;a2&gt;Guide&lt;/a2&gt; &lt;a3&gt;API&lt;/a3&gt; &lt;a4&gt;Community&lt;/a4&gt; &lt;a5&gt;Learn&lt;/a5&gt; &lt;a6&gt;Download&lt;/a6&gt; &lt;a7&gt;Github&lt;/a7&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132024Z" creationid="shibukawa.yoshiki" creationdate="20150407T131933Z">
        <seg>&lt;a0&gt;&lt;s1&gt;○&lt;/s1&gt; Mithril&lt;/a0&gt; &lt;a2&gt;ガイド&lt;/a2&gt; &lt;a3&gt;API&lt;/a3&gt; &lt;a4&gt;コミュニティ&lt;/a4&gt; &lt;a5&gt;もっと知る&lt;/a5&gt; &lt;a6&gt;ダウンロード&lt;/a6&gt; &lt;a7&gt;Github&lt;/a7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Bower&lt;/a0&gt; is a frontend package manager built in &lt;a1&gt;NodeJS&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142356Z" creationid="shibukawa.yoshiki" creationdate="20160412T142356Z">
        <seg>&lt;a0&gt;Bower&lt;/a0&gt;は&lt;a1&gt;NodeJS&lt;/a1&gt;で作成されたパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Component&lt;/a0&gt; is another package manager for &lt;a1&gt;NodeJS&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235559Z" creationid="shibukawa.yoshiki" creationdate="20150407T235559Z">
        <seg>&lt;a0&gt;Component&lt;/a0&gt;も、&lt;a1&gt;NodeJS&lt;/a1&gt;向けのパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;ES5 Shim&lt;/a0&gt; or Mozilla.org's &lt;a1&gt;Array::indexOf&lt;/a1&gt;, &lt;a2&gt;Array::map&lt;/a2&gt; and &lt;a3&gt;Object::keys&lt;/a3&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014856Z" creationid="shibukawa.yoshiki" creationdate="20150417T014856Z">
        <seg>&lt;a0&gt;ES5 Shim&lt;/a0&gt;もしくは、Mozillaの&lt;a1&gt;Array::indexOf&lt;/a1&gt;、&lt;a2&gt;Array::map&lt;/a2&gt;、&lt;a3&gt;Object::keys&lt;/a3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Guide&lt;/a0&gt; &lt;a1&gt;API&lt;/a1&gt; &lt;a2&gt;Chat&lt;/a2&gt; &lt;a3&gt;Github&lt;/a3&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024549Z" creationid="shibukawa.yoshiki" creationdate="20170131T024549Z">
        <seg>&lt;a0&gt;ガイド&lt;/a0&gt; &lt;a1&gt;API&lt;/a1&gt; &lt;a2&gt;チャット&lt;/a2&gt; &lt;a3&gt;Github&lt;/a3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;RESTful&lt;/a0&gt; architectures are popular with API providers, and &lt;a1&gt;service oriented architectures&lt;/a1&gt; are often required where there are lots of highly transactional workflows.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024701Z" creationid="shibukawa.yoshiki" creationdate="20170220T024701Z">
        <seg>API提供者の間では、&lt;a0&gt;RESTful&lt;/a0&gt;アーキテクチャが人気ですし、トランザクションを高度に扱う必要があれば&lt;a1&gt;サービス指向アーキテクチャ&lt;/a1&gt;が必要となるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Read more&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135001Z" creationid="shibukawa.yoshiki" creationdate="20150407T135001Z">
        <seg>&lt;a0&gt;より詳しい説明&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;v0.2.0&lt;/a0&gt; - improved components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140707Z" creationid="shibukawa.yoshiki" creationdate="20160412T140707Z">
        <seg>&lt;a0&gt;v0.2.0&lt;/a0&gt; - コンポーネントの改善</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a2&gt;IE9 and lower&lt;/a2&gt; do not support this feature and will gracefully degrade to page refreshes instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015322Z" creationid="shibukawa.yoshiki" creationdate="20150417T015218Z">
        <seg>&lt;a2&gt;IE9とそれ以下のブラウザ&lt;/a2&gt;はこの機能をサポートしていないため、リフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt; forces a redraw to happen in the next available frame (or optionally, it can redraw immediately for synchronous processing).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192020Z" creationid="shibukawa.yoshiki" creationdate="20150411T192020Z">
        <seg>&lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt;を呼び出すと次のフレーム更新時に強制的に再描画を行います。また、オプションで同期処理として再描画を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a6&gt;&lt;c7&gt;m.redraw.strategy&lt;/c7&gt;&lt;/a6&gt; can change the way Mithril runs the next scheduled redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000533Z" creationid="shibukawa.yoshiki" creationdate="20150506T000533Z">
        <seg>&lt;a6&gt;&lt;c7&gt;m.redraw.strategy&lt;/c7&gt;&lt;/a6&gt;を使うと、Mithrilが次に再描画を計画する方法を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;body&gt;&lt;/body&gt;
&lt;script src="http://unpkg.com/mithril/mithril.js"&gt;&lt;/script&gt;
&lt;script&gt;
var root = document.body

// your code goes here!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025531Z" creationid="shibukawa.yoshiki" creationdate="20170131T025531Z">
        <seg>&lt;body&gt;&lt;/body&gt;
&lt;script src="http://unpkg.com/mithril/mithril.js"&gt;&lt;/script&gt;
&lt;script&gt;
var root = document.body

// ここにコードを書きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;button onclick={app.vm.add}&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013912Z" creationid="shibukawa.yoshiki" creationdate="20150417T013912Z">
        <seg>&lt;button onclick={app.vm.add}&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;button&gt;A button&lt;/button&gt;
&lt;/main&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030509Z" creationid="shibukawa.yoshiki" creationdate="20170131T030509Z">
        <seg>&lt;button&gt;ボタン&lt;/button&gt;
&lt;/main&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;button&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013845Z" creationid="shibukawa.yoshiki" creationdate="20150408T013845Z">
        <seg>&lt;button&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;"/grid?sortby=date"&lt;/c0&gt; - here, &lt;c1&gt;m.route.param("sortby")&lt;/c1&gt; returns &lt;c2&gt;"date"&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170756Z" creationid="shibukawa.yoshiki" creationdate="20150414T170756Z">
        <seg>&lt;c0&gt;"/grid?sortby=date"&lt;/c0&gt; - ここでは、&lt;c1&gt;m.route.param("sortby")&lt;/c1&gt;は&lt;c2&gt;"date"&lt;/c2&gt;を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;"/path/to/page/:id"&lt;/c0&gt; - here, &lt;c1&gt;id&lt;/c1&gt; is the name of the route parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170625Z" creationid="shibukawa.yoshiki" creationdate="20150414T170618Z">
        <seg>&lt;c0&gt;"/path/to/page/:id"&lt;/c0&gt; - ここでは、&lt;c1&gt;id&lt;/c1&gt;がラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;"all"&lt;/c0&gt; - recreates the DOM tree from scratch</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152312Z" creationid="shibukawa.yoshiki" creationdate="20150416T152312Z">
        <seg>&lt;c0&gt;"all"&lt;/c0&gt; - すべて破棄してDOMツリーを再構築する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;"diff"&lt;/c0&gt; - updates only DOM elements if needed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152326Z" creationid="shibukawa.yoshiki" creationdate="20150416T152326Z">
        <seg>&lt;c0&gt;"diff"&lt;/c0&gt; - 必要があればDOMエレメントを更新する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;"none"&lt;/c0&gt; - leaves the DOM tree intact</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152341Z" creationid="shibukawa.yoshiki" creationdate="20150416T152341Z">
        <seg>&lt;c0&gt;"none"&lt;/c0&gt; - DOMツリーを変更せずにそのままにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ContactsWidget&lt;/c0&gt; is the top level module being rendered to &lt;c1&gt;document.body&lt;/c1&gt;, and it is the module that has the responsibility of talking to our Model entity &lt;c2&gt;Contact&lt;/c2&gt;, which we defined earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001544Z" creationid="shibukawa.yoshiki" creationdate="20150502T001544Z">
        <seg>&lt;c0&gt;ContactsWidget&lt;/c0&gt;は&lt;c1&gt;document.body&lt;/c1&gt;にレンダリングされる、最上位のモジュールです。また、これは先に定義していた&lt;c2&gt;Contact&lt;/c2&gt;モデルのエンティティと話をする責務を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt; calls can be aborted before they resolve (e.g. to avoid race conditions in for instant search UIs).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T025128Z" creationid="shibukawa.yoshiki" creationdate="20170220T025128Z">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt;の呼び出しは、完了前に中断させられることがあります。例えば、簡易検索UIの複数リクエストの競合を避けるために必要となることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt; is supported by all browsers, whereas &lt;c1&gt;fetch()&lt;/c1&gt; is not supported by Internet Explorer, Safari and Android (non-Chromium).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T030039Z" creationid="shibukawa.yoshiki" creationdate="20170220T025249Z">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt;はすべてのブラウザで対応していますが、&lt;c1&gt;fetch()&lt;/c1&gt;はInternet Explorer, Safari, ChromiumでないAndroidではサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt; provides hooks for progress listeners for long running requests (e.g. file uploads).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T025207Z" creationid="shibukawa.yoshiki" creationdate="20170220T025207Z">
        <seg>&lt;c0&gt;XMLHttpRequest&lt;/c0&gt;は長時間かかる進捗情報を取得するためのフックを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;config&lt;/c0&gt; function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033732Z" creationid="shibukawa.yoshiki" creationdate="20170131T033732Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;fetch&lt;/c0&gt; is not fully standardized yet, and may be subject to specification changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T025019Z" creationid="shibukawa.yoshiki" creationdate="20170220T025019Z">
        <seg>&lt;c0&gt;fetch&lt;/c0&gt;はまだ十分に標準化が行われていません。そのため、仕様の変更の影響を受ける可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;git add&lt;/c0&gt; called on bundle output</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054311Z" creationid="shibukawa.yoshiki" creationdate="20170220T054311Z">
        <seg>バンドル出力に対する&lt;c0&gt;git add&lt;/c0&gt;コマンド実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;git push --follow-tags&lt;/c0&gt; pushes up new version commit &amp; tag to github</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054428Z" creationid="shibukawa.yoshiki" creationdate="20170220T054428Z">
        <seg>&lt;c0&gt;git push --follow-tags&lt;/c0&gt;を使って新しいバージョンのコミットとタグをgithubにプッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;hash&lt;/c0&gt; mode uses the hash (i.e. &lt;c1&gt;#&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170025Z" creationid="shibukawa.yoshiki" creationdate="20150414T170025Z">
        <seg>&lt;c0&gt;hash&lt;/c0&gt;モードはハッシュ(&lt;c1&gt;#以降&lt;/c1&gt;)を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;hash&lt;/c0&gt; mode uses the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005129Z" creationid="shibukawa.yoshiki" creationdate="20150410T005129Z">
        <seg>&lt;c0&gt;hash&lt;/c0&gt;モードはハッシュを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m(component, ...args)&lt;/c0&gt; can now be used as a shorthand for &lt;c1&gt;m.component(component, ...args)&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140251Z" creationid="shibukawa.yoshiki" creationdate="20160412T140251Z">
        <seg>&lt;c0&gt;m(component, ...args)&lt;/c0&gt;を&lt;c1&gt;m.component(component, ...args)&lt;/c1&gt;の短縮形として使えるようになった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.component&lt;/c0&gt; removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034030Z" creationid="shibukawa.yoshiki" creationdate="20170131T033722Z">
        <seg>&lt;c0&gt;m.component&lt;/c0&gt;が削除された</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.deferred&lt;/c0&gt; removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034549Z" creationid="shibukawa.yoshiki" creationdate="20170131T034528Z">
        <seg>&lt;c0&gt;m.deferred&lt;/c0&gt;が削除された</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.module&lt;/c0&gt; has been renamed &lt;c1&gt;m.mount&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140924Z" creationid="shibukawa.yoshiki" creationdate="20160412T140924Z">
        <seg>&lt;c0&gt;m.module&lt;/c0&gt;は&lt;c1&gt;m.mount&lt;/c1&gt;へとリネームされた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.mount()&lt;/c0&gt; and &lt;c1&gt;m.route()&lt;/c1&gt; still automatically redraw after a DOM event handler runs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120724Z" creationid="shibukawa.yoshiki" creationdate="20170131T120724Z">
        <seg>&lt;c0&gt;m.mount()&lt;/c0&gt;と&lt;c1&gt;m.route()&lt;/c1&gt;は、引き続きDOMイベントハンドラの実行後に再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.prop&lt;/c0&gt; can also be used in conjunction with &lt;a1&gt;&lt;c2&gt;m.request&lt;/c2&gt;&lt;/a1&gt; and &lt;a3&gt;&lt;c4&gt;m.deferred&lt;/c4&gt;&lt;/a3&gt; to bind data on completion of an asynchronous operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134821Z" creationid="shibukawa.yoshiki" creationdate="20150414T134821Z">
        <seg>&lt;c0&gt;m.prop&lt;/c0&gt;は、&lt;a1&gt;&lt;c2&gt;m.request&lt;/c2&gt;&lt;/a1&gt;や&lt;a3&gt;&lt;c4&gt;m.deferred&lt;/c4&gt;&lt;/a3&gt;と組み合わせて、非同期操作の結果に対してデータを束縛することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.prop&lt;/c0&gt; removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034024Z" creationid="shibukawa.yoshiki" creationdate="20170131T033714Z">
        <seg>&lt;c0&gt;m.prop&lt;/c0&gt;が削除された</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.redraw&lt;/c0&gt; is a method that allows you to render a template outside the scope of Mithril's auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015835Z" creationid="shibukawa.yoshiki" creationdate="20150421T015835Z">
        <seg>&lt;c0&gt;m.redraw&lt;/c0&gt;を使うと、Mithrilの自動再描画システムのスコープ外から、再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.render&lt;/c0&gt; accepts a special low level SubtreeDirective object as a node in a virtual DOM tree: if a tree contains a node that looks exactly like the object below, Mithril will abort the diff algorithm for that node.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123617Z" creationid="shibukawa.yoshiki" creationdate="20150416T123617Z">
        <seg>&lt;c0&gt;m.render&lt;/c0&gt;は、特別なSubtreeDirectiveオブジェクトを仮想DOMツリーのノードとして受け取ることができます。もし、ツリーが次のようなオブジェクトを含んでいると、Mithrilはこのノードに対する差分検知アルゴリズムを中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.request()&lt;/c0&gt; exposes its underlying &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; object via the &lt;c2&gt;options.config&lt;/c2&gt; parameter, which allows you to attach event listeners to the XMLHttpRequest object:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T191210Z" creationid="shibukawa.yoshiki" creationdate="20170219T191210Z">
        <seg>&lt;c2&gt;options.config&lt;/c2&gt;パラメータを使うと、&lt;c0&gt;m.request()&lt;/c0&gt;の内部の&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;オブジェクトに触れる事ができます。これを使うと、XMLHttpRequestオブジェクトにイベントリスナーを付与するできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.request()&lt;/c0&gt; exposes its underlying &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; object via the &lt;c2&gt;options.config&lt;/c2&gt; parameter, which allows you to save a reference to that object and call its &lt;c3&gt;abort&lt;/c3&gt; method when required:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155230Z" creationid="shibukawa.yoshiki" creationdate="20170219T155230Z">
        <seg>&lt;c2&gt;options.config&lt;/c2&gt;パラメータを使うと、&lt;c0&gt;m.request()&lt;/c0&gt;の内部の&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;オブジェクトに触れる事ができます。これを使ってオブジェクトの参照を保存しておくことで、必要に応じて&lt;c3&gt;abort&lt;/c3&gt;メソッドを呼ぶこともができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route()&lt;/c0&gt; - returns the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152813Z" creationid="shibukawa.yoshiki" creationdate="20150414T152813Z">
        <seg>&lt;c0&gt;m.route()&lt;/c0&gt; - 現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route()&lt;/c0&gt; and anchor tags</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141239Z" creationid="shibukawa.yoshiki" creationdate="20170131T141239Z">
        <seg>&lt;c0&gt;m.route()&lt;/c0&gt;とアンカータグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route(element)&lt;/c0&gt; - an extension to link elements that unobtrusively abstracts away the routing mode</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153031Z" creationid="shibukawa.yoshiki" creationdate="20150414T153031Z">
        <seg>&lt;c0&gt;m.route(element)&lt;/c0&gt; - ラウトのモードを抽象化し、現在のモードで利用可能なエレメントの実リンクを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route(path)&lt;/c0&gt; - redirects to another route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152759Z" creationid="shibukawa.yoshiki" creationdate="20150414T152759Z">
        <seg>&lt;c0&gt;m.route(path)&lt;/c0&gt; - 他のラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route(rootElement, defaultRoute, routes)&lt;/c0&gt; - defines the available URLs in an application, and their respective components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135009Z" creationid="shibukawa.yoshiki" creationdate="20150502T135009Z">
        <seg>&lt;c0&gt;m.route(rootElement, defaultRoute, routes)&lt;/c0&gt; - アプリケーションで使用できるURLとその時にロードされるコンポーネントの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.route&lt;/c0&gt; and anchor tags</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034245Z" creationid="shibukawa.yoshiki" creationdate="20170131T034245Z">
        <seg>&lt;c0&gt;m.route&lt;/c0&gt;とアンカータグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.startComputation&lt;/c0&gt;/&lt;c1&gt;m.endComputation&lt;/c1&gt; removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034106Z" creationid="shibukawa.yoshiki" creationdate="20170131T034106Z">
        <seg>&lt;c0&gt;m.startComputation&lt;/c0&gt;/&lt;c1&gt;m.endComputation&lt;/c1&gt;の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m.sync&lt;/c0&gt; removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034538Z" creationid="shibukawa.yoshiki" creationdate="20170131T034538Z">
        <seg>&lt;c0&gt;m.sync&lt;/c0&gt;が削除された</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;package.json&lt;/c0&gt; and updated bundles are committed to git</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054334Z" creationid="shibukawa.yoshiki" creationdate="20170220T054334Z">
        <seg>&lt;c0&gt;package.json&lt;/c0&gt;と更新されたバンドルがgitにコミットされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;pathname&lt;/c0&gt; mode allows routing URLs that contain no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005430Z" creationid="shibukawa.yoshiki" creationdate="20150410T005430Z">
        <seg>&lt;c0&gt;pathname&lt;/c0&gt;モードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;pathname&lt;/c0&gt; mode allows routing URLs that contains no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170054Z" creationid="shibukawa.yoshiki" creationdate="20150414T170054Z">
        <seg>&lt;c0&gt;pathname&lt;/c0&gt;モードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;search&lt;/c0&gt; mode uses the querystring (i.e. &lt;c1&gt;?&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165825Z" creationid="shibukawa.yoshiki" creationdate="20150414T165825Z">
        <seg>&lt;c0&gt;search&lt;/c0&gt;モードはクエリー文字列 (&lt;c1&gt;?&lt;/c1&gt;以降)を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;search&lt;/c0&gt; mode uses the querystring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004858Z" creationid="shibukawa.yoshiki" creationdate="20150410T004858Z">
        <seg>&lt;c0&gt;search&lt;/c0&gt;モードはクエリー文字列を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;select2.config&lt;/c0&gt; is a factory that creates a &lt;c1&gt;config&lt;/c1&gt; function based on a given controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133322Z" creationid="shibukawa.yoshiki" creationdate="20150412T133322Z">
        <seg>&lt;c0&gt;select2.config&lt;/c0&gt;は、与えられたコントローラに対応する&lt;c1&gt;config&lt;/c1&gt;関数を作成するファクトリー関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;update&lt;/c0&gt; is the controller function itself, so defining it as a promise callback simply means that the controller is re-initialized after the previous asynchronous operation (&lt;c1&gt;Contact.save()&lt;/c1&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003837Z" creationid="shibukawa.yoshiki" creationdate="20150502T003837Z">
        <seg>&lt;c0&gt;update&lt;/c0&gt;はコントローラの関数そのものです。それをPromiseのコールバックとして定義するとということは、非同期操作(&lt;c1&gt;Contact.save()&lt;/c1&gt;)が完了したあとにコントローラを再初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt; used its own custom asynchronous contract object, exposed as &lt;c1&gt;m.deferred&lt;/c1&gt;, which was used as the basis for &lt;c2&gt;m.request&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045951Z" creationid="shibukawa.yoshiki" creationdate="20170201T045951Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、&lt;c1&gt;m.deferred&lt;/c1&gt;という名前でMithril自身が提供する非同期の契約オブジェクトが使われてきました。また、これは&lt;c2&gt;m.request&lt;/c2&gt;からも使用されていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt; is largely API-compatible with &lt;c1&gt;v0.2.x&lt;/c1&gt;, but there are some breaking changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033608Z" creationid="shibukawa.yoshiki" creationdate="20170131T033608Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt; は&lt;c1&gt;v0.2.x&lt;/c1&gt;と幅広くAPIの互換性がありますが、破壊的変更もいくつか行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;view()&lt;/c0&gt; parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034130Z" creationid="shibukawa.yoshiki" creationdate="20170131T034130Z">
        <seg>&lt;c0&gt;view()&lt;/c0&gt;パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;vnode.dom&lt;/c0&gt; points to the root DOM element of the component (&lt;c1&gt;&lt;div class="fancy"&gt;&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110306Z" creationid="shibukawa.yoshiki" creationdate="20170206T110306Z">
        <seg>&lt;c0&gt;vnode.dom&lt;/c0&gt;はコンポーネントのルートとなるDOMエレメント（&lt;c1&gt;&lt;div class="fancy"&gt;&lt;/c1&gt;）を指しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;vnode&lt;/c0&gt; equality checks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050859Z" creationid="shibukawa.yoshiki" creationdate="20170201T050859Z">
        <seg>&lt;c0&gt;vnode&lt;/c0&gt;同値性チェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;xlink&lt;/c0&gt; namespace required</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034622Z" creationid="shibukawa.yoshiki" creationdate="20170131T034622Z">
        <seg>&lt;c0&gt;xlink&lt;/c0&gt;名前空間が必要になった</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;{'/path/to/page/': pageComponent}&lt;/c0&gt; - a route with a basic pathname</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135713Z" creationid="shibukawa.yoshiki" creationdate="20150502T135713Z">
        <seg>&lt;c0&gt;{'/path/to/page/': pageComponent}&lt;/c0&gt; - 基本パス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;{'/path/to/page/:id': pageComponent}&lt;/c0&gt; - a route with a pathname that contains a dynamic parameter called &lt;c1&gt;id&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135725Z" creationid="shibukawa.yoshiki" creationdate="20150502T135725Z">
        <seg>&lt;c0&gt;{'/path/to/page/:id': pageComponent}&lt;/c0&gt; - &lt;c1&gt;id&lt;/c1&gt;と呼ばれる動的パラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;{'/user/:userId/book/:bookId': userBookComponent}&lt;/c0&gt; - a route with a pathname that contains two parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135735Z" creationid="shibukawa.yoshiki" creationdate="20150502T135735Z">
        <seg>&lt;c0&gt;{'/user/:userId/book/:bookId': userBookComponent}&lt;/c0&gt; - 2つのパラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;Home&lt;/c1&gt;, &lt;c2&gt;Login&lt;/c2&gt; and &lt;c3&gt;Dashboard&lt;/c3&gt; are components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135125Z" creationid="shibukawa.yoshiki" creationdate="20150502T135125Z">
        <seg>&lt;c1&gt;home&lt;/c1&gt;、&lt;c2&gt;login&lt;/c2&gt;、&lt;c3&gt;dashboard&lt;/c3&gt;はそれぞれコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;home&lt;/c1&gt;, &lt;c2&gt;login&lt;/c2&gt; and &lt;c3&gt;dashboard&lt;/c3&gt; are modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002830Z" creationid="shibukawa.yoshiki" creationdate="20150410T002811Z">
        <seg>&lt;c1&gt;home&lt;/c1&gt;、&lt;c2&gt;login&lt;/c2&gt;、&lt;c3&gt;dashboard&lt;/c3&gt;はそれぞれモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;e.target.files&lt;/c2&gt; is a list of &lt;c3&gt;File&lt;/c3&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155506Z" creationid="shibukawa.yoshiki" creationdate="20170219T155506Z">
        <seg>&lt;c2&gt;e.target.files&lt;/c2&gt;が&lt;c3&gt;File&lt;/c3&gt;オブジェクトの配列になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;oninit&lt;/c2&gt; is called, which calls &lt;c3&gt;m.request&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143540Z" creationid="shibukawa.yoshiki" creationdate="20170219T143540Z">
        <seg>初期化されると&lt;c2&gt;oninit&lt;/c2&gt;が呼び出され、この中で&lt;c3&gt;m.request&lt;/c3&gt;が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;v1.x&lt;/c2&gt; provides much more fine-grained control over the lifecycle of a vnode.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035011Z" creationid="shibukawa.yoshiki" creationdate="20170131T035011Z">
        <seg>&lt;c2&gt;v1.x&lt;/c2&gt;ではVノードのライフサイクルに対して適切な粒度の制御方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;v1.x&lt;/c3&gt; only supports &lt;c4&gt;m(component)&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034850Z" creationid="shibukawa.yoshiki" creationdate="20170131T034850Z">
        <seg>&lt;c3&gt;v1.x&lt;/c3&gt;では&lt;c4&gt;m(component)&lt;/c4&gt;だけがサポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;v1.x&lt;/c3&gt; uses Promises instead, and implements a &lt;a4&gt;polyfill&lt;/a4&gt; in non-supporting environments.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050035Z" creationid="shibukawa.yoshiki" creationdate="20170201T050035Z">
        <seg>&lt;c3&gt;v1.x&lt;/c3&gt;ではこれの代わりにPromiseが使われます。非サポートの環境のために&lt;a4&gt;polyfill&lt;/a4&gt;を使った実装になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;/edit/2&lt;/c5&gt; would also resolve to &lt;c6&gt;UserForm&lt;/c6&gt;, but with an &lt;c7&gt;id&lt;/c7&gt; of &lt;c8&gt;"2"&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120525Z" creationid="shibukawa.yoshiki" creationdate="20170221T120525Z">
        <seg>&lt;c5&gt;/edit/2&lt;/c5&gt;も&lt;c6&gt;UserForm&lt;/c6&gt;を解決しますが、&lt;c7&gt;id&lt;/c7&gt;は&lt;c8&gt;"2"&lt;/c8&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;h1 class="title"&gt;My first app&lt;/h1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030505Z" creationid="shibukawa.yoshiki" creationdate="20170131T030505Z">
        <seg>&lt;h1 class="title"&gt;最初のMithrilアプリケーション&lt;/h1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;h1&gt;Error: invalid user&lt;/h1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015426Z" creationid="shibukawa.yoshiki" creationdate="20150416T015426Z">
        <seg>&lt;h1&gt;エラー: ユーザ名が違います&lt;/h1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;item 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121631Z" creationid="shibukawa.yoshiki" creationdate="20150502T121631Z">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;item 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121634Z" creationid="shibukawa.yoshiki" creationdate="20150502T121634Z">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;アイテム 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;item 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121637Z" creationid="shibukawa.yoshiki" creationdate="20150502T121637Z">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;アイテム 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;item 1&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000617Z" creationid="shibukawa.yoshiki" creationdate="20150413T000617Z">
        <seg>&lt;li&gt;アイテム 1&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;item 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000620Z" creationid="shibukawa.yoshiki" creationdate="20150413T000620Z">
        <seg>&lt;li&gt;アイテム 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;n0&gt; &lt;a1&gt;Guide&lt;/a1&gt; &lt;a2&gt;API&lt;/a2&gt; &lt;a3&gt;Chat&lt;/a3&gt; &lt;a4&gt;Github&lt;/a4&gt; &lt;/n0&gt; &lt;/s5&gt; &lt;/h6&gt; &lt;m7&gt; &lt;s8&gt; [body]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T053900Z" creationid="shibukawa.yoshiki" creationdate="20170220T053843Z">
        <seg>&lt;n0&gt; &lt;a1&gt;ガイド&lt;/a1&gt; &lt;a2&gt;API&lt;/a2&gt; &lt;a3&gt;チャット&lt;/a3&gt; &lt;a4&gt;Github&lt;/a4&gt; &lt;/n0&gt; &lt;/s5&gt; &lt;/h6&gt; &lt;m7&gt; &lt;s8&gt; [body]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;script&gt;
//this application only has one component: todo
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040351Z" creationid="shibukawa.yoshiki" creationdate="20150502T040351Z">
        <seg>&lt;script&gt;
//このアプリケーションはtodoコンポーネントのみを含む
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;td&gt;task description&lt;/td&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013941Z" creationid="shibukawa.yoshiki" creationdate="20150408T013941Z">
        <seg>&lt;td&gt;タスクの説明&lt;/td&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;title&gt;My Application&lt;/title&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000304Z" creationid="shibukawa.yoshiki" creationdate="20170205T000304Z">
        <seg>&lt;title&gt;Mithrilのアプリケーション&lt;/title&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@param {Object} data - the data with which to populate the &lt;option&gt; list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132418Z" creationid="shibukawa.yoshiki" creationdate="20160101T132418Z">
        <seg>@param {Object} data - &lt;option&gt;リストに追加されるデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@param {function(Object id)} onchange - the event handler to call when the selection changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132807Z" creationid="shibukawa.yoshiki" creationdate="20160101T132807Z">
        <seg>@param {function(Object id)} onchange - 選択が変更された時に呼び出されるイベントハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@param {prop} value - the prop of the item in `data` that we want to select</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132749Z" creationid="shibukawa.yoshiki" creationdate="20160101T132749Z">
        <seg>@param {prop} value - `data`内の選択したいアイテムのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;a0&gt;vnode&lt;/a0&gt; whose attributes object contains routing parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090947Z" creationid="shibukawa.yoshiki" creationdate="20170207T090947Z">
        <seg>&lt;a0&gt;vnode&lt;/a0&gt;ですが、このオブジェクトの属性は、ラウトパラメータを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Todo&lt;/c0&gt; can be instantiated, and have its properties changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151837Z" creationid="shibukawa.yoshiki" creationdate="20150407T151837Z">
        <seg>&lt;c0&gt;Todo&lt;/c0&gt;は初期化をして、プロパティの変更を行うことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DOM element that will be the parent node to the subtree</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080205Z" creationid="shibukawa.yoshiki" creationdate="20170207T080205Z">
        <seg>サブツリーの親ノードとなるDOM要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DOM element which will contain the template represented by &lt;c0&gt;children&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124732Z" creationid="shibukawa.yoshiki" creationdate="20150416T124732Z">
        <seg>&lt;c0&gt;children&lt;/c0&gt;で表現されるテンプレートの結果が入るDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DOM element which will contain the view's template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020744Z" creationid="shibukawa.yoshiki" creationdate="20150414T020744Z">
        <seg>ビューのテンプレートの結果が作成されるDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Javascript Framework for Building Brilliant Applications</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132054Z" creationid="shibukawa.yoshiki" creationdate="20150407T132054Z">
        <seg>輝かしいアプリケーションを構築するためのJavaScriptフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Knockout view model is an amalgamation of model and controller layers in a single class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105558Z" creationid="shibukawa.yoshiki" creationdate="20150420T105558Z">
        <seg>Knockoutのビュー・モデルはモデルとコントローラレイヤーを1つに融合させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Mithril component is just an object with a &lt;c0&gt;view&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030537Z" creationid="shibukawa.yoshiki" creationdate="20170131T030537Z">
        <seg>Mithrilのコンポーネントは&lt;c0&gt;view&lt;/c0&gt;関数を持つ単なるオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Promise aggregator</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153843Z" creationid="shibukawa.yoshiki" creationdate="20150412T153843Z">
        <seg>Promiseを集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Promise factory</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153806Z" creationid="shibukawa.yoshiki" creationdate="20150412T153800Z">
        <seg>Promiseのファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RouteResolver is not a component, and therefore it does NOT have lifecycle methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084556Z" creationid="shibukawa.yoshiki" creationdate="20170207T084556Z">
        <seg>ラウとリゾルバはコンポーネントではありません。そのため、ライフサイクルメソッドも持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RouteResolver object contains a &lt;c0&gt;onmatch()&lt;/c0&gt; and/or a &lt;c1&gt;render()&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064803Z" creationid="shibukawa.yoshiki" creationdate="20170208T064803Z">
        <seg>ラウトリゾルバーオブジェクトにはは&lt;c0&gt;onmatch&lt;/c0&gt;メソッドと&lt;c1&gt;render&lt;/c1&gt;メソッドの両方、あるいはどちらかが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RouterResolver is an object that contains an &lt;c0&gt;onmatch&lt;/c0&gt; method and/or a &lt;c1&gt;render&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084511Z" creationid="shibukawa.yoshiki" creationdate="20170207T084511Z">
        <seg>ラウとリゾルバは&lt;c0&gt;onmatch&lt;/c0&gt;メソッドと&lt;c1&gt;render&lt;/c1&gt;メソッドの両方、あるいはどちらかを持つオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Simple Application</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142412Z" creationid="shibukawa.yoshiki" creationdate="20150407T142412Z">
        <seg>シンプルなアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URL using this strategy typically looks like &lt;c0&gt;http://localhost/?/page1&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T093758Z" creationid="shibukawa.yoshiki" creationdate="20170207T093758Z">
        <seg>この戦略を使ったURLは&lt;c0&gt;http://localhost/?/page1&lt;/c0&gt;のような形式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URL using this strategy typically looks like &lt;c0&gt;http://localhost/page1&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T093819Z" creationid="shibukawa.yoshiki" creationdate="20170207T093819Z">
        <seg>この戦略を使ったURLは&lt;c0&gt;http://localhost/page1&lt;/c0&gt;のような形式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A URL using this strategy typically looks like &lt;c1&gt;http://localhost/#!/page1&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092640Z" creationid="shibukawa.yoshiki" creationdate="20170207T092640Z">
        <seg>この戦略を使った時のURLは一般的には&lt;c1&gt;http://localhost/#!/page1&lt;/c1&gt;のような形式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call to &lt;c0&gt;m.request&lt;/c0&gt; return a &lt;a1&gt;promise&lt;/a1&gt; and trigger a redraw upon completion of its promise chain.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T141014Z" creationid="shibukawa.yoshiki" creationdate="20170219T141007Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;を呼ぶと&lt;a1&gt;Promise&lt;/a1&gt;が返ってきます。また、そのPromiseのチェーンが完了すると再描画が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component can be re-initialized from scratch by changing the &lt;c0&gt;key&lt;/c0&gt; associated with it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085454Z" creationid="shibukawa.yoshiki" creationdate="20150502T085454Z">
        <seg>コンポーネントを再初期化したい場合は、&lt;c0&gt;key&lt;/c0&gt;属性を書き換えると行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component is said to be stateless when it does not store data internally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080503Z" creationid="shibukawa.yoshiki" creationdate="20150502T080503Z">
        <seg>コンポーネントは、内部にデータを保持しなければステートレスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component is simply an object that has a &lt;c0&gt;view&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121613Z" creationid="shibukawa.yoshiki" creationdate="20170220T121613Z">
        <seg>今回作成するコンポーネントは&lt;c0&gt;view&lt;/c0&gt;関数を持つシンプルなオブジェクトです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component is supposed to be an Object with two keys: &lt;c0&gt;controller&lt;/c0&gt; and &lt;c1&gt;view&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100430Z" creationid="shibukawa.yoshiki" creationdate="20150502T100430Z">
        <seg>コンポーネントは、&lt;c0&gt;controller&lt;/c0&gt;と&lt;c1&gt;view&lt;/c1&gt;のキーを持つオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component with arguments bound</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100704Z" creationid="shibukawa.yoshiki" creationdate="20150502T100704Z">
        <seg>引数が束縛されたコンポーネント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constructor to be applied to each object in the response.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070521Z" creationid="shibukawa.yoshiki" creationdate="20170219T070521Z">
        <seg>レスポンスの中でオブジェクトごとに適用されるコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A contact has an id, a name and an email.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224101Z" creationid="shibukawa.yoshiki" creationdate="20150501T224101Z">
        <seg>この連絡先には、id、名前、eメールが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A contrived example of bi-directional data binding</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140721Z" creationid="shibukawa.yoshiki" creationdate="20150414T140721Z">
        <seg>双方向データバインディングのサンプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A controller can also be used as a class constructor (i.e. it's possible to attach properties to the &lt;c0&gt;this&lt;/c0&gt; object within the constructor, instead of returning a value).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072300Z" creationid="shibukawa.yoshiki" creationdate="20150502T072300Z">
        <seg>controllerはクラスコンストラクタとしても使用できます。その時は値を返すのではなく、コンストラクタ内で&lt;c0&gt;this&lt;/c0&gt;オブジェクトに値を追加していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deferred is an asynchrony monad.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015925Z" creationid="shibukawa.yoshiki" creationdate="20150415T015925Z">
        <seg>deferredは非同時性モナドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deserialization method to be applied to the response.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074405Z" creationid="shibukawa.yoshiki" creationdate="20170219T074405Z">
        <seg>レスポンスをデシリアライズするときに適用されるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A event handler factory utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153211Z" creationid="shibukawa.yoshiki" creationdate="20150412T153211Z">
        <seg>イベントハンドラを生成するユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A flag that drives the rendering strategy for the next redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154128Z" creationid="shibukawa.yoshiki" creationdate="20150412T154128Z">
        <seg>次の再描画をどのような戦略で行うかを決定するフラグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A getter-setter method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135818Z" creationid="shibukawa.yoshiki" creationdate="20150414T135818Z">
        <seg>getter-setterメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A getter-setter utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153150Z" creationid="shibukawa.yoshiki" creationdate="20150412T153150Z">
        <seg>getter-setterユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A high-level AJAX utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153752Z" creationid="shibukawa.yoshiki" creationdate="20150412T153752Z">
        <seg>高レベルなAJAXユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A high-level explicit rendering method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153952Z" creationid="shibukawa.yoshiki" creationdate="20150412T153952Z">
        <seg>高レベルな明示的なレンダリングメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hook to specify how the XMLHttpRequest response should be read.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074515Z" creationid="shibukawa.yoshiki" creationdate="20170219T074515Z">
        <seg>XMLHttpRequestのレスポンスをどのように読み込むかを指定するフック関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-value map of possible routes and their respective components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135659Z" creationid="shibukawa.yoshiki" creationdate="20150502T135659Z">
        <seg>利用可能なラウトと、そのラウトに対応するコンポーネントの対応が格納されたキー・バリュー・マップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-value map to be converted into a string</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133200Z" creationid="shibukawa.yoshiki" creationdate="20170206T133200Z">
        <seg>文字列に変換するキー・バリューのマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key/value map of attributes that gets bound as an argument to both the &lt;c0&gt;controller&lt;/c0&gt; and &lt;c1&gt;view&lt;/c1&gt; functions of the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100617Z" creationid="shibukawa.yoshiki" creationdate="20150502T100617Z">
        <seg>コンポーネントの&lt;c0&gt;controller&lt;/c0&gt;と&lt;c1&gt;view&lt;/c1&gt;の両方の関数に束縛される属性のキー/バリューマップです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of promises to synchronize</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180752Z" creationid="shibukawa.yoshiki" creationdate="20150415T180718Z">
        <seg>同期を取りたいpromiseの配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map of URL parameter values</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T091653Z" creationid="shibukawa.yoshiki" creationdate="20170207T091653Z">
        <seg>URLパラメータ値のマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map of options for JSONP requests</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014502Z" creationid="shibukawa.yoshiki" creationdate="20150415T014502Z">
        <seg>JSONPリクエストのためのオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map of options for the XMLHttpRequest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002049Z" creationid="shibukawa.yoshiki" creationdate="20150415T002036Z">
        <seg>XMLHttpRequestに渡すオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A method to unescape HTML</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153905Z" creationid="shibukawa.yoshiki" creationdate="20150412T153905Z">
        <seg>エスケープしないHTMLのためのメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more intellectually interesting aspect of the framework is that event handling is encouraged to be done via functional composition (i.e. by using tools like &lt;a0&gt;&lt;c1&gt;m.withAttr&lt;/c1&gt;&lt;/a0&gt;, &lt;a2&gt;&lt;c3&gt;m.prop&lt;/c3&gt;&lt;/a2&gt; and the native &lt;c4&gt;.bind()&lt;/c4&gt; method for partial application).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T022010Z" creationid="shibukawa.yoshiki" creationdate="20150409T015513Z">
        <seg>Mithril実装の中で、これよりも知的で面白い点としては、&lt;a0&gt;&lt;c1&gt;m.withAttr&lt;/c1&gt;&lt;/a0&gt;、&lt;a2&gt;&lt;c3&gt;m.prop&lt;/c3&gt;&lt;/a2&gt;や、ネイティブの&lt;c4&gt;.bind()&lt;/c4&gt;メソッドを使って部分適用させていくことで、イベントハンドリングが関数合成の文脈で行うことができる点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A noteworthy difference between Angular and Mithril is in framework complexity: Angular implements several subsystems that would seem more logical in programming language implementations (e.g. a parser, a dynamic scoping mechanism, decorators, etc).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095100Z" creationid="shibukawa.yoshiki" creationdate="20150420T095100Z">
        <seg>AngularとMithrilの大きな違いといえば、フレームワークの複雑さです。Angularは数々のサブシステムを持ち、パーサ、動的スコープシステム、デコレータなどより多くのプログラミング言語によるロジックを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A particularly nasty instance of this problem that sometimes occurs in "real-time" applications is when event triggering chains become circular due to a conditional statement bug, causing infinite loops and browser crashes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021258Z" creationid="shibukawa.yoshiki" creationdate="20150420T021047Z">
        <seg>「リアルタイム」を標榜するアプリケーションでこの問題をこじらせると、条件判断を間違えてイベントのトリガーが循環し、無限ループができてしまってブラウザが応答しなくなることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A password for HTTP authentication.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002357Z" creationid="shibukawa.yoshiki" creationdate="20150415T002357Z">
        <seg>HTTP認証のパスワード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A password for HTTP authorization.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T065853Z" creationid="shibukawa.yoshiki" creationdate="20170219T065853Z">
        <seg>HTTP認証のパスワード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A preprocessor function to unwrap the data from a success response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012651Z" creationid="shibukawa.yoshiki" creationdate="20150415T012651Z">
        <seg>レスポンス成功時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A preprocessor function to unwrap the data from an error response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013033Z" creationid="shibukawa.yoshiki" creationdate="20150415T013033Z">
        <seg>レスポンス失敗時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A promise has a method called &lt;c0&gt;then&lt;/c0&gt; which takes two computation callbacks as parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174919Z" creationid="shibukawa.yoshiki" creationdate="20150415T174919Z">
        <seg>promiseは、2つの計算のコールバックを持つ&lt;c0&gt;then&lt;/c0&gt;メソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A promise is also a getter-setter (see &lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175059Z" creationid="shibukawa.yoshiki" creationdate="20150415T175059Z">
        <seg>promiseはgetter-setter (&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt;参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A promise that resolves to the response data, after it has been piped through the &lt;c0&gt;extract&lt;/c0&gt;, &lt;c1&gt;deserialize&lt;/c1&gt; and &lt;c2&gt;type&lt;/c2&gt; methods</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T080045Z" creationid="shibukawa.yoshiki" creationdate="20170219T080045Z">
        <seg>このPromiseが解決されると&lt;c0&gt;extract&lt;/c0&gt;, &lt;c1&gt;deserialize&lt;/c1&gt;, &lt;c2&gt;type&lt;/c2&gt;メソッドで処理されたレスポンスデータが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A route with parameters might look like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170600Z" creationid="shibukawa.yoshiki" creationdate="20150414T170600Z">
        <seg>パラメータ付きのラウトは次のような文字列です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A route without parameters looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170538Z" creationid="shibukawa.yoshiki" creationdate="20150414T170538Z">
        <seg>パラメータのないラウトは次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A routing utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153221Z" creationid="shibukawa.yoshiki" creationdate="20150412T153221Z">
        <seg>ラウティングユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A serialization method to be applied to &lt;c0&gt;data&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070555Z" creationid="shibukawa.yoshiki" creationdate="20170219T070555Z">
        <seg>&lt;c0&gt;data&lt;/c0&gt;に適用されるシリアライズメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string containing HTML markup</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015438Z" creationid="shibukawa.yoshiki" creationdate="20150416T015438Z">
        <seg>HTMLマークアップを含む文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string representing the input object</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133222Z" creationid="shibukawa.yoshiki" creationdate="20170206T133222Z">
        <seg>入力されたオブジェクトの文字列表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user for HTTP authentication.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002342Z" creationid="shibukawa.yoshiki" creationdate="20150415T002331Z">
        <seg>HTTP認証のユーザ名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A username for HTTP authorization.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T065820Z" creationid="shibukawa.yoshiki" creationdate="20170219T065820Z">
        <seg>HTTP認証のユーザー名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A utility to create virtual elements</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153122Z" creationid="shibukawa.yoshiki" creationdate="20150412T153122Z">
        <seg>仮想エレメントを作るためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A view-model is a model level entity that stores UI state.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152444Z" creationid="shibukawa.yoshiki" creationdate="20150407T152444Z">
        <seg>ビュー・モデルはモデルレベルのエンティティで、UIの状態を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aborting a request</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174655Z" creationid="shibukawa.yoshiki" creationdate="20150414T174655Z">
        <seg>リクエストの中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aborting requests</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152515Z" creationid="shibukawa.yoshiki" creationdate="20170219T152515Z">
        <seg>リクエストの中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Above, &lt;c0&gt;dashboard&lt;/c0&gt; is a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135159Z" creationid="shibukawa.yoshiki" creationdate="20150502T135159Z">
        <seg>上記のサンプルの&lt;c0&gt;dashboard&lt;/c0&gt;はコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Above, &lt;c0&gt;dashboard&lt;/c0&gt; is a module.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003508Z" creationid="shibukawa.yoshiki" creationdate="20150410T003508Z">
        <seg>上記のサンプルの&lt;c0&gt;dashboard&lt;/c0&gt;はモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Above, &lt;c0&gt;render&lt;/c0&gt; only runs after the request completes, making the ternary operator redundant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T082011Z" creationid="shibukawa.yoshiki" creationdate="20170208T082011Z">
        <seg>上記の&lt;c0&gt;render&lt;/c0&gt;はリクエストが完了したときにのみ実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Absolute (e.g. Jan 1, 1970 12:00 AM)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143449Z" creationid="shibukawa.yoshiki" creationdate="20160412T143449Z">
        <seg>絶対 (例 Jan 1, 1970 12:00 AM)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing route params</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034306Z" creationid="shibukawa.yoshiki" creationdate="20170131T034306Z">
        <seg>ラウトパラメータへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing the real DOM element</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234151Z" creationid="shibukawa.yoshiki" creationdate="20150412T234151Z">
        <seg>本物のDOM要素へアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the classic definition of the MVC pattern, the model layer is responsible for data storage, state management and business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151156Z" creationid="shibukawa.yoshiki" creationdate="20150407T151156Z">
        <seg>昔ながらのMVCパターンの定義によると、モデルレイヤはデータの保持、状態の管理、ビジネスロジックについての責務を負っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add this line of code under the previous one:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025814Z" creationid="shibukawa.yoshiki" creationdate="20170131T025814Z">
        <seg>次の行を前のサンプルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, calling &lt;c0&gt;m.redraw&lt;/c0&gt; synchronously after calling &lt;c1&gt;m.redraw.strategy("none")&lt;/c1&gt; resets the strategy to &lt;c2&gt;"diff"&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150834Z" creationid="shibukawa.yoshiki" creationdate="20150416T150834Z">
        <seg>また、&lt;c1&gt;m.redraw.strategy("none")&lt;/c1&gt;を呼んだ後に&lt;c0&gt;m.redraw&lt;/c0&gt;を同期的に呼んだ場合には、戦略は&lt;c2&gt;"diff"&lt;/c2&gt;にリセットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, if the &lt;c0&gt;extract&lt;/c0&gt; option is passed to &lt;c1&gt;m.request&lt;/c1&gt; the return value of the provided function will be used directly to resolve the request promise, and the &lt;c2&gt;deserialize&lt;/c2&gt; callback is ignored.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045831Z" creationid="shibukawa.yoshiki" creationdate="20170201T045831Z">
        <seg>これに加えて、&lt;c0&gt;extract&lt;/c0&gt;オプションが&lt;c1&gt;m.request&lt;/c1&gt;に渡されると、指定された関数の返り値がPromiseの解決にそのまま使われ、&lt;c2&gt;deserialize&lt;/c2&gt;コールバックは無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced Topics</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140749Z" creationid="shibukawa.yoshiki" creationdate="20150407T140749Z">
        <seg>上級トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced component resolution</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064634Z" creationid="shibukawa.yoshiki" creationdate="20170208T064634Z">
        <seg>高度なコンポーネントの解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a call to either &lt;c2&gt;resolve&lt;/c2&gt; or &lt;c3&gt;reject&lt;/c3&gt;, it holds the result of the parent's computation (or the &lt;c4&gt;resolve&lt;/c4&gt;/&lt;c5&gt;reject&lt;/c5&gt; value, if the promise has no parent promises)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175418Z" creationid="shibukawa.yoshiki" creationdate="20150415T175418Z">
        <seg>&lt;c2&gt;resolve&lt;/c2&gt;と&lt;c3&gt;reject&lt;/c3&gt;のどちらを呼んでも、promiseは親の計算結果の値 (もしくはpromiseが親を持っていなければ&lt;c4&gt;resolve&lt;/c4&gt;/&lt;c5&gt;reject&lt;/c5&gt;)を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After event handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120721Z" creationid="shibukawa.yoshiki" creationdate="20170206T120721Z">
        <seg>イベントハンドラ後</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After m.request</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121002Z" creationid="shibukawa.yoshiki" creationdate="20170206T121002Z">
        <seg>m.request後</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121133Z" creationid="shibukawa.yoshiki" creationdate="20170206T121133Z">
        <seg>ラウトの変更後</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After that, Mithril resets the &lt;c2&gt;m.redraw.strategy&lt;/c2&gt; flag to either "all" or "diff" depending on whether the redraw was due to a route change or whether it was triggered by some other action.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155843Z" creationid="shibukawa.yoshiki" creationdate="20150416T155843Z">
        <seg>再描画が完了すると、Mithrilは再描画がの原因が他のアクションにあるかどうかをを元にして、&lt;c2&gt;m.redraw.strategy&lt;/c2&gt;の設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the redraw, Mithril resets the value of the flag to either "all" or "diff", depending on whether the redraw was due to a route change or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140302Z" creationid="shibukawa.yoshiki" creationdate="20150416T140302Z">
        <seg>再描画が完了すると、Mithrilは再描画がラウトの変更に起因するものかどうかによって、この設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating requests in a top-level component makes it easier to replay the request chain (i.e. fetching an updated list of items after you've saved something that changes that list), and it ensures the entire data set is loaded in memory before drilling down into nested components, avoiding redundant AJAX calls for sibling components that need the same data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084936Z" creationid="shibukawa.yoshiki" creationdate="20150502T084822Z">
        <seg>リクエストをトップレベルのコンポーネントに集約することは、リスト内のデータを変更した後などに再度リクエストを行うのが簡単になります。ネストされたコンポーネントをたどっていく前に必要なデータセットが確実に存在することを保証できますし、兄弟コンポーネントで同じデータを何度もリクエストするのを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating responsibility in a top-level component allows the developer to manage multiple model entities easily: any given AJAX request only needs to be performed once regardless of how many components need its data, and refreshing the data set is simple.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005427Z" creationid="shibukawa.yoshiki" creationdate="20150502T005427Z">
        <seg>責務とトップレベルのコンポーネントで統合するという方法は、複数のモデルエンティティを持つ場合の管理を楽にします。多くのコンポーネントがサーバ側のデータを必要としても、AJAXアクセスをまとめて通信をシンプルにしたり、データのリフレッシュが行い易くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation of responsibility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180047Z" creationid="shibukawa.yoshiki" creationdate="20150501T180047Z">
        <seg>責務の集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All API points are explained in prose, and have code examples.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114416Z" creationid="shibukawa.yoshiki" creationdate="20150417T114416Z">
        <seg>すべてのAPIは人間に読みやすいように書かれており、サンプルコードもたくさん書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All further steps are automated and run as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054155Z" creationid="shibukawa.yoshiki" creationdate="20170220T054155Z">
        <seg>それ以降の手順はすべて自動化されています。次の手順で実行されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that concatenating or splitting a trusted string removes the trust flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015655Z" creationid="shibukawa.yoshiki" creationdate="20150416T015655Z">
        <seg>また、文字列を結合したり、分割すると、信頼フラグは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the &lt;c0&gt;config&lt;/c0&gt; callback only runs after a rendering lifecycle is done.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124801Z" creationid="shibukawa.yoshiki" creationdate="20150413T124801Z">
        <seg>また、&lt;c0&gt;config&lt;/c0&gt;コールバックはレンダリングのライフサイクルが終わった時にしか呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that, unlike observable-based frameworks like Knockout.js, setting a value in a &lt;c4&gt;m.prop&lt;/c4&gt; getter-setter does NOT trigger redrawing side-effects in Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014658Z" creationid="shibukawa.yoshiki" creationdate="20150408T014658Z">
        <seg>MithrilはKnockout.jsのようなObservableベースのフレームワークとは異なり、&lt;c4&gt;m.prop&lt;/c4&gt;のgetter-setterに値を設定しても、再描画が起動されるような副作用は発生しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also notice we &lt;s0&gt;didn't&lt;/s0&gt; do &lt;c1&gt;oninit: User.loadList()&lt;/c1&gt; (with parentheses at the end).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T150036Z" creationid="shibukawa.yoshiki" creationdate="20170220T150036Z">
        <seg>このコードでは&lt;c1&gt;oninit: User.loadList()&lt;/c1&gt; (末尾にかっこ) とは&lt;s0&gt;しませんでした&lt;/s0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, as you would expect, clicking on the link on the splash page takes you to the click counter screen we created earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170203T091446Z" creationid="shibukawa.yoshiki" creationdate="20170203T091446Z">
        <seg>スプラッシュページのなかのリンクをクリックすると、以前作ったクリックカウンターに移動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, if the component is ever recreated (through navigating back and forth through the application), the function won't be called again as expected.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T151041Z" creationid="shibukawa.yoshiki" creationdate="20170220T151034Z">
        <seg>この場合、アプリケーション上で前後に移動した場合などにコンポーネントが再作成されたときには、期待に反して呼び出しが行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, keys must be either strings or numbers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142219Z" creationid="shibukawa.yoshiki" creationdate="20150413T142219Z">
        <seg>キーは文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, notice that since these components are designed to encapsulate their behavior, they cannot easily affect other components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015346Z" creationid="shibukawa.yoshiki" creationdate="20150502T015346Z">
        <seg>また、それぞれのコンポーネントの動作はカプセル化されているため、他のモジュールを外部から操作することは簡単にはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the memory gains from repeatedly reusing small buffers may be offset or nullified if they result in excessive browser repaints.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034318Z" creationid="shibukawa.yoshiki" creationdate="20170220T034233Z">
        <seg>また小さいバッファを繰り返し利用することによるメモリの効率的な利用に関しても、再描画が頻繁になると打ち消されてしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, there's an extra field &lt;c2&gt;error&lt;/c2&gt; for holding an error message, and the view of the &lt;c3&gt;Todos&lt;/c3&gt; component was modified to displays an error message if one exists, or display a loading icon if &lt;c4&gt;Data.todos.list&lt;/c4&gt; is not an array.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T145113Z" creationid="shibukawa.yoshiki" creationdate="20170219T145113Z">
        <seg>また、エラーメッセージを保持する追加フィールドの&lt;c2&gt;error&lt;/c2&gt;が追加されており、エラーがあったらエラーメッセージを、&lt;c4&gt;Data.todos.list&lt;/c4&gt;が配列でなかったらローディングアイコンを表示するように&lt;c3&gt;Todos&lt;/c3&gt; コンポーネントが書き換えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can also explore other techniques in order to achieve better &lt;a0&gt;performance&lt;/a0&gt; and &lt;a1&gt;expressiveness&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015842Z" creationid="shibukawa.yoshiki" creationdate="20150413T015842Z">
        <seg>バインディングに関して&lt;a0&gt;パフォーマンス&lt;/a0&gt;と&lt;a1&gt;表現&lt;/a1&gt;を改善する他の方法についてはブログの記事で学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An URI encoded querystring to be deserialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135935Z" creationid="shibukawa.yoshiki" creationdate="20150502T135935Z">
        <seg>デシリアライズするURIエンコーディングされたクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alert box will appear when the upload finishes"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034917Z" creationid="shibukawa.yoshiki" creationdate="20150502T034917Z">
        <seg>アップロードが完了するとアラートボックスが表示されます。"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element is considered "different enough" if:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135347Z" creationid="shibukawa.yoshiki" creationdate="20150413T135347Z">
        <seg>「大きく異る」の判定基準は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An execution thread is basically any amount of code that runs before other asynchronous threads start to run.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155935Z" creationid="shibukawa.yoshiki" creationdate="20150412T004720Z">
        <seg>実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initialization function that runs after &lt;c0&gt;open&lt;/c0&gt; and before &lt;c1&gt;send&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013955Z" creationid="shibukawa.yoshiki" creationdate="20150415T013943Z">
        <seg>&lt;c0&gt;open&lt;/c0&gt;と&lt;c1&gt;send&lt;/c1&gt;の間に呼ばれる初期化関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initialization value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135822Z" creationid="shibukawa.yoshiki" creationdate="20150414T135712Z">
        <seg>初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of the controller constructor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T024717Z" creationid="shibukawa.yoshiki" creationdate="20150414T024717Z">
        <seg>コントローラコンストラクタのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object containing all the route parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T135456Z" creationid="shibukawa.yoshiki" creationdate="20160101T135456Z">
        <seg>ラウトのパラメータをすべて含むオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that retains its state across redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155255Z" creationid="shibukawa.yoshiki" creationdate="20150413T155255Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object to be serialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170954Z" creationid="shibukawa.yoshiki" creationdate="20150414T170954Z">
        <seg>シリアライズしたいオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object whose keys are route strings and values are either components or a &lt;a0&gt;RouteResolver&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080401Z" creationid="shibukawa.yoshiki" creationdate="20170207T080401Z">
        <seg>キーがラウトのURL、値がコンポーネントか&lt;a0&gt;ラウトリゾルバー&lt;/a0&gt;が格納されているオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And because Mithril views are Javascript, the developer has full freedom to abstract common patterns - from bidirectional binding helpers to full blown components - using standard Javascript refactoring techniques.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021942Z" creationid="shibukawa.yoshiki" creationdate="20150409T015129Z">
        <seg>MithrilのビューがJavaScriptであることから、破壊的なコンポーネントに対する双方向バインディングヘルパーといった、抽象的な一般化のパターンから開発者が開放されます。一般的なJavaScriptのリファクタリングテクニックが利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And finally, we can create a route that references it:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120244Z" creationid="shibukawa.yoshiki" creationdate="20170221T120244Z">
        <seg>次に、このモジュールを参照するラウトを追加しましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if you really do want to use HTML syntax after all, &lt;a0&gt;you can use a package called MSX&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014543Z" creationid="shibukawa.yoshiki" creationdate="20150409T014543Z">
        <seg>それでもHTMLの文法を使いたいということであれば、&lt;a0&gt;MSXと呼ばれるパッケージが使えます&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And let's add some styles to &lt;c0&gt;styles.css&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120746Z" creationid="shibukawa.yoshiki" creationdate="20170221T120746Z">
        <seg>新しいコンポーネントで使うスタイルも&lt;c0&gt;styles.css&lt;/c0&gt;に追加しましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And moving the responsibility of saving to the &lt;c0&gt;ContactForm&lt;/c0&gt; component alleviates the need to send data back up the component tree, making the handling of non-idempotent operations less prone to pass-through argument noise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031049Z" creationid="shibukawa.yoshiki" creationdate="20150502T031049Z">
        <seg>また、保存の責務を&lt;c0&gt;ContactForm&lt;/c0&gt;コンポーネントに移動したことで、コンポーネントツリーをさかのぼってデータを渡す必要は軽減されています。 引数を使ってパススルーするノイズも減らしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152205Z" creationid="shibukawa.yoshiki" creationdate="20150407T152205Z">
        <seg>他にもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030330Z" creationid="shibukawa.yoshiki" creationdate="20170131T030330Z">
        <seg>さらにタグで囲って階層化してみます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the data is &lt;c0&gt;[{name: "John"}, {name: "Mary"}]&lt;/c0&gt;, then the response will contain an array of two User instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013928Z" creationid="shibukawa.yoshiki" creationdate="20150415T013928Z">
        <seg>そして、サーバから&lt;c0&gt;[{name: "John"}, {name: "Mary"}]&lt;/c0&gt;というデータが帰ってくると、レスポンスはUserクラスのインスタンスを2つ含む配列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And this is for every list that needs to be displayed in some way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014441Z" creationid="shibukawa.yoshiki" creationdate="20150420T014441Z">
        <seg>リストを表示するコードを実装するときは、毎回この作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And you can download Mithril by typing this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235523Z" creationid="shibukawa.yoshiki" creationdate="20150407T235523Z">
        <seg>このあと、次のようにタイプするとMithrilをダウンロードすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Angular is an MVC framework maintained by Google, and it provides a declarative view layer and an emphasis on testability.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025013Z" creationid="shibukawa.yoshiki" creationdate="20150420T025013Z">
        <seg>AngularはGoogleにより開発が行われているMVCフレームワークで、宣言的なビューとテストしやすさに重点が置かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animating an element via CSS when the element created couldn't be simpler.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105449Z" creationid="shibukawa.yoshiki" creationdate="20170206T105449Z">
        <seg>要素作成時にCSSを使って要素をアニメーションさせるのは、これ以上簡単にはできないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143306Z" creationid="shibukawa.yoshiki" creationdate="20160412T143306Z">
        <seg>アニメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animation on element creation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105352Z" creationid="shibukawa.yoshiki" creationdate="20170206T105352Z">
        <seg>エレメント作成時のアニメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animation on element removal</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105529Z" creationid="shibukawa.yoshiki" creationdate="20170206T105529Z">
        <seg>要素の削除時のアニメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animations - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T104701Z" creationid="shibukawa.yoshiki" creationdate="20170206T104701Z">
        <seg>アニメーション - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Animations are often used to make applications come alive.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T104759Z" creationid="shibukawa.yoshiki" creationdate="20170206T104759Z">
        <seg>アニメーションはアプリケーションのいきいきとさせるためによく利用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another benefit is that Mithril enables a &lt;a0&gt;retained mode&lt;/a0&gt; UI development paradigm, which greatly simplifies development and maintenance of complex user interactions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022641Z" creationid="shibukawa.yoshiki" creationdate="20170220T022641Z">
        <seg>他のメリットとしては、Mithrilを使うと&lt;a0&gt;retained mode&lt;/a0&gt;と呼ばれるUI開発のパラダイムが利用できるようになります。このパラダイムを使うと複雑なユーザーとのインタラクションの開発をシンプルにして、メンテナンス性も向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another difference is that Mithril, being an MVC framework, rather than a templating engine, provides an auto-redrawing system that is aware of network asynchrony and that can render views efficiently without cluttering application code with redraw calls, and without letting the developer unintentionally bleed out of the MVC pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105303Z" creationid="shibukawa.yoshiki" creationdate="20150420T105303Z">
        <seg>他に違う点といえば、Mithrilは単なるテンプレートエンジンではなく、MVCフレームワークとして統一的に動作するように作られているため、アプリケーションコードに再描画命令を挟み込んでMVCフレームワークのパターンを逸脱することなく、非同期通信のネットワークアクセスなどを探知して適切に再描画行う再描画エンジンを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another feature - the optional &lt;c0&gt;m()&lt;/c0&gt; utility - allows writing terse templates in a declarative style using CSS shorthands, similar to popular HTML preprocessors from server-side MVC frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021918Z" creationid="shibukawa.yoshiki" creationdate="20150409T014927Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;ユーティリティが持つ他の機能としては、CSS的な記述方法で完結にテンプレートが記述できます。これは一般的なサーバサイドMVCフレームワークのHTML処理と似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another marking difference is that Backbone is workflow agnostic, providing no idiomatic way to organize applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020252Z" creationid="shibukawa.yoshiki" creationdate="20150420T020252Z">
        <seg>他に異なる点としては、Backboneはワークフローに関しては関与しません。アプリケーションを組み立てていくための手順に関しては特に定めていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another point of comparison is documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113935Z" creationid="shibukawa.yoshiki" creationdate="20150417T113935Z">
        <seg>もう１つの比較ポイントはドキュメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another side-effect is that UI state like input focus is not tracked correctly if the focused element moves around, and likewise, state for 3rd party plugins that are added via &lt;c0&gt;config&lt;/c0&gt; can also end up in the wrong element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141431Z" creationid="shibukawa.yoshiki" creationdate="20150413T141431Z">
        <seg>他の副作用としては、フォーカスを持ったエレメントが移動してしまったり、&lt;c0&gt;config&lt;/c0&gt;を通じて追加されたサードパーティのプラグインが違うエレメントの内側に移動してしまう可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another significant difference between Backbone and Mithril is in their approach to familiarity: Backbone appeals to people familiar w/ jQuery; Mithril is designed to be familiar to people with server-side MVC framework experience.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T024834Z" creationid="shibukawa.yoshiki" creationdate="20150420T024834Z">
        <seg>それ以外の違いとしては、フレームワークがターゲットとしている層です。BackboneはjQueryに慣れている人にアプローチしています。MithrilはサーバサイドMVCフレームワークの経験を持っている人が親しみやすいように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way of organizing code is to distribute concrete responsibilities across multiple modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013600Z" creationid="shibukawa.yoshiki" creationdate="20150502T013600Z">
        <seg>他のコードの構築方法としては、具体的な責務をモジュール間に分配する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any code that is between a &lt;c2&gt;m.startComputation&lt;/c2&gt; and its respective &lt;c3&gt;m.endComputation&lt;/c3&gt; call is said to live in the &lt;e4&gt;context&lt;/e4&gt; of its respective pair of function calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185444Z" creationid="shibukawa.yoshiki" creationdate="20150411T185444Z">
        <seg>&lt;c2&gt;m.startComputation&lt;/c2&gt;呼び出しと、対応する&lt;c3&gt;m.endComputation&lt;/c3&gt;呼び出しにあるコードは、Mithrilの文脈では、「同じペアの関数呼び出しの&lt;e4&gt;コンテキスト&lt;/e4&gt;内に存在する」と表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any time an exception is thrown inside a promise callback, Mithril calls &lt;c0&gt;m.deferred.onerror(e)&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174241Z" creationid="shibukawa.yoshiki" creationdate="20150415T174241Z">
        <seg>promiseコールバックの中で例外が発生すると、Mithrilは&lt;c0&gt;m.deferred.onerror(e)&lt;/c0&gt;を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application architecture with components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180000Z" creationid="shibukawa.yoshiki" creationdate="20150501T180000Z">
        <seg>アプリケーションアーキテクチャとコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114907Z" creationid="shibukawa.yoshiki" creationdate="20150417T114907Z">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133115Z" creationid="shibukawa.yoshiki" creationdate="20170206T133115Z">
        <seg>引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments are accessed within the component by reading them from the &lt;c4&gt;vnode.attrs&lt;/c4&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121930Z" creationid="shibukawa.yoshiki" creationdate="20170131T121930Z">
        <seg>コンポーネント内部では、引数は&lt;c4&gt;vnode.attrs&lt;/c4&gt;オブジェクトとして参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments to a component in &lt;c0&gt;v1.x&lt;/c0&gt; must be an object, simple values like &lt;c1&gt;String&lt;/c1&gt;/&lt;c2&gt;Number&lt;/c2&gt;/&lt;c3&gt;Boolean&lt;/c3&gt; will be treated as text children.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121851Z" creationid="shibukawa.yoshiki" creationdate="20170131T121851Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt;のコンポーネントはオブジェクトでなければなりません。&lt;c1&gt;String&lt;/c1&gt;、&lt;c2&gt;Number&lt;/c2&gt;、&lt;c3&gt;Boolean&lt;/c3&gt;は子供のテキストノードとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays now represent &lt;a0&gt;fragments&lt;/a0&gt;, which are structurally significant in v1.x virtual DOM. Whereas nested arrays in v0.2.x would be flattened into one continuous list of virtual nodes for the purposes of diffing, v1.x preserves the array structure - the children of any given array are not considered siblings of those of adjacent arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050850Z" creationid="shibukawa.yoshiki" creationdate="20170201T050850Z">
        <seg>配列は&lt;a0&gt;フラグメント&lt;/a0&gt;を表現するのに使われるようになりました。これはv1.xの仮想DOMの主要な構造です。v0.2.xではネストされた配列は差分検知のためにフラット化され、1つのリストにされていました。v1.xでは配列構造をそのまま維持します。別の配列の子要素が、京大の要素として扱われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the controller runs again, the DOM is re-generated, and any applicable 3rd party plugins in configs are re-initialized.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090552Z" creationid="shibukawa.yoshiki" creationdate="20150502T090552Z">
        <seg>これにより、コントローラが再実行され、DOMが再生成されます。また、サードパーティのプラグインがconfigで設定されていた場合には、これも最初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a rule of thumb, RouteResolvers should be in the same file as the &lt;c2&gt;m.route&lt;/c2&gt; call, whereas component definitions should be in their own modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084916Z" creationid="shibukawa.yoshiki" creationdate="20170207T084905Z">
        <seg>一般的な使い方は、ラウトリゾルバは&lt;c2&gt;m.route&lt;/c2&gt;呼び出しと同じファイルに入れ、コンポーネントはそれぞれ別のファイルに入れる方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a rule of thumb, controllers should not change model entity properties on an individual basis.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T031859Z" creationid="shibukawa.yoshiki" creationdate="20150421T014126Z">
        <seg>経験則として、コントローラがモデルのプロパティを直接変更すべきではない、というものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a rule of thumb, you should &lt;e0&gt;never&lt;/e0&gt; implement performance optimizations if another solution is available.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142929Z" creationid="shibukawa.yoshiki" creationdate="20150412T142929Z">
        <seg>一般的な方針として、他のソリューションがある場合には、&lt;e0&gt;絶対に&lt;/e0&gt;パフォーマンスの最適化を行わないほうが良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it turns out, this design decision is actually a compromise: it offers the benefit of decreased application code complexity at the cost of some performance loss.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014911Z" creationid="shibukawa.yoshiki" creationdate="20150420T014911Z">
        <seg>通常、このような設計の決定は折衷案になりがちです。アプリケーションコードの複雑さを減らそうとすると、パフォーマンスのコストが必要になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as the event handler returns, the strategy is set back to "diff".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150525Z" creationid="shibukawa.yoshiki" creationdate="20150416T150525Z">
        <seg>イベントハンドラが完了すると、再び"diff"に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As summarized above, Mithril differs from jQuery by allowing DOM-related code to be written largely in a declarative style (thereby decreasing code complexity), in addition to providing an idiomatic way to structure applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015629Z" creationid="shibukawa.yoshiki" creationdate="20150420T015629Z">
        <seg>言い換えると、MithrilとjQueryの書き方は大きく異なっています。Mithrilは宣言的なスタイルでDOM関連のコードを書くことが可能で、コードの複雑さは低減されています。それに加えて、共通のアプリケーションの構造を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Angular, Knockout templates are written in HTML, and therefore have the same pros and cons as Angular templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105833Z" creationid="shibukawa.yoshiki" creationdate="20150420T105833Z">
        <seg>また、Angularと同様にテンプレートがHTMLに書かれるため、Angularのテンプレートと同じ利点・欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with input focus, we can maintain referential integrity between data in a list and the respective DOM representation by using keys.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150247Z" creationid="shibukawa.yoshiki" creationdate="20150413T150247Z">
        <seg>入力のフォーカスと同様に、キーを使うとリスト内のデータとそのDOM表現間の参照の整合性を維持できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with jQuery, Mithril differs from Backbone by enforcing view code to be written in a declarative style.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020128Z" creationid="shibukawa.yoshiki" creationdate="20150420T020128Z">
        <seg>BackboneとjQueryとの組み合わせたスタイルを使う場合、Mithrilではビューコードの記述に宣言的なスタイルが強要されるため、大きくことなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, flow control is done with vanilla Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002654Z" creationid="shibukawa.yoshiki" creationdate="20150413T002559Z">
        <seg>このように、普通のJavaScriptの文法を利用してフロー制御を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, it paints a much less flattering picture for some frameworks than when we look at gzipped size alone.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113909Z" creationid="shibukawa.yoshiki" creationdate="20150417T113909Z">
        <seg>すでにご覧になられたとおり、大げさではなくて、gzipされたサイズ以上のパフォーマンスが出ている事がわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, this component simply renders a link to &lt;c0&gt;#!/hello&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032008Z" creationid="shibukawa.yoshiki" creationdate="20170131T032008Z">
        <seg>このコンポーネントは、&lt;c0&gt;#!/hello&lt;/c0&gt;へのリンクをレンダリングするだけのシンプルなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, we return a partial template with two &lt;c0&gt;&lt;td&gt;&lt;/c0&gt;'s.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153237Z" creationid="shibukawa.yoshiki" creationdate="20150408T153237Z">
        <seg>このメソッドは、ご覧のとおりに、2つの&lt;c0&gt;&lt;td&gt;&lt;/c0&gt;タグを持つ、部分テンプレートを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, you can use CSS selectors to specify attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004324Z" creationid="shibukawa.yoshiki" creationdate="20150408T004324Z">
        <seg>CSSセレクタを使って要素を選択することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, you use the same code to both create and update HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025858Z" creationid="shibukawa.yoshiki" creationdate="20170131T025858Z">
        <seg>このコードを見ればおわかりの通りに、同じコードをつかってHTMLの作成と更新を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you may recall, models are responsible for encapsulating business logic, and view-models encapsulate logic that pertains specifically to UI state, so there's really nothing else for a controller to abstract away, and all it needs to do is expose a slice of the model layer that pertains to the UI that is currently in view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004036Z" creationid="shibukawa.yoshiki" creationdate="20150408T004036Z">
        <seg>ここで今まで出てきたロールを思い出してみてください。モデルはビジネスロジックのカプセル化、ビュー・モデルは特定のUI状態に関するロジックのカプセル化を行います。抽象化された役割の中でコントローラが行うべきものは、モデルの中から、現在の表示されているものを切り出して表示するという役割以外は残っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you saw, you can chain operations that act on the response data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125423Z" creationid="shibukawa.yoshiki" creationdate="20150410T125423Z">
        <seg>これまで見てきたとおり、レスポンスで返されたデータに対して処理のオペレーションをいくつもチェーンさせて追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you would expect, doing so creates this markup:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030705Z" creationid="shibukawa.yoshiki" creationdate="20170131T030705Z">
        <seg>期待されるように、次のマークアップが生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming a document has an empty &lt;c0&gt;&lt;body&gt;&lt;/c0&gt; element, the code below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123317Z" creationid="shibukawa.yoshiki" creationdate="20150416T081357Z">
        <seg>ドキュメントは空の&lt;c0&gt;&lt;body&gt;&lt;/c0&gt;エレメントを持っているとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming the server is configured to accept multipart requests, the file information will be associated with the &lt;c0&gt;myfile&lt;/c0&gt; key.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160141Z" creationid="shibukawa.yoshiki" creationdate="20170219T160141Z">
        <seg>マルチパートフォームが受け取れるサーバーであれば、&lt;c0&gt;myfile&lt;/c0&gt;キーに格納されたファイル情報が取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can download Mithril by typing this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235211Z" creationid="shibukawa.yoshiki" creationdate="20150407T170054Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでMithrilをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Bower by typing this in the command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235149Z" creationid="shibukawa.yoshiki" creationdate="20150407T235149Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでBowerをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Component by typing this in the command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000021Z" creationid="shibukawa.yoshiki" creationdate="20150408T000021Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでComponentをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming your templates have appropriate null checks in place, &lt;c0&gt;m.redraw&lt;/c0&gt; is useful for transient DOM state such as loading indicators and to commit state to the DOM for the purposes of reading back computed values (for example, &lt;c1&gt;offsetWidth&lt;/c1&gt; or &lt;c2&gt;scrollHeight&lt;/c2&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130458Z" creationid="shibukawa.yoshiki" creationdate="20150502T130458Z">
        <seg>テンプレートでは適切にnullチェックが行われていると仮定すると、&lt;c0&gt;m.redraw&lt;/c0&gt;はローディングのインジケータ表示したり、 &lt;c1&gt;offsetWidth&lt;/c1&gt;や&lt;c2&gt;scrollHeight&lt;/c2&gt;の値を元にDOMの状態を変更しにいく時には便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At a glance it may seem like we're doing something very expensive by redrawing, but as it turns out, calling the &lt;c0&gt;todo.view&lt;/c0&gt; method multiple times does not actually re-render the entire template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015426Z" creationid="shibukawa.yoshiki" creationdate="20150408T015426Z">
        <seg>一見すると、このコードは再描画を何度も行っていて、とても実行コストが高そうに見えますが、&lt;c0&gt;todo.view&lt;/c0&gt;メソッドを何度呼び出しても、実際にはテンプレート全体が再描画されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At its most basic form, one could do the following:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T085918Z" creationid="shibukawa.yoshiki" creationdate="20170208T085918Z">
        <seg>もっとも基本的な形式は次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to unwrap its value early will likely result in errors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015311Z" creationid="shibukawa.yoshiki" creationdate="20150410T015311Z">
        <seg>そのため、データを早期にアンラップしようとするとおそらくエラーになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T074841Z" creationid="shibukawa.yoshiki" creationdate="20170208T074841Z">
        <seg>認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autocompleter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143311Z" creationid="shibukawa.yoshiki" creationdate="20160412T143311Z">
        <seg>自動補完</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013614Z" creationid="shibukawa.yoshiki" creationdate="20150417T013614Z">
        <seg>自動HTML→Mithirilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autoredraw system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024752Z" creationid="shibukawa.yoshiki" creationdate="20170131T024752Z">
        <seg>自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid anti-patterns</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T161117Z" creationid="shibukawa.yoshiki" creationdate="20170219T161117Z">
        <seg>アンチパターンを避ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backbone was originally designed as a way to structure jQuery-based applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015758Z" creationid="shibukawa.yoshiki" creationdate="20150420T015758Z">
        <seg>Backboneは当初、jQueryベースのアプリケーションの構造化をする目的で設計されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic usage</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014521Z" creationid="shibukawa.yoshiki" creationdate="20150410T014521Z">
        <seg>基本的な使い方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basically, XHR is just a way to talk to a server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T143505Z" creationid="shibukawa.yoshiki" creationdate="20170204T143505Z">
        <seg>基本的にXHRはサーバーと話をするための方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that by using the native Array class, we're making an implicit statement that we are going to support all of the standard Array methods as part of our API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002837Z" creationid="shibukawa.yoshiki" creationdate="20150409T002837Z">
        <seg>ネイティブのArrayクラスを使ったお陰で、標準のArrayクラスのメソッドを自分自身のAPIとして暗黙的に使えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that even though Mithril has tests running in a continuous integration environment, the bleeding edge version might occasionally break.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000533Z" creationid="shibukawa.yoshiki" creationdate="20150408T000533Z">
        <seg>Mithrilは継続的インテグレーション環境を使ってテストされていますが、最先端のバージョンは頻繁に機能しなくなる可能性がありますので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to read the &lt;a0&gt;Application Architecture section&lt;/a0&gt; to learn more about organizing componentized code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085142Z" creationid="shibukawa.yoshiki" creationdate="20150502T085142Z">
        <seg>コンポーネント化されたコードの構成については、&lt;a0&gt;アプリケーションアーキテクチャのセクション&lt;/a0&gt;をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Mithril encourages all entity logic to be done in the model layer, it's idiomatic to create modules with model-level classes that deal specifically with relationships between entities, when there isn't already a model entity that can logically hold the relational business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033306Z" creationid="shibukawa.yoshiki" creationdate="20150421T033306Z">
        <seg>Mithrilでは、エンティティのロジックはすべてモデルレイヤ内に置かれるのが推奨されます。エンティティ間の関係を取り扱う必要が出てきたら、コントローラのレイヤーにコードを足すのではなく、新たに専門のモデルレベルのクラスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the DOM is by far the largest bottleneck in rendering engines, Mithril's approach of running a diff against a virtual representation of the DOM and only batching changes to the real DOM as needed is surprisingly performant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184338Z" creationid="shibukawa.yoshiki" creationdate="20150411T184338Z">
        <seg>DOMはレンダリングエンジンにとって最大のボトルネックであるため、MithrilのDOMの仮想表現に対して差分をとり、必要に応じてバッチで実際のDOMを変更するアプローチは、驚くべきパフォーマンスを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the XMLHttpRequest's progress event is not directly handled by Mithril's virtual DOM engine, &lt;c2&gt;m.redraw()&lt;/c2&gt; must be called to signal to Mithril that data has changed and a redraw is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T003847Z" creationid="shibukawa.yoshiki" creationdate="20170220T003847Z">
        <seg>XMLHttpRequestのプログレスイベントはMithrilの仮想DOMエンジンでは直接扱う方法は提供していません。そのため、Mithrilにデータが変更されて再描画が必要なことを伝えるには&lt;c2&gt;m.redraw()&lt;/c2&gt;を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the entire documentation is hand-crafted, you get the benefit of actually having explanations for things that documentation-generator tools don't support well (for example, interfaces and callback parameter documentation).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114600Z" creationid="shibukawa.yoshiki" creationdate="20150417T114600Z">
        <seg>すべてのドキュメントが人の手で書かれているため、ドキュメントに知りたい情報がきちんとかかれているというメリットがあります。ドキュメント生成ツールではインタフェースやコールバックのパラメータなどが抜けがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this handler is not created using Mithril's templating engine (i.e. we're not defining an attribute in a virtual element), we must manually integrate it to the auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134225Z" creationid="shibukawa.yoshiki" creationdate="20150412T134225Z">
        <seg>仮想エレメントの中でこの属性を使用しなかった場合など、もしこのハンドラがMithrilのテンプレートで作成されていない場合は、手動で自動再描画システムに統合する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Below are some examples of consuming the &lt;c0&gt;Uploader&lt;/c0&gt; component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034534Z" creationid="shibukawa.yoshiki" creationdate="20150502T034534Z">
        <seg>次のコードは&lt;c0&gt;Uploader&lt;/c0&gt;コンポーネントの使用例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Below is an example where various methods implemented with a third party library can be integrated in layered fashion: any of the methods can be used in isolation or in combination.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005157Z" creationid="shibukawa.yoshiki" creationdate="20150412T005157Z">
        <seg>次のサンプルは、多くのメソッドがサードパーティ製ライブラリを使っているコードを、階層に分けて統合したコードになります。メソッドの中には個別に使われるものもあれば、組み合わせて使われるものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Benchmarks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141004Z" creationid="shibukawa.yoshiki" creationdate="20150407T141004Z">
        <seg>ベンチマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bind redirection code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124256Z" creationid="shibukawa.yoshiki" creationdate="20150410T124256Z">
        <seg>リダイレクトするコードのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding errors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124707Z" creationid="shibukawa.yoshiki" creationdate="20150410T124707Z">
        <seg>エラーのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding to data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160146Z" creationid="shibukawa.yoshiki" creationdate="20150412T160146Z">
        <seg>データへバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both can be compiled, but React's compiled code still has function calls for each virtual DOM element; Mithril templates compile into static Javascript data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100330Z" creationid="shibukawa.yoshiki" creationdate="20150420T100330Z">
        <seg>どちらもコンパイルは可能ですが、Reactのコンパイル済みのコードには仮想DOMエレメントごとの関数呼び出しが残っています。Mithrilのテンプレートは静的なJavaScriptのデータ構造になるため、関数呼び出しはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both components use a &lt;c0&gt;menu&lt;/c0&gt; template, which contains links for navigation between the two components, and an expensive-to-reinitialize element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124841Z" creationid="shibukawa.yoshiki" creationdate="20150502T124841Z">
        <seg>どちらのコンポーネントも&lt;c0&gt;menu&lt;/c0&gt;テンプレートを使用しています。このテンプレーには2つのコンポーネント間をナビゲートするリンクがあります。そして、最初期化のコストが非常に高いエレメントだとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both methods are optional but at least one of them must be present.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064822Z" creationid="shibukawa.yoshiki" creationdate="20170208T064822Z">
        <seg>メソッドはどちらもオプションですが、どちらか一方は必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both methods are optional, but at least one must be present.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084530Z" creationid="shibukawa.yoshiki" creationdate="20170207T084530Z">
        <seg>メソッドはどちらもオプションですが、どちらか一方は必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Browsers do, however, allow scripts to be run asynchronously via a number of execution points, such as the &lt;c0&gt;onload&lt;/c0&gt; or &lt;c1&gt;onerror&lt;/c1&gt; attributes in &lt;c2&gt;&lt;img&gt;&lt;/c2&gt; and &lt;c3&gt;&lt;iframe&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014634Z" creationid="shibukawa.yoshiki" creationdate="20150416T014634Z">
        <seg>しかし、ブラウザが非同期でスクリプトの実行を行うポイントがいくつかあります。&lt;c2&gt;&lt;img&gt;&lt;/c2&gt;と&lt;c3&gt;&lt;iframe&gt;&lt;/c3&gt;に含まれる&lt;c0&gt;onload&lt;/c0&gt;、&lt;c1&gt;onerror&lt;/c1&gt;属性などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bug Fixes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135158Z" creationid="shibukawa.yoshiki" creationdate="20160412T135158Z">
        <seg>バグ修正:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Build a simple application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135538Z" creationid="shibukawa.yoshiki" creationdate="20150407T135538Z">
        <seg>小さなアプリケーションを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Build succeeded, so travis will commit back any changes to the repo (but there won't be any)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054621Z" creationid="shibukawa.yoshiki" creationdate="20170220T054621Z">
        <seg>もし成功したら、Travisは何らかの変更があったらコミットして戻す（ないこともある）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By bundling model methods in the component, we avoid hard-coding how files are handled once they're dropped in, and instead, we provide a useful library of functions that can be consumed flexibly to meet the demands on an application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034046Z" creationid="shibukawa.yoshiki" creationdate="20150502T034046Z">
        <seg>コンポーネントにモデルメソッドをバンドルするときは、どのようにファイルを取り扱うかをハードコーディングするのを避けます。アプリケーションの需要に応じて柔軟に使用できる関数ライブラリを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, Mithril is framework designed for thick client applications, which typically download templates and data separately and combine them in the browser via Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T021718Z" creationid="shibukawa.yoshiki" creationdate="20170220T021718Z">
        <seg>これと比較すると、Mithrilは厚いクライアントアプリケーションレイヤーのためにデザインされているフレームワークです。テンプレートとデータは別々にダウンロードされ、JavaScriptを使ってブラウザ上で結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default Mithril attempts to parse a response as JSON and returns &lt;c0&gt;xhr.responseText&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005833Z" creationid="shibukawa.yoshiki" creationdate="20170220T005833Z">
        <seg>Mithrilはデフォルトでは&lt;c0&gt;xhr.responseText&lt;/c0&gt;からレスポンスのデータを取得し、JSONとしてパースして返そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default Mithril attempts to parse a response as if it was JSON.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004624Z" creationid="shibukawa.yoshiki" creationdate="20170220T004624Z">
        <seg>MithrilはデフォルトではレスポンスがJSONであるとみなしてパースしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, &lt;c0&gt;m.request&lt;/c0&gt; assumes the response is in JSON format and parses it into a Javascript object (or array).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T141053Z" creationid="shibukawa.yoshiki" creationdate="20170219T141053Z">
        <seg>デフォルトでは&lt;c0&gt;m.request&lt;/c0&gt;はレスポンスがJSONフォーマットであると想定してパースし、JavaScriptのオブジェクトや配列に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, &lt;c0&gt;m.request&lt;/c0&gt; expects response data to be in JSON format.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022709Z" creationid="shibukawa.yoshiki" creationdate="20170220T022709Z">
        <seg>デフォルトでは&lt;c0&gt;m.request&lt;/c0&gt;はレスポンスのデータはJSONであると想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, &lt;c0&gt;m.request&lt;/c0&gt; uses JSON to send and receive data to web services.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174901Z" creationid="shibukawa.yoshiki" creationdate="20150410T174901Z">
        <seg>デフォルトでは、&lt;c0&gt;m.request&lt;/c0&gt;はウェブサービスとのデータの送受信にJSONを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, &lt;c1&gt;serialize&lt;/c1&gt; converts an object to JSON, but in the case of a FormData payload, you want to pass the object intact.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175449Z" creationid="shibukawa.yoshiki" creationdate="20150414T175449Z">
        <seg>デフォルトでは&lt;c1&gt;serialize&lt;/c1&gt;はオブジェクトをJSONに変換しますが、FormDataをペイロードとして使う場合には、オブジェクトをそのまま流します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril assumes a HTTP response body are in JSON format and automatically parses it into a Javascript object or array.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T120656Z" creationid="shibukawa.yoshiki" creationdate="20170220T120656Z">
        <seg>デフォルトではMithrilはHTTPレスポンスボディがJSONフォーマットであるとみなして、自動でJavaScriptのオブジェクトか配列に変換しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril assumes both success and error responses are in JSON format, but some servers may not return JSON responses when returning HTTP error codes (e.g. 404)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175634Z" creationid="shibukawa.yoshiki" creationdate="20150414T175634Z">
        <seg>デフォルトでは、Mithrilは成功時も失敗時もレスポンスはJSONフォーマットで帰ってくるものとみなしてパースしようとしますが、サーバの中には404のようなエラーコードを返す時にJSONを返さないものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril does not swallow errors if these errors are subclasses of the Error class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141042Z" creationid="shibukawa.yoshiki" creationdate="20150415T141042Z">
        <seg>デフォルトでは、MithrilはエラーがErrorクラスのサブクラスであれば、必ずフレームワーク外までそれを届けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril escapes HTML strings in order to help prevent XSS attacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020908Z" creationid="shibukawa.yoshiki" creationdate="20150413T020908Z">
        <seg>デフォルトでは、MithrilはXSS攻撃を防ぐためにHTMLの文字列をエスケープします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril is configured to auto-redraw from scratch after component controllers are initialized, and it is configured to diff after event handlers are triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150505T234934Z" creationid="shibukawa.yoshiki" creationdate="20150505T234934Z">
        <seg>デフォルトでは、コンポーネントのコントローラが初期化されるとゼロから再描画を行う設定になっていて、イベントハンドラが起動されると差分描画が行われるように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril sets this value to &lt;c4&gt;"all"&lt;/c4&gt; before running controller constructors, and it sets it to &lt;c5&gt;"diff"&lt;/c5&gt; before event handlers are triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T131100Z" creationid="shibukawa.yoshiki" creationdate="20150416T131055Z">
        <seg>Mithirlのデフォルト&lt;c4&gt;"all"&lt;/c4&gt;で、コントローラのコンストラクタが実行される・イベントハンドラが起動される前に、差分を取得します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril uses &lt;c0&gt;window&lt;/c0&gt; itself as the dependency.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161043Z" creationid="shibukawa.yoshiki" creationdate="20150416T161043Z">
        <seg>デフォルトではMithrilは依存先として&lt;c0&gt;window&lt;/c0&gt;自身を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril views are described using &lt;a0&gt;hyperscript&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121700Z" creationid="shibukawa.yoshiki" creationdate="20170220T121700Z">
        <seg>デフォルトでは、Mithrilのビューは&lt;a0&gt;hyperscript&lt;/a0&gt;を使って定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril waits for web service requests to complete before attempting a redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235712Z" creationid="shibukawa.yoshiki" creationdate="20150414T235712Z">
        <seg>デフォルトでは、Mithrilはウェブサービスへのリクエストが完了するまでは再描画を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, changing routes causes templates to be re-rendered from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140443Z" creationid="shibukawa.yoshiki" creationdate="20160101T140443Z">
        <seg>デフォルトでは、ラウトの変更時にはすべてを破棄してテンプレートの再描画が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, event handlers schedule redraws to be done asynchronously in order to allow simultaneous events to run before redrawing (for example, the keypress and input are often used together for inputs).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152141Z" creationid="shibukawa.yoshiki" creationdate="20150416T152141Z">
        <seg>デフォルトでは、イベントハンドラは非同期で再描画を行うようにスケジュールします。これにより、同じ入力フォームに対して同時に使われるkeypressとinputなどの複数のイベントを再描画前にまとめて実行し、再描画の回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it assumes server responses are in JSON format and optionally instantiates a class with the response data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174821Z" creationid="shibukawa.yoshiki" creationdate="20150414T174821Z">
        <seg>デフォルトではサーバのレスポンスはJSONとみなして解釈します。また、オプションでレスポンスデータを元にクラスのインスタンスを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it rethrows to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180334Z" creationid="shibukawa.yoshiki" creationdate="20150415T180334Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, promises are not integrated to the Mithril auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135332Z" creationid="shibukawa.yoshiki" creationdate="20150415T135332Z">
        <seg>デフォルトでは、promiseはMithrilの自動再描画システムとは統合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the SPA router prefix is &lt;c2&gt;#!&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T101211Z" creationid="shibukawa.yoshiki" creationdate="20170207T101211Z">
        <seg>デフォルトでは、SPAのラウターは&lt;c2&gt;#!&lt;/c2&gt;をプリフィックスとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the querystring is considered the URL component to test against the routes collection</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165457Z" creationid="shibukawa.yoshiki" creationdate="20150414T165457Z">
        <seg>デフォルトではラウト集に対してクエリー文字列がURLの構成要素として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the spec requires that all thrown errors trigger rejection, which result in silent failures if the developer forgets to explicitly handle the failure case.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172608Z" creationid="shibukawa.yoshiki" creationdate="20150415T172355Z">
        <seg>デフォルトでは、Promise/A+の仕様ではすべての例外はrejectionを起動しますが、開発者がこの失敗時のコールバックを設定し忘れると、誰もエラーを受け取らずに例外は握りつぶされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this event handler rethrows the exception to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174340Z" creationid="shibukawa.yoshiki" creationdate="20150415T174340Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By freezing APIs and swapping implementations, the developer can completely avoid touching other layers in the application while refactoring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003758Z" creationid="shibukawa.yoshiki" creationdate="20150409T003758Z">
        <seg>APIをフリーズしたり実装を交換したりするだけであれば、リファクタリングを行う際に他のレイヤをまったく触る必要はなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By nature, optimizing performance make aggressive assumptions that can break in edge cases and it yields difficult to understand code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142625Z" creationid="shibukawa.yoshiki" creationdate="20150412T142625Z">
        <seg>パフォーマンスの最適化でやりがちなこととしては、特殊なケースですぐに成り立たなくなるような思い込みを行い、コードの理解が極めて難しいコードを書いてしまうということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By strategically placing calls to this pair of functions, it is possible to stack asynchronous data services in any number of ways within a context without the need to pass state variables around the entire application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190231Z" creationid="shibukawa.yoshiki" creationdate="20150411T190231Z">
        <seg>この関数呼び出しのペアを戦略的に配置することで、アプリケーションコード全体で状態変数を管理する必要性をなくし、データを取得する非同期のサービスをいくつもスタックさせることが可能になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CDNs (Content Delivery Networks)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165147Z" creationid="shibukawa.yoshiki" creationdate="20150407T165147Z">
        <seg>CDN (コンテンツデリバリネットワーク)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CSS-in-JS libraries achieve maintainability by reducing the size of the problem space, but come at the cost of having high complexity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T035616Z" creationid="shibukawa.yoshiki" creationdate="20170221T035616Z">
        <seg>CSS-in-JSライブラリを使うと、問題となる領域を狭くすることができるため、メンテナンス性が向上しますが、複雑性のコストを払う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call it at the beginning of your test file to supply a mock &lt;c0&gt;window&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161336Z" creationid="shibukawa.yoshiki" creationdate="20150416T161336Z">
        <seg>テストファイルの最初でこの関数を呼んで、モックの&lt;c0&gt;window&lt;/c0&gt;を設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call this before &lt;c0&gt;m.route()&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T112118Z" creationid="shibukawa.yoshiki" creationdate="20170206T112118Z">
        <seg>&lt;c0&gt;m.route()&lt;/c0&gt;の前に実行してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling &lt;c0&gt;e.preventDefault()&lt;/c0&gt; from a component's &lt;c1&gt;onunload&lt;/c1&gt; function aborts route changes, but it does not abort rollback or affect the current redraw in any way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092934Z" creationid="shibukawa.yoshiki" creationdate="20150502T092934Z">
        <seg>コンポーネントの&lt;c1&gt;onunload&lt;/c1&gt;関数から&lt;c0&gt;e.preventDefault()&lt;/c0&gt;を呼ぶと、ラウターの変更を中断しますが、ロールバックしたり、現在の再描画への変更を辞めることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling &lt;c0&gt;m.mount&lt;/c0&gt; with a DOM element as the first argument and a component as the second argument will call the component's controller function, and then call the component's view function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125441Z" creationid="shibukawa.yoshiki" creationdate="20150502T125441Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;を呼ぶ時は、DOMエレメントを最初の引数に設定し、2つ目の引数にコンポーネントを設定します。まずコンポーネントのcontroller関数が呼ばれ、次にview関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling &lt;c0&gt;m.redraw&lt;/c0&gt; triggers a redraw regardless of whether AJAX requests (and other asynchronous services) are completed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130115Z" creationid="shibukawa.yoshiki" creationdate="20150502T130115Z">
        <seg>&lt;c0&gt;m.redraw&lt;/c0&gt;を呼ぶと、AJAXリクエストや他の非同期サービスが完了しているかどうかに関わらず、再描画処理を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling &lt;c2&gt;m.module&lt;/c2&gt; will still work, but should be considered deprecated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140955Z" creationid="shibukawa.yoshiki" creationdate="20160412T140955Z">
        <seg>&lt;c2&gt;m.module&lt;/c2&gt;呼び出しはまだ動作するが、非推奨になった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the &lt;c8&gt;then&lt;/c8&gt; method attaches the computations represented by &lt;c9&gt;successCallback&lt;/c9&gt; and &lt;c10&gt;errorCallback&lt;/c10&gt; to the promise, which will be called when either &lt;c11&gt;resolve&lt;/c11&gt; or &lt;c12&gt;reject&lt;/c12&gt; is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134626Z" creationid="shibukawa.yoshiki" creationdate="20150415T134626Z">
        <seg>&lt;c8&gt;then&lt;/c8&gt;メソッドを呼ぶと、 &lt;c9&gt;successCallback&lt;/c9&gt;と、 &lt;c10&gt;errorCallback&lt;/c10&gt;で表される計算表現をpromiseに追加します。これは、&lt;c11&gt;resolve&lt;/c11&gt;か&lt;c12&gt;reject&lt;/c12&gt;が呼ばれると呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the increment function &lt;a0&gt;upserts&lt;/a0&gt; an object &lt;c1&gt;{count: 1}&lt;/c1&gt; to the &lt;c2&gt;/api/tutorial/1&lt;/c2&gt; endpoint.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T151035Z" creationid="shibukawa.yoshiki" creationdate="20170204T151035Z">
        <seg>&lt;c1&gt;{count: 1}&lt;/c1&gt;オブジェクトを付けて、&lt;c2&gt;/api/tutorial/1&lt;/c2&gt;のエンドポイントで公開されているインクリメントをする&lt;a0&gt;upserts&lt;/a0&gt;関数を呼び出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this function without arguments returns the currently assigned redraw strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152649Z" creationid="shibukawa.yoshiki" creationdate="20150416T152649Z">
        <seg>引数を渡さずにこの関数を呼ぶと、現在の再描画戦略を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this method while using &lt;c0&gt;m.mount&lt;/c0&gt; or &lt;c1&gt;m.route&lt;/c1&gt; should only be done if you have recurring asynchronous view updates (i.e. something that uses setInterval).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045615Z" creationid="shibukawa.yoshiki" creationdate="20150502T045615Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;と&lt;c1&gt;m.route&lt;/c1&gt;を使っている場合は、このメソッド呼び出しはsetIntervalを使っている場合など、非同期にビューを繰り返し更新したい場合に限定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cancelling redraw from event handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033846Z" creationid="shibukawa.yoshiki" creationdate="20170131T033846Z">
        <seg>イベントハンドラから再描画をキャンセルする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cancelling these redraws from within your event handlers is now done by setting the &lt;c2&gt;redraw&lt;/c2&gt; property on the passed-in event object to &lt;c3&gt;false&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120837Z" creationid="shibukawa.yoshiki" creationdate="20170131T120837Z">
        <seg>イベントハンドラ内からこれらの再描画をキャンセルするには、イベントオブジェクトの&lt;c2&gt;redraw&lt;/c2&gt;プロパティに&lt;c3&gt;false&lt;/c3&gt;を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Casting response to a type</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160937Z" creationid="shibukawa.yoshiki" creationdate="20170219T160937Z">
        <seg>レスポンスを指定の型にキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Casting the Response Data to a Class</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130540Z" creationid="shibukawa.yoshiki" creationdate="20150410T130440Z">
        <seg>ウェブサービスから帰ってきたデータをクラスにキャスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change Log</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160425T035859Z" creationid="shibukawa.yoshiki" creationdate="20160425T035859Z">
        <seg>変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change Log - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160425T035919Z" creationid="shibukawa.yoshiki" creationdate="20160425T035919Z">
        <seg>変更履歴 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change log</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154309Z" creationid="shibukawa.yoshiki" creationdate="20150412T154309Z">
        <seg>変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change log - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033422Z" creationid="shibukawa.yoshiki" creationdate="20170131T033422Z">
        <seg>変更履歴 - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change log/Migration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024847Z" creationid="shibukawa.yoshiki" creationdate="20170131T024847Z">
        <seg>変更履歴/移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes in redraw behaviour</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033907Z" creationid="shibukawa.yoshiki" creationdate="20170131T033755Z">
        <seg>再描画時の動作の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to controller and model values in this fashion will only render on the next &lt;c2&gt;m.render&lt;/c2&gt; or &lt;c3&gt;m.mount&lt;/c3&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121719Z" creationid="shibukawa.yoshiki" creationdate="20150502T121719Z">
        <seg>この方法でコントローラやモデルの値を変更しても、次の&lt;c2&gt;m.render&lt;/c2&gt;呼び出しか、&lt;c3&gt;m.mount&lt;/c3&gt;呼び出しがあるまでは描画されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing redraw strategy</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125045Z" creationid="shibukawa.yoshiki" creationdate="20150416T125045Z">
        <seg>再描画戦略の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing router prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064418Z" creationid="shibukawa.yoshiki" creationdate="20170208T064418Z">
        <seg>ラウタープリフィックスの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the flag outside of a redrawable context does nothing since the flag gets reset when entering one of the documented redrawable contexts above.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140537Z" creationid="shibukawa.yoshiki" creationdate="20150416T140537Z">
        <seg>上記の説明に書かれているように、再描画のコンテキストに入る時にこのフラグはリセットされるため、再描画コンテキスト外でこのフラグを設定しても無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the temperature value from the input updates the temperature value, which is passed to the TemperatureConverter view directly, and transformation functions are called from there.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081444Z" creationid="shibukawa.yoshiki" creationdate="20150502T081444Z">
        <seg>入力フォームから温度を入力すると、温度値が変更されてTemperatureConverterに直接渡されます。ここから変換関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cheatsheet</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111919Z" creationid="shibukawa.yoshiki" creationdate="20170206T111919Z">
        <seg>チートシート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classic MVC</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180205Z" creationid="shibukawa.yoshiki" creationdate="20150501T180205Z">
        <seg>クラシックなMVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clever readers will probably notice that we can refactor the &lt;c0&gt;add&lt;/c0&gt; method to make it much simpler:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152348Z" creationid="shibukawa.yoshiki" creationdate="20150408T152348Z">
        <seg>賢い読者の方は、&lt;c0&gt;add&lt;/c0&gt;メソッドをもっとシンプルなコードにリファクタリングすることができることに気づいたかもしれません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clicking the button should now update the count.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T152224Z" creationid="shibukawa.yoshiki" creationdate="20170204T152224Z">
        <seg>ボタンをクリックするとカウントが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client side routing has the benefit of avoiding flashes of blank screen between page transitions, and can reduce the amount of data being sent down from the server when used in conjunction with an web service oriented architecture (i.e. an application that downloads data as JSON instead of downloading pre-rendered chunks of verbose HTML).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T053012Z" creationid="shibukawa.yoshiki" creationdate="20170221T053012Z">
        <seg>クライアント側でラウティングを行うと、ページ遷移中に画面がクリアされてブランクなページが見えてしまうのを避けることができます。また、ウェブサービス指向アーキテクチャ（サーバー側で生成されたHTMLを返すのではなく、JSONでデータをダウンロードさせるウェブアプリケーション）と組み合わせると、サーバーとの通信量を削減できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code Size</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015915Z" creationid="shibukawa.yoshiki" creationdate="20150417T015915Z">
        <seg>コードサイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code splitting</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T082017Z" creationid="shibukawa.yoshiki" creationdate="20170208T082017Z">
        <seg>コード分割</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common reasons why one might need to change redraw strategy are:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143924Z" creationid="shibukawa.yoshiki" creationdate="20150416T143924Z">
        <seg>再描画戦略を変更する一般的な理由としては次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling Templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140943Z" creationid="shibukawa.yoshiki" creationdate="20150407T140943Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling a template transforms the nested function calls of a template into a raw virtual DOM tree (which is merely a collection of native Javascript objects that is ready to be rendered via &lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144245Z" creationid="shibukawa.yoshiki" creationdate="20150412T144245Z">
        <seg>テンプレートをコンパイルすると、ネストされた関数呼び出しを生の仮想DOMツリーに変換します。これはネイティブのJavaScriptオブジェクトの集合体で、&lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt;を使って即座にレンダリングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143611Z" creationid="shibukawa.yoshiki" creationdate="20150412T143611Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component &lt;c0&gt;controller&lt;/c0&gt; function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034118Z" creationid="shibukawa.yoshiki" creationdate="20170131T034118Z">
        <seg>コンポーネントの&lt;c0&gt;controller&lt;/c0&gt;関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component Shorthand</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T144932Z" creationid="shibukawa.yoshiki" creationdate="20160101T144932Z">
        <seg>コンポーネントの短縮形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034124Z" creationid="shibukawa.yoshiki" creationdate="20170131T034124Z">
        <seg>コンポーネントの引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component shorthand</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T144824Z" creationid="shibukawa.yoshiki" creationdate="20160101T144824Z">
        <seg>コンポーネントの短縮形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component views can include other components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080057Z" creationid="shibukawa.yoshiki" creationdate="20150502T080057Z">
        <seg>コンポーネントのビューは他のコンポーネントを持つことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140744Z" creationid="shibukawa.yoshiki" creationdate="20150407T140744Z">
        <seg>コンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T180346Z" creationid="shibukawa.yoshiki" creationdate="20150410T180346Z">
        <seg>コンポーネント - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components &lt;e1&gt;can&lt;/e1&gt; be stateful, but the purpose of component state is to prevent the pollution of the model layer with aspects that are inherently related to the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082912Z" creationid="shibukawa.yoshiki" creationdate="20150502T082912Z">
        <seg>コンポーネントはステートフルにすることも&lt;e1&gt;できます&lt;/e1&gt;が、コンポーネントに状態を持たせる目的は、モデルレイヤーが、コンポーネント内の情報で汚染されるのを防ぐことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are building blocks for Mithril applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061139Z" creationid="shibukawa.yoshiki" creationdate="20150502T061139Z">
        <seg>コンポーネントはMithrilのアプリケーションを作成するのに使うブロックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are merely structures that represent a viewable "page" or a part of a page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040205Z" creationid="shibukawa.yoshiki" creationdate="20150502T040205Z">
        <seg>コンポーネントは見ることが可能な「ページ」もしくはページの一部を表す、単なる構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are versatile tools to organize code and can be used in a variety of ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180342Z" creationid="shibukawa.yoshiki" creationdate="20150501T180342Z">
        <seg>コンポーネントはコードを組織化するのに使える多目的なツールで、さまざまな用途があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can be placed anywhere a regular element can.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080202Z" creationid="shibukawa.yoshiki" creationdate="20150502T080202Z">
        <seg>コンポーネントは、通常のエレメントが置けるところであればどこにでも置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can be rendered without enabling the &lt;a0&gt;auto-redrawing system&lt;/a0&gt;, via &lt;a1&gt;&lt;c2&gt;m.render&lt;/c2&gt;&lt;/a1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100144Z" creationid="shibukawa.yoshiki" creationdate="20150502T100144Z">
        <seg>コンポーネントは&lt;a0&gt;自動再描画システム&lt;/a0&gt;を有効にせずに描画を行わせることができます。&lt;a1&gt;&lt;c2&gt;m.render&lt;/c2&gt;&lt;/a1&gt;を使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can have arguments "preloaded".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075023Z" creationid="shibukawa.yoshiki" creationdate="20150502T075023Z">
        <seg>コンポーネントは「事前にロードされた」引数を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can now be parameterized via &lt;c0&gt;m.component&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140903Z" creationid="shibukawa.yoshiki" creationdate="20160412T140903Z">
        <seg>コンポーネントは&lt;c0&gt;m.component&lt;/c0&gt;を使ってパラメータ化することができるようになった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components no longer call &lt;c0&gt;this.onunload&lt;/c0&gt; when they are being removed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045043Z" creationid="shibukawa.yoshiki" creationdate="20170201T045043Z">
        <seg>コンポーネントは削除時に&lt;c0&gt;this.onunload&lt;/c0&gt;を呼ばなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components that are nested inside other components can also call &lt;c0&gt;onunload&lt;/c0&gt; and its &lt;c1&gt;e.preventDefault()&lt;/c1&gt; like top-level components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092543Z" creationid="shibukawa.yoshiki" creationdate="20150502T092510Z">
        <seg>トップレベルのコンポーネントと同様に、他のコンポーネント内にネストされたコンポーネントの&lt;c0&gt;onunload&lt;/c0&gt;を呼び出し、その中の&lt;c1&gt;e.preventDefault()&lt;/c1&gt;を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensive integration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010403Z" creationid="shibukawa.yoshiki" creationdate="20150412T010403Z">
        <seg>統括的な統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensive integration is recommended if integrating a monolithic series of asynchronous operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010451Z" creationid="shibukawa.yoshiki" creationdate="20150412T010451Z">
        <seg>非同期の操作が、常に同じ手順で使われている場合には、統括的な統合がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the underlying XMLHttpRequest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174649Z" creationid="shibukawa.yoshiki" creationdate="20150414T174649Z">
        <seg>バックエンドのXMLHttpRequestの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conforming to the spec requires either a &lt;c0&gt;setImmediate&lt;/c0&gt; polyfill (which is a significantly large library), or &lt;c1&gt;setTimeout&lt;/c1&gt; (which is required to take at least 4 milliseconds per call, according to its specs).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140848Z" creationid="shibukawa.yoshiki" creationdate="20150415T140848Z">
        <seg>仕様を満たすには、&lt;c0&gt;setImmediate&lt;/c0&gt;ポリフィル(将来のバージョンのJavaScriptと互換性を持たせるための、非常に巨大なライブラリ)か、&lt;c1&gt;setTimeout&lt;/c1&gt;(仕様により、最低でも4ミリ秒の待ちが発生する)が要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidget is the same as before
var ContactsWidget = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031258Z" creationid="shibukawa.yoshiki" creationdate="20150502T031258Z">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidgetは以前と同じ
var ContactsWidget = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content delivery networks allow the library to be cached across different websites that use the same version of the framework, and help reduce latency by serving the files from a server that is physically near the user's location.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165709Z" creationid="shibukawa.yoshiki" creationdate="20150407T165709Z">
        <seg>CDNを使うと、同じバージョンのフレームワーク使用する、さまざまなウェブサイト間でライブラリの共有が可能になります。また、ユーザの場所から物理的に近いサーバからダウンロードが行われるため、表示の遅延を減らすのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controller</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163857Z" creationid="shibukawa.yoshiki" creationdate="20150407T163857Z">
        <seg>コントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controller as a class constructor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045949Z" creationid="shibukawa.yoshiki" creationdate="20150502T045949Z">
        <seg>クラスコンストラクタ形式のコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controllers are deregistered when their &lt;c4&gt;onunload&lt;/c4&gt; event is triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021025Z" creationid="shibukawa.yoshiki" creationdate="20150502T021025Z">
        <seg>&lt;c4&gt;onunload&lt;/c4&gt;イベントが起動されるとコントローラの登録は解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controllers may explicitly call &lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt;, but, if possible, it's preferable to abstract this into a service which integrates with Mithril's auto-redrawing system (see &lt;a5&gt;&lt;c6&gt;m.startComputation&lt;/c6&gt; / &lt;c7&gt;m.endComputation&lt;/c7&gt;&lt;/a5&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033711Z" creationid="shibukawa.yoshiki" creationdate="20150421T033711Z">
        <seg>コントローラで明示的に&lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt;を呼び出すことも出来ますが、操作を抽象化してMithrilの自動再描画システムと統合する方が望ましいです(&lt;a5&gt;&lt;c6&gt;m.startComputation&lt;/c6&gt; / &lt;c7&gt;m.endComputation&lt;/c7&gt;&lt;/a5&gt;参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copy the code below into your file (and by copy, I mean type it out - you'll learn better)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025724Z" creationid="shibukawa.yoshiki" creationdate="20170131T025724Z">
        <seg>次のコードをコピーして、最初に作ったファイルにコピーしてみましょう（コピーと言いましたが、タイピングした方が学習効果は高いでしょう）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153107Z" creationid="shibukawa.yoshiki" creationdate="20150412T153107Z">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Topics</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140757Z" creationid="shibukawa.yoshiki" creationdate="20150407T140623Z">
        <seg>基本トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a file &lt;c0&gt;index.html&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000244Z" creationid="shibukawa.yoshiki" creationdate="20170205T000244Z">
        <seg>&lt;c0&gt;index.html&lt;/c0&gt;を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a file called &lt;c0&gt;src/views/UserList.js&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121353Z" creationid="shibukawa.yoshiki" creationdate="20170220T121353Z">
        <seg>&lt;c0&gt;src/views/UserList.js&lt;/c0&gt;というファイルを作成しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credits</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024826Z" creationid="shibukawa.yoshiki" creationdate="20170131T024826Z">
        <seg>クレジット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cross-communication in single-purpose components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180149Z" creationid="shibukawa.yoshiki" creationdate="20150501T180149Z">
        <seg>単一目的のコンポーネント間のコミュニケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currency (e.g. $1,000.00)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143516Z" creationid="shibukawa.yoshiki" creationdate="20160412T143516Z">
        <seg>通貨 (例 $1,000.00)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, due to lack of browser support, &lt;c0&gt;fetch()&lt;/c0&gt; typically requires a &lt;a1&gt;polyfill&lt;/a1&gt;, which is over 11kb uncompressed - nearly three times larger than Mithril's XHR module.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T030146Z" creationid="shibukawa.yoshiki" creationdate="20170220T030146Z">
        <seg>現在&lt;c0&gt;fetch()&lt;/c0&gt; を使うには、欠けているブラウザサポートをおぎなうために&lt;a1&gt;polyfill&lt;/a1&gt;が必要となりますが、これは無圧縮状態で11KBです。これはMithrilのXHRの三倍のサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom headers may also be helpful in this regard.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005350Z" creationid="shibukawa.yoshiki" creationdate="20170220T005350Z">
        <seg>このサンプルでは、カスタムヘッダーも役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom request rejections</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174633Z" creationid="shibukawa.yoshiki" creationdate="20150414T174633Z">
        <seg>カスタムリクエストのリジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOM elements</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030218Z" creationid="shibukawa.yoshiki" creationdate="20170131T024644Z">
        <seg>DOMエレメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOM manipulation should be done in the view via &lt;a0&gt;&lt;c1&gt;m()&lt;/c1&gt; and &lt;c2&gt;config&lt;/c2&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021348Z" creationid="shibukawa.yoshiki" creationdate="20150421T021246Z">
        <seg>DOM操作は、ビュー内の&lt;a0&gt;&lt;c1&gt;m()&lt;/c1&gt;と、&lt;c2&gt;config&lt;/c2&gt;&lt;/a0&gt;でのみ行うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153741Z" creationid="shibukawa.yoshiki" creationdate="20150412T153741Z">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Bindings</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014703Z" creationid="shibukawa.yoshiki" creationdate="20150408T014703Z">
        <seg>データバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data bindings connect a DOM element to a Javascript variable so that updating one updates the other.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014842Z" creationid="shibukawa.yoshiki" creationdate="20150408T014842Z">
        <seg>データバインディングは、DOM要素とJavaScriptの変数変数を結びつけて、片方の変更をもう片方に反映させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data manipulation should be done in model classes, such that controllers never have entities lying around in temporarily invalid states.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032029Z" creationid="shibukawa.yoshiki" creationdate="20150421T014232Z">
        <seg>データ操作はモデルクラス内で行われるべきです。コントローラが一時的にとはいえ、不完全な状態のモデルを取り扱うべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data services may be organized in many different ways depending on the nature of the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024553Z" creationid="shibukawa.yoshiki" creationdate="20170220T024553Z">
        <seg>データサービスの構造化は、アプリケーションの性質によって、さまざまな手法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be deserialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013247Z" creationid="shibukawa.yoshiki" creationdate="20150415T013247Z">
        <seg>デシリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be sent.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002405Z" creationid="shibukawa.yoshiki" creationdate="20150415T002405Z">
        <seg>送信するデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be serialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013135Z" creationid="shibukawa.yoshiki" creationdate="20150415T013135Z">
        <seg>シリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data-driven component identity</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050634Z" creationid="shibukawa.yoshiki" creationdate="20150502T050634Z">
        <seg>データ駆動コンポーネントの同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Date</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143442Z" creationid="shibukawa.yoshiki" creationdate="20160412T143442Z">
        <seg>日付</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Date/time picker</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143318Z" creationid="shibukawa.yoshiki" creationdate="20160412T143318Z">
        <seg>日付/時間のピッカー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with focus</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235035Z" creationid="shibukawa.yoshiki" creationdate="20150412T235035Z">
        <seg>フォーカスの操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with sorting and deleting in lists</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235054Z" creationid="shibukawa.yoshiki" creationdate="20150412T235054Z">
        <seg>リスト内のソートと削除の操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with state</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050550Z" creationid="shibukawa.yoshiki" creationdate="20150502T050550Z">
        <seg>状態の取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deep data structures</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133334Z" creationid="shibukawa.yoshiki" creationdate="20170206T133334Z">
        <seg>深いデータ構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deep data structures are serialized in a way that is understood by popular web application servers such as PHP, Rails and ExpressJS</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133436Z" creationid="shibukawa.yoshiki" creationdate="20170206T133436Z">
        <seg>深いデータ構造は有名なウェブアプリケーションフレームワークのPHP、Rails、ExpressJSが解釈してくれる方法でシリアライズされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default value is "search".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165706Z" creationid="shibukawa.yoshiki" creationdate="20150414T165706Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to "callback"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014628Z" creationid="shibukawa.yoshiki" creationdate="20150415T014628Z">
        <seg>デフォルト値は"callback"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c0&gt;false&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152156Z" creationid="shibukawa.yoshiki" creationdate="20150416T152156Z">
        <seg>デフォルト値は&lt;c0&gt;false&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c0&gt;true&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T065813Z" creationid="shibukawa.yoshiki" creationdate="20170219T065813Z">
        <seg>デフォルト値は&lt;c0&gt;true&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c0&gt;undefined&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002340Z" creationid="shibukawa.yoshiki" creationdate="20150415T002340Z">
        <seg>デフォルトは&lt;c0&gt;undefined&lt;/c0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c0&gt;undefined&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T065828Z" creationid="shibukawa.yoshiki" creationdate="20170219T065828Z">
        <seg>デフォルトは&lt;c0&gt;undefined&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c1&gt;JSON.stringify&lt;/c1&gt;, or if &lt;c2&gt;options.data&lt;/c2&gt; is an instance of &lt;a3&gt;&lt;c4&gt;FormData&lt;/c4&gt;&lt;/a3&gt;, defaults to the &lt;a5&gt;identity function&lt;/a5&gt; (i.e. &lt;c6&gt;function(value) {return value}&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074341Z" creationid="shibukawa.yoshiki" creationdate="20170219T074341Z">
        <seg>デフォルトは&lt;c1&gt;JSON.stringify&lt;/c1&gt;、あるいは、&lt;c2&gt;options.data&lt;/c2&gt;が&lt;a3&gt;&lt;c4&gt;FormData&lt;/c4&gt;&lt;/a3&gt;の時は&lt;a5&gt;恒等写像&lt;/a5&gt;（&lt;c6&gt;function(value) {return value}&lt;/c6&gt;）となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c2&gt;false&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075943Z" creationid="shibukawa.yoshiki" creationdate="20170219T075943Z">
        <seg>デフォルトは&lt;c2&gt;false&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c4&gt;false&lt;/c4&gt; for &lt;c5&gt;GET&lt;/c5&gt; requests and &lt;c6&gt;true&lt;/c6&gt; for other methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075809Z" creationid="shibukawa.yoshiki" creationdate="20170219T075809Z">
        <seg>&lt;c5&gt;GET&lt;/c5&gt;リクエスト時のデフォルトは&lt;c4&gt;false&lt;/c4&gt;で、他のメソッドのリクエスト時のデフォルトは&lt;c6&gt;true&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;c7&gt;GET&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T064442Z" creationid="shibukawa.yoshiki" creationdate="20170219T064442Z">
        <seg>デフォルトは&lt;c7&gt;GET&lt;/c7&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to a function that returns &lt;c0&gt;xhr.responseText&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074551Z" creationid="shibukawa.yoshiki" creationdate="20170219T074551Z">
        <seg>デフォルトは&lt;c0&gt;xhr.responseText&lt;/c0&gt;を返す関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to a small wrapper around &lt;c0&gt;JSON.parse&lt;/c0&gt; that returns &lt;c1&gt;null&lt;/c1&gt; for empty responses.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074446Z" creationid="shibukawa.yoshiki" creationdate="20170219T074446Z">
        <seg>デフォルトは、空のレスポンスに対して&lt;c1&gt;null&lt;/c1&gt;を返すようにした、&lt;c0&gt;JSON.parse&lt;/c0&gt;のラッパー関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to false</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080749Z" creationid="shibukawa.yoshiki" creationdate="20170207T080749Z">
        <seg>デフォルトはfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to false.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171614Z" creationid="shibukawa.yoshiki" creationdate="20150414T171614Z">
        <seg>デフォルトはfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to the &lt;a0&gt;identity function&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070324Z" creationid="shibukawa.yoshiki" creationdate="20170219T070324Z">
        <seg>デフォルトは&lt;a0&gt;恒等写像（入力をそのまま返す関数）&lt;/a0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defending against nullables can typically be achieved via the &lt;c0&gt;initialValue&lt;/c0&gt; option in &lt;a1&gt;&lt;c2&gt;m.request&lt;/c2&gt;&lt;/a1&gt; and basic null checks (e.g. &lt;c3&gt;data ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121023Z" creationid="shibukawa.yoshiki" creationdate="20150502T121023Z">
        <seg>nullになる可能性がある場合の対処法としては、&lt;a1&gt;&lt;c2&gt;m.request&lt;/c2&gt;&lt;/a1&gt;に&lt;c0&gt;initialValue&lt;/c0&gt;オプションを指定するか、基本的なnullチェック(例: &lt;c3&gt;data ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines a router prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082610Z" creationid="shibukawa.yoshiki" creationdate="20170207T082610Z">
        <seg>ラウターのプリフィックスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the property of the DOM element whose value will be passed to the callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140830Z" creationid="shibukawa.yoshiki" creationdate="20150414T140830Z">
        <seg>この関数のコールバックに渡したい値を持つ、DOMエレメントのプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines what routes exist</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153238Z" creationid="shibukawa.yoshiki" creationdate="20150412T153238Z">
        <seg>存在するラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162438Z" creationid="shibukawa.yoshiki" creationdate="20150409T162432Z">
        <seg>ラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Demo</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034741Z" creationid="shibukawa.yoshiki" creationdate="20150502T034741Z">
        <seg>デモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dependency management</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143527Z" creationid="shibukawa.yoshiki" creationdate="20160412T143527Z">
        <seg>依存性マネジメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the application, this may or may not be desirable.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T071842Z" creationid="shibukawa.yoshiki" creationdate="20170208T071842Z">
        <seg>アプリケーションによりますが、この動作が望ましくないこともあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the overall application architecture, it may be desirable to transform the response data of a request to a specific class or type (for example, to uniformly parse date fields or to have helper methods).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004042Z" creationid="shibukawa.yoshiki" creationdate="20170220T004042Z">
        <seg>アプリケーションのアーキテクチャによっては、レスポンスデータを特定のクラスや型に変換し、データの正規化を行ったり、ヘルパーメソッドを持たせたいことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deprecations:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140911Z" creationid="shibukawa.yoshiki" creationdate="20160412T140911Z">
        <seg>非推奨化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Description</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133050Z" creationid="shibukawa.yoshiki" creationdate="20170206T133050Z">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deserializes an object from an URI encoded querystring representation, following the same deserialization conventions as &lt;a0&gt;URI.js&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135909Z" creationid="shibukawa.yoshiki" creationdate="20150502T135909Z">
        <seg>&lt;a0&gt;URI.js&lt;/a0&gt;のデシリアライズ規約を用いて、URIエンコードされたクエリー文字列表現されたオブジェクトをデシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite being much smaller, Mithril's XHR module supports many important and not-so-trivial-to-implement features like &lt;a0&gt;URL interpolation&lt;/a0&gt;, querystring serialization and &lt;a1&gt;JSON-P requests&lt;/a1&gt;, in addition to its ability to integrate seamlessly to Mithril's autoredrawing subsystem.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T033532Z" creationid="shibukawa.yoshiki" creationdate="20170220T033407Z">
        <seg>ファイルサイズは大きくありませんが、自動再描画システムとの統合に加えて、&lt;a0&gt;URLの変数&lt;/a0&gt;, クエリー文字列のシリアライズ, &lt;a1&gt;JSON-Pリクエスト&lt;/a1&gt;など、MithrilのXHRモジュールは重要かつ、実装が簡単ではないさまざまな機能を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Destructors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234210Z" creationid="shibukawa.yoshiki" creationdate="20150412T234210Z">
        <seg>デストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determines whether the &lt;c0&gt;m.request&lt;/c0&gt; can affect template rendering.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002601Z" creationid="shibukawa.yoshiki" creationdate="20150415T002601Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;中にテンプレートのレンダリング行うかどうかの設定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Difference between computation methods and m.redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T112333Z" creationid="shibukawa.yoshiki" creationdate="20150502T112333Z">
        <seg>computationメソッドとm.redrawの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences from Other MVC Frameworks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140957Z" creationid="shibukawa.yoshiki" creationdate="20150407T140957Z">
        <seg>他のMVCフレームワークとの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences from Promises/A+</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015805Z" creationid="shibukawa.yoshiki" creationdate="20150415T015805Z">
        <seg>Promises/A+との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Direct download</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164448Z" creationid="shibukawa.yoshiki" creationdate="20150407T164448Z">
        <seg>直接ダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution of concrete responsibilities</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180130Z" creationid="shibukawa.yoshiki" creationdate="20150501T180130Z">
        <seg>具体的な責務の分担</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dividing the codebase this way is known as code splitting or lazy loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T085745Z" creationid="shibukawa.yoshiki" creationdate="20170208T085745Z">
        <seg>このようなコードベースの分割は、コード分割、あるいは遅延ダウンロードと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not create or manipulate trust flags manually.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015611Z" creationid="shibukawa.yoshiki" creationdate="20150416T015611Z">
        <seg>信頼するフラグを手で作成したり変更しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docs and code samples for your reference</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135618Z" creationid="shibukawa.yoshiki" creationdate="20150407T135618Z">
        <seg>参照用のドキュメントとコードサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113916Z" creationid="shibukawa.yoshiki" creationdate="20150417T113916Z">
        <seg>ドキュメンテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the controller level is also possible, but philosophically not recommended, because by tying logic to a controller, the code becomes harder to reuse due to unrelated controller dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124045Z" creationid="shibukawa.yoshiki" creationdate="20150410T124045Z">
        <seg>この処理をコントローラのレベルで行うことができますが、Mithrilの哲学としては推奨していません。コントローラと関係ない処理であったとしても、コントローラとロジックが結びついてしまうと再利用が難しくなるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the model level is also possible, but generally leads to more code in order to connect all the dots.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125012Z" creationid="shibukawa.yoshiki" creationdate="20150410T125012Z">
        <seg>もちろん、モデルレベルで行うこともできますが、全ての関連する機能を正しく動かすためには、多くのコードを書く必要がああります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the model level is also possible, but philosophically not recommended, because by tying redirection to the model, the code becomes harder to reuse due to overly tight coupling.</seg>
      </tuv>
      <tuv lang="JA" changeid="shunya_shishido" changedate="20151110T183623Z" creationid="shibukawa.yoshiki" creationdate="20150410T124425Z">
        <seg>この処理をモデルレイヤで行うことも出来ますが、Mithrilの哲学としては非推奨です。リダイレクト処理とモデルが結びついてしまうと、再利用が難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so will make the batch upload atomic, i.e. no files will be processed if there's an error during the upload, so it's not possible to have only part of the files saved.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T190656Z" creationid="shibukawa.yoshiki" creationdate="20170219T190656Z">
        <seg>複数ファイルを同時にアップロードすると、その通信はアトミックになります。そのため、アップロード中にエラーがひとつでもあると、すべてのファイルのアップロードが無効になります。一部だけを保存することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so will trigger another redraw, which will result in an infinite loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094851Z" creationid="shibukawa.yoshiki" creationdate="20150502T094851Z">
        <seg>再描画処理の中で再描画を行ってしまうと、無限ループになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing the templating heavy-lifting in the browser can bring benefits like reducing operational costs by freeing server resources.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022352Z" creationid="shibukawa.yoshiki" creationdate="20170220T022352Z">
        <seg>テンプレートの実行をブラウザ側に寄せると、サーバーリソースが解放されるため、サーバーのオペレーションコストが下がるメリットがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download size</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025046Z" creationid="shibukawa.yoshiki" creationdate="20170131T025046Z">
        <seg>ダウンロードサイズの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic URLs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T145458Z" creationid="shibukawa.yoshiki" creationdate="20170219T145458Z">
        <seg>動的URL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic parameters are wild cards that allow selecting a component based on a URL pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135745Z" creationid="shibukawa.yoshiki" creationdate="20150502T135745Z">
        <seg>動的パラメータは、URLパターンに応じてコンポーネント選択する時に使用できるワイルドカードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic parameters are words preceded by a colon &lt;c0&gt;:&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160002Z" creationid="shibukawa.yoshiki" creationdate="20150414T160002Z">
        <seg>動的パラメータはコロン(&lt;c0&gt;:&lt;/c0&gt;)で始まっている単語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c0&gt;m()&lt;/c0&gt; call creates a virtual DOM element, that is, a Javascript object that represents a DOM element, and which is eventually converted into one.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000527Z" creationid="shibukawa.yoshiki" creationdate="20150413T000527Z">
        <seg>それぞれの&lt;c0&gt;m()&lt;/c0&gt;呼び出して作成される仮想DOM要素は、DOMエレメントに対応する情報を持つJavaScriptオブジェクトで、最終的にDOMエレメントに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each computation function takes a value as a parameter and is expected to return another value, which in turns is forwarded along to the next computation function (or functions) in the tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133903Z" creationid="shibukawa.yoshiki" creationdate="20150415T133903Z">
        <seg>それぞれの計算関数はその値を引数として受け取り、他の値を返すことが期待されています。その値は、木の中の次の計算関数に渡されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each contains a menu and some text.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100837Z" creationid="shibukawa.yoshiki" creationdate="20170207T100837Z">
        <seg>それぞれのコンポーネントはメニューとテキストを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these should point to a Javascript function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100447Z" creationid="shibukawa.yoshiki" creationdate="20150502T100447Z">
        <seg>それぞれ、JavaScriptの関数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of those should point to a Javascript function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T161544Z" creationid="shibukawa.yoshiki" creationdate="20150413T161544Z">
        <seg>このどちらの属性も、JavaScriptの関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements are recreated if either their node name changes, or if the list of attribute names change, or if the ID attribute changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144131Z" creationid="shibukawa.yoshiki" creationdate="20150413T144131Z">
        <seg>ノード名が変更されたり、属性名のリストが変更されたり、ID属性が変更されれば、エレメントは再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ember is a highly comprehensive MVC framework, providing a large API that covers not only traditional MVC patterns, but also a vast range of helper utilities as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095246Z" creationid="shibukawa.yoshiki" creationdate="20150420T095246Z">
        <seg>Emberは伝統的なMVCフレームワークだけではなく、さまざまな大量のヘルパーコードを含む、非常に大きなAPIセットを提供する広範囲に渡るMVCフレームワークです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ember is also more opinionated in terms of how application architecture should look, and as a result, tends to be less transparent in terms of what is actually happening under the hood.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095555Z" creationid="shibukawa.yoshiki" creationdate="20150420T095555Z">
        <seg>Emberはまた、アプリケーションのアーキテクチャがどうあるべきかを厳しく規定しています。そのため、裏で何が起こっているのかが不透明で見通しにくくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error binding is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124907Z" creationid="shibukawa.yoshiki" creationdate="20150410T124907Z">
        <seg>Mithrilではエラーのバインディングはコントローラレベルで行われることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: &lt;c0&gt;http://server/#/path/to/page&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005232Z" creationid="shibukawa.yoshiki" creationdate="20150410T005232Z">
        <seg>サンプルURL: &lt;c0&gt;http://server/#/path/to/page&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: &lt;c0&gt;http://server/?/path/to/page&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005115Z" creationid="shibukawa.yoshiki" creationdate="20150410T005115Z">
        <seg>サンプルURL: &lt;c0&gt;http://server/?/path/to/page&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: &lt;c0&gt;http://server/path/to/page&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005502Z" creationid="shibukawa.yoshiki" creationdate="20150410T005502Z">
        <seg>サンプルURL: &lt;c0&gt;http://server/path/to/page&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: HTML5 drag-n-drop file uploader component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031809Z" creationid="shibukawa.yoshiki" creationdate="20150501T180240Z">
        <seg>サンプル: HTML5ドラッグ・アンド・ドロップでファイルアップロードするコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024720Z" creationid="shibukawa.yoshiki" creationdate="20170131T024720Z">
        <seg>サンプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054001Z" creationid="shibukawa.yoshiki" creationdate="20170220T054001Z">
        <seg>サンプル - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153334Z" creationid="shibukawa.yoshiki" creationdate="20150413T153334Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposes the underlying XMLHttpRequest object for low-level configuration.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070211Z" creationid="shibukawa.yoshiki" creationdate="20170219T070211Z">
        <seg>低レベルの設定を行うために、APIの内部に隠れているXMLHttpRequestオブジェクトに触れるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressiveness can be achieved using standard refactoring techniques:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015459Z" creationid="shibukawa.yoshiki" creationdate="20150413T015459Z">
        <seg>一般的なリファクタリングのテクニックを使うと、表現力を向上させることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extracting Metadata from the Response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174624Z" creationid="shibukawa.yoshiki" creationdate="20150414T174624Z">
        <seg>レスポンス中のメタデータの分解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Falls back to &lt;c0&gt;window.setTimeout&lt;/c0&gt;/&lt;c1&gt;window.clearTimeout&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162112Z" creationid="shibukawa.yoshiki" creationdate="20150416T162112Z">
        <seg>利用できないときは代わりに&lt;c0&gt;window.setTimeout&lt;/c0&gt;/&lt;c1&gt;window.clearTimeout&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fast</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133849Z" creationid="shibukawa.yoshiki" creationdate="20150407T133849Z">
        <seg>高速</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Feel free to edit the project and author information in this file.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071539Z" creationid="shibukawa.yoshiki" creationdate="20170207T071539Z">
        <seg>このファイルを編集して、プロジェクト情報と作者名を自由に変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File Separation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015007Z" creationid="shibukawa.yoshiki" creationdate="20150421T015007Z">
        <seg>ファイル分割</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File uploads</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155240Z" creationid="shibukawa.yoshiki" creationdate="20170219T155240Z">
        <seg>ファイルアップロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File uploads with FormData</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174538Z" creationid="shibukawa.yoshiki" creationdate="20150414T174538Z">
        <seg>FormDataによるファイルのアップロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the low-level &lt;a8&gt;&lt;c9&gt;m.render&lt;/c9&gt;&lt;/a8&gt; can also be used if a developer chooses to opt out of rest of the framework altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000546Z" creationid="shibukawa.yoshiki" creationdate="20150506T000546Z">
        <seg>また、開発者が再描画の仕組みを完全に止める選択をした場合にも、&lt;a8&gt;&lt;c9&gt;m.render&lt;/c9&gt;&lt;/a8&gt;関数を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First and foremost, you should think hard about whether performance optimization is truly your last resort.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142408Z" creationid="shibukawa.yoshiki" creationdate="20150412T142408Z">
        <seg>まず第一に、パフォーマンスの最適化が自分にとって最後の手段であるかどうかを真剣に考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First let's create a module called &lt;c0&gt;views/UserForm.js&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120028Z" creationid="shibukawa.yoshiki" creationdate="20170221T120028Z">
        <seg>まず、&lt;c0&gt;views/UserForm.js&lt;/c0&gt;というモジュールを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First let's create an entry point for the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000236Z" creationid="shibukawa.yoshiki" creationdate="20170205T000236Z">
        <seg>まずはアプリケーションのエントリーポイントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First we create a component for it:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031919Z" creationid="shibukawa.yoshiki" creationdate="20170131T031919Z">
        <seg>まず次のコンポーネントを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First we create a function that calls &lt;c0&gt;m.request&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T143711Z" creationid="shibukawa.yoshiki" creationdate="20170204T143711Z">
        <seg>まず、&lt;c0&gt;m.request&lt;/c0&gt;を呼び出す関数を作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let's include Mithril and our model, since we'll need to use both:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121419Z" creationid="shibukawa.yoshiki" creationdate="20170220T121419Z">
        <seg>まず、これからすぐに必要になるMithrilとモデルをインクルードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we include Mithril in the module:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055458Z" creationid="shibukawa.yoshiki" creationdate="20170220T055458Z">
        <seg>まず、Mithrilをインクルードして取り込みましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For developer convenience, Mithril makes an exception for the &lt;c0&gt;class&lt;/c0&gt; attribute: if there are classes defined in both parameters, they are concatenated as a space separated list.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153249Z" creationid="shibukawa.yoshiki" creationdate="20150413T153249Z">
        <seg>開発者の利便性のために、Mithrilは&lt;c0&gt;class&lt;/c0&gt;属性は特別扱いをします。もし両方で定義されていた場合には、スペース区切りのリストとして2つのパラメータを統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each &lt;c0&gt;m.startComputation&lt;/c0&gt; call a library makes, it MUST also make one and ONLY one corresponding &lt;c1&gt;m.endComputation&lt;/c1&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193257Z" creationid="shibukawa.yoshiki" creationdate="20150411T193257Z">
        <seg>ライブラリ内のそれぞれの&lt;c0&gt;m.startComputation&lt;/c0&gt;呼び出しに対して、「かならず」「１回だけ」&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example a form might have an input and a cancel button.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160654Z" creationid="shibukawa.yoshiki" creationdate="20150407T153100Z">
        <seg>例えば、テキスト入力とキャンセルのボタンを持っているフォームがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c1&gt;m.route.set("/page1")&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053322Z" creationid="shibukawa.yoshiki" creationdate="20170208T053322Z">
        <seg>&lt;c1&gt;m.route.set("/page1")&lt;/c1&gt;のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an application could "remember" the state of a large form when the user leaves a page by navigating away, such that if the user pressed the back button in the browser, they'd have the form filled rather than a blank form.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061730Z" creationid="shibukawa.yoshiki" creationdate="20170208T061730Z">
        <seg>例えば、ユーザーがナビゲーションに従って別のページに遷移した時に、巨大な入力フォームの状態をアプリケーションに覚えさせておくこともできます。この機能を使うと、ユーザーがブラウザの「戻る」ボタンを押したときにフォームの状態を入力時の状態に維持しておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an autocompleter component may need to internally store a flag to indicate whether the dropdown is visible, but this kind of state is not relevant to an application's business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083342Z" creationid="shibukawa.yoshiki" creationdate="20150502T083342Z">
        <seg>例えば、自動補完コンポーネントはドロップダウンが表示されているかどうかのフラグを持っています。しかしこの種の状態はアプリケーションのビジネスロジックは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both &lt;c0&gt;class&lt;/c0&gt; and &lt;c1&gt;className&lt;/c1&gt; are valid.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153529Z" creationid="shibukawa.yoshiki" creationdate="20150413T153529Z">
        <seg>&lt;c0&gt;class&lt;/c0&gt;も&lt;c1&gt;className&lt;/c1&gt;も使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if &lt;c0&gt;type&lt;/c0&gt; is the following class:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013847Z" creationid="shibukawa.yoshiki" creationdate="20150415T013847Z">
        <seg>もし&lt;c0&gt;type&lt;/c0&gt;として次のクラスが渡されたとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the response is &lt;c0&gt;{data: [{name: "John"}, {name: "Mary"}]}&lt;/c0&gt; and the unwrap function is &lt;c1&gt;function(response) {return response.data}&lt;/c1&gt;, then the response will be considered to be &lt;c2&gt;[{name: "John"}, {name: "Mary"}]&lt;/c2&gt; when processing the &lt;c3&gt;type&lt;/c3&gt; parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012946Z" creationid="shibukawa.yoshiki" creationdate="20150415T012946Z">
        <seg>もし返り値が&lt;c0&gt;{data: [{name: "John"}, {name: "Mary"}]}&lt;/c0&gt;というJSONで、unwrap関数として&lt;c1&gt;function(response) {return response.data}&lt;/c1&gt;という関数が渡された場合には、&lt;c3&gt;type&lt;/c3&gt;パラメータの評価時に&lt;c2&gt;[{name: "John"}, {name: "Mary"}]&lt;/c2&gt;というデータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if todo descriptions needed to always be uppercased, one could simply change the &lt;c0&gt;description&lt;/c0&gt; getter-setter:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002402Z" creationid="shibukawa.yoshiki" creationdate="20150409T002402Z">
        <seg>例えば、ToDoの説明(description)が大文字でなければならないとしたら、&lt;c0&gt;description&lt;/c0&gt; getter-setterだけを置き換えればこれが実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if we wanted to change the application to make the list be persisted, a native Array would most certainly not be a suitable class to use.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003136Z" creationid="shibukawa.yoshiki" creationdate="20150409T003136Z">
        <seg>例えば、リストを永続化させる機能をアプリケーションに追加したくなったとすると、ネイティブのArrayクラスはもっとも適切なクラスとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are building a table with thousands of rows and finding that the template is slow, you should first consider making the table show less items, because from a user experience perspective, no one is realistically going to scan through thousands of records.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143359Z" creationid="shibukawa.yoshiki" creationdate="20150412T143359Z">
        <seg>もし、数千行の行を持つテーブルの構築を行っていて、そのテンプレートの動作が遅いことが分かったとしても、まずはユーザビリティの観点から表示行数を少なくすることを検討すべきです。だれも数千行のレコードを実際に読み込もうとする人などいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you were to call a web service using &lt;c0&gt;m.request&lt;/c0&gt;, you would not need to add more calls to &lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt; (you would still need the first pair in the event handler, though).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134719Z" creationid="shibukawa.yoshiki" creationdate="20150412T134719Z">
        <seg>例えば、もし非同期のウェブサービス呼び出しに&lt;c0&gt;m.request&lt;/c0&gt;を使っていれば、これ以上&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;呼び出しを追加する必要はありませんが、イベントハンドラには追加しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you're requesting an SVG, you probably want to set the content type accordingly.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005431Z" creationid="shibukawa.yoshiki" creationdate="20170220T005431Z">
        <seg>たとえば、SVGをリクエストする時は、適切なContent-Typeをセットしたいと考えるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in an autocompleter/typeahead widget, you want to ensure that only the last request completes, because typically autocompleters fire several requests as the user types and HTTP requests may complete out of order due to the unpredictable nature of networks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152815Z" creationid="shibukawa.yoshiki" creationdate="20170219T152815Z">
        <seg>例えば、自動補完やサジェストウィジェットの場合、最後にリクエストした補完だけを利用したいはずです。よくある自動補完ではユーザーが入力するたびに何度もリクエストが発生しますが、ネットワークの性質上、結果の順序が正しく返ってくるとは限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's say that you're generating a link from an entry that comes from a web service:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002254Z" creationid="shibukawa.yoshiki" creationdate="20150413T002254Z">
        <seg>ウェブサービスから帰ってきたエントリーを元に、動的にリンクが書き換わるようなリンクを作成するには次のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the value for &lt;c0&gt;className&lt;/c0&gt; should be a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153641Z" creationid="shibukawa.yoshiki" creationdate="20150413T153641Z">
        <seg>例えば、&lt;c0&gt;className&lt;/c0&gt;の値は文字列である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the value for the &lt;c0&gt;onclick&lt;/c0&gt; attribute should be a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153914Z" creationid="shibukawa.yoshiki" creationdate="20150413T153914Z">
        <seg>例えば、&lt;c0&gt;onclick&lt;/c0&gt;属性は関数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there is simply never a case where a developer would want to programmatically handle the error of accessing the property of a nullable entity without first checking for its existence.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172742Z" creationid="shibukawa.yoshiki" creationdate="20150415T172742Z">
        <seg>開発者は、最初にその存在を把握しなければ、nullになる可能性のあるオブジェクトのプロパティのアクセスエラーのハンドリングをしたいとは思わないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you could create a form like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061822Z" creationid="shibukawa.yoshiki" creationdate="20170208T061822Z">
        <seg>次のようなフォームを作ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you might have a &lt;c0&gt;UserForm&lt;/c0&gt; component that lives alongside other unrelated components on a bigger page, but it probably doesn't make sense for the parent page to be aware of the unsaved user data stored within the &lt;c1&gt;UserForm&lt;/c1&gt; component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084102Z" creationid="shibukawa.yoshiki" creationdate="20150502T084102Z">
        <seg>例えば、大きなページ内に、他の関係ないコンポーネントと一緒に&lt;c0&gt;UserForm&lt;/c0&gt;コンポーネントがあったとします。&lt;c1&gt;UserForm&lt;/c1&gt;コンポーネント内に未保存のデータがあった場合は、親ページに知らせる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you might only be interested in running a redraw if a user presses the space bar, and you might not want to waste a redraw if the user presses any other key.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150203Z" creationid="shibukawa.yoshiki" creationdate="20150416T150203Z">
        <seg>例えば、ユーザがスペースバーを推した時だけ再描画を行い、そうでない場合は再描画はムダなのでやりたいくない、ということもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013232Z" creationid="shibukawa.yoshiki" creationdate="20150410T013232Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on &lt;c0&gt;onmatch&lt;/c0&gt;, see the &lt;a1&gt;advanced component resolution&lt;/a1&gt; section</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085649Z" creationid="shibukawa.yoshiki" creationdate="20170207T085649Z">
        <seg>&lt;c0&gt;onmatch&lt;/c0&gt;の詳細は、&lt;a1&gt;応用的なコンポーネントの解決&lt;/a1&gt;のセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on components, see &lt;a0&gt;&lt;c1&gt;m.component&lt;/c1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125538Z" creationid="shibukawa.yoshiki" creationdate="20150502T125538Z">
        <seg>より詳細な情報は&lt;a0&gt;&lt;c1&gt;m.component&lt;/c1&gt;&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see this page:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014234Z" creationid="shibukawa.yoshiki" creationdate="20150417T014234Z">
        <seg>詳細についてはこのページを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For simplicity, our application will have only one component, and we're going to use it as the namespace for our application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040232Z" creationid="shibukawa.yoshiki" creationdate="20150502T040232Z">
        <seg>サンプルを簡単にするために、これから作るアプリケーションにはコンポーネントを1つだけ作ることにします。そしてそれをアプリケーションの名前空間として使っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the most part, Mithril promises behave as you'd expect a &lt;a0&gt;Promise/A+&lt;/a0&gt; promise to behave, but have one difference: Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140147Z" creationid="shibukawa.yoshiki" creationdate="20150415T140022Z">
        <seg>ほとんどの部分で、Mithrilのpromiseは&lt;a0&gt;Promise/A+&lt;/a0&gt;の仕様通りの動作をしますが1つ異なる点があります。Mithrilのpromiseは、可能であれば同期で処理を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of testing out our code so far, the view can be rendered using the &lt;c0&gt;m.render&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013558Z" creationid="shibukawa.yoshiki" creationdate="20150408T013537Z">
        <seg>コードをテストする目的で表示したい場合は、&lt;c0&gt;m.render&lt;/c0&gt;メソッドを呼ぶことでビューをレンダリングすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the sake of simplicity, in the example above, the user's logged in status is kept in a global variable, and that flag is merely toggled when the user clicks the login button.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075843Z" creationid="shibukawa.yoshiki" creationdate="20170208T075733Z">
        <seg>サンプルコードを短くするためにユーザーのログイン状態はグローバル変数を使って保持しています。このフラグはユーザーががログインボタンを押すと単純に入れ替わる手抜き実装になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the server, we'll use &lt;a0&gt;REM&lt;/a0&gt;, a mock REST API designed for toy apps like this tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T143643Z" creationid="shibukawa.yoshiki" creationdate="20170204T143643Z">
        <seg>サーバーには、チュートリアルのようなおもちゃアプリケーションのために作られた、モックのREST APIを提供する&lt;a0&gt;REM&lt;/a0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, &lt;c0&gt;m.trust&lt;/c0&gt; will not auto-run &lt;c1&gt;&lt;script&gt;&lt;/c1&gt; tags from trusted strings.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014430Z" creationid="shibukawa.yoshiki" creationdate="20150416T014430Z">
        <seg>このため、&lt;c0&gt;m.trust&lt;/c0&gt;が自動的に&lt;c1&gt;&lt;script&gt;&lt;/c1&gt;タグを実行することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this tutorial, we'll make XHR calls to the &lt;a1&gt;REM&lt;/a1&gt; API, a mock REST API designed for rapid prototyping.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055740Z" creationid="shibukawa.yoshiki" creationdate="20170220T055701Z">
        <seg>このチュートリアルでは、&lt;a1&gt;REM&lt;/a1&gt; APIへの呼び出しを行います。これは高速なプロトタイピングのためにデザインされたのモックのREST APIです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those reasons, choosing &lt;c0&gt;fetch()&lt;/c0&gt; streaming instead of &lt;c1&gt;m.request&lt;/c1&gt; is only recommended for extremely resource intensive applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034412Z" creationid="shibukawa.yoshiki" creationdate="20170220T034412Z">
        <seg>これらの理由により、&lt;c1&gt;m.request&lt;/c1&gt;の代わりに&lt;c0&gt;fetch()&lt;/c0&gt;ストリームが推奨されるのは大量のデータを扱うアプリケーションに限られるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Force the use of the HTTP body section for &lt;c0&gt;data&lt;/c0&gt; in &lt;c1&gt;GET&lt;/c1&gt; requests when set to &lt;c2&gt;true&lt;/c2&gt;, or the use of querystring for other HTTP methods when set to &lt;c3&gt;false&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075239Z" creationid="shibukawa.yoshiki" creationdate="20170219T075239Z">
        <seg>&lt;c2&gt;true&lt;/c2&gt;をセットすると、&lt;c1&gt;GET&lt;/c1&gt;リクエスト時にHTTPのボディセクションを&lt;c0&gt;data&lt;/c0&gt;に使うようになります。 &lt;c3&gt;false&lt;/c3&gt;を設定すると他のHTTPメソッドのときにクエリー文字列を使うようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125110Z" creationid="shibukawa.yoshiki" creationdate="20150416T125110Z">
        <seg>強制再描画</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Formatters / parsers</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143437Z" creationid="shibukawa.yoshiki" creationdate="20160412T143437Z">
        <seg>フォーマッタ/パーサ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, Mithril offers a &lt;a0&gt;&lt;c1&gt;onbeforeremove&lt;/c1&gt;&lt;/a0&gt; hook that allows us to defer the removal of an element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105746Z" creationid="shibukawa.yoshiki" creationdate="20170206T105746Z">
        <seg>幸い、Mithril 1.0以降では&lt;a0&gt;&lt;c1&gt;onbeforeremove&lt;/c1&gt;&lt;/a0&gt;フックを提供しており、要素の削除を遅延させるのが簡単に行えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, bindings can also be &lt;s0&gt;bi-directional&lt;/s0&gt;: that is, they can be coded in such a way that, in addition to setting the DOM value, it's also possible to read it as a user types, and then update the &lt;c1&gt;description&lt;/c1&gt; getter-setter in the view-model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110549Z" creationid="shibukawa.yoshiki" creationdate="20150408T020207Z">
        <seg>幸い、バインディングは&lt;s0&gt;双方向&lt;/s0&gt;で行うように設定することができます。双方向になると、DOMの値を設定するだけでなく、ユーザが入力した内容を読み込んで、ビューモデル内の&lt;c1&gt;description&lt;/c1&gt; setter-getterの内容を更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, there are a number of tools that facilitate the task of bundling modules for lazy loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T090126Z" creationid="shibukawa.yoshiki" creationdate="20170208T090126Z">
        <seg>幸い、遅延ダウンロードを実現するためにモジュールをバンドルする機能を持ったツールはいくつもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, with Mithril, it's possible for developers to attach an identity key to elements so that array operations like shift, splice and sort only affect the minimum amount of elements required, leaving the rest of the DOM elements untouched when a redraw happens.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141643Z" creationid="shibukawa.yoshiki" creationdate="20150413T141643Z">
        <seg>幸い、Mithrilでは、開発が各エレメントに識別子のキーを付与できるため、シフト、スプライス、ソートといった配列操作が行われても、再描画時に最小のエレメントだけを変更し、残りのDOMエレメントは変更されないようにする、といったことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework comparison</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024838Z" creationid="shibukawa.yoshiki" creationdate="20170131T024838Z">
        <seg>フレームワークの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the get-go, Mithril's build system produces archived versions of the code and documentation so that you'll never be stuck without docs for out-of-date versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114752Z" creationid="shibukawa.yoshiki" creationdate="20150417T114752Z">
        <seg>Mithrilのビルドシステムは、過去のバージョンのコードとドキュメントをすべてアーカイブします。過去のバージョンの情報がなくて困ることもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functional / relational tools</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143354Z" creationid="shibukawa.yoshiki" creationdate="20160412T143354Z">
        <seg>関数型 / リレーショナル関連のツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getter-setters are JSON-serializable:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135617Z" creationid="shibukawa.yoshiki" creationdate="20150414T135617Z">
        <seg>getter-setterはJSONにシリアライズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getter-setters work like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150526Z" creationid="shibukawa.yoshiki" creationdate="20150407T150526Z">
        <seg>getter-setterは次のように動作します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting Started</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140635Z" creationid="shibukawa.yoshiki" creationdate="20150407T140635Z">
        <seg>はじめよう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting Started - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T045552Z" creationid="shibukawa.yoshiki" creationdate="20150407T140554Z">
        <seg>はじめよう - Mithrilf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting started</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024616Z" creationid="shibukawa.yoshiki" creationdate="20170131T024616Z">
        <seg>はじめよう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given how young Mithril is, hopefully you can appreciate the level of commitment for providing good documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114904Z" creationid="shibukawa.yoshiki" creationdate="20150417T114904Z">
        <seg>Mithrilはまだまだ若いのですが、良いドキュメントを提供することに対してどれだけのコミットメントをしているかを理解してもらえれば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the code above, the replacement class would only need to implement the &lt;c0&gt;.push()&lt;/c0&gt; and &lt;c1&gt;.map()&lt;/c1&gt; methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003616Z" creationid="shibukawa.yoshiki" creationdate="20150409T003616Z">
        <seg>上記のコードの場合は、新しいクラスに必要なメソッド&lt;c0&gt;.push()&lt;/c0&gt;メソッドと&lt;c1&gt;.map()&lt;/c1&gt;メソッドだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the example in the "Defining Routes" section:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013027Z" creationid="shibukawa.yoshiki" creationdate="20150410T013027Z">
        <seg>ラウトの定義のセクションのサンプルですでに使っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to mailing list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135804Z" creationid="shibukawa.yoshiki" creationdate="20150407T135804Z">
        <seg>メーリングリストへ飛ぶ(英語)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good Practices</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141019Z" creationid="shibukawa.yoshiki" creationdate="20150407T141019Z">
        <seg>良いプラクティス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guide</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135500Z" creationid="shibukawa.yoshiki" creationdate="20150407T135500Z">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013413Z" creationid="shibukawa.yoshiki" creationdate="20150417T013413Z">
        <seg>HTML→Mithrilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handlers like &lt;c2&gt;oncreate&lt;/c2&gt; and &lt;c3&gt;onupdate&lt;/c3&gt; fire after the UI has been redrawn.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121626Z" creationid="shibukawa.yoshiki" creationdate="20170206T121626Z">
        <seg>&lt;c2&gt;oncreate&lt;/c2&gt;と&lt;c3&gt;onupdate&lt;/c3&gt;ハンドラはUIが再描画された後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling clicks on anchor tags via the mithril router is similar to &lt;c0&gt;v0.2.x&lt;/c0&gt; but uses a new lifecycle method and API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141527Z" creationid="shibukawa.yoshiki" creationdate="20170131T141527Z">
        <seg>アンカータグのクリックをハンドリングしてMithrilラウターと一緒に扱う方法は&lt;c0&gt;v0.2.x&lt;/c0&gt;と似ていますが、新しいライフサイクルメソッドとAPIを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Headers to append to the request before sending it (applied right before &lt;c0&gt;options.config&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070449Z" creationid="shibukawa.yoshiki" creationdate="20170219T070449Z">
        <seg>送信前に追加されるヘッダーです。&lt;c0&gt;options.config&lt;/c0&gt;の直前に付与が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are examples for the most commonly used methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111951Z" creationid="shibukawa.yoshiki" creationdate="20170206T111951Z">
        <seg>次のサンプルはもっとも頻繁に使われるメソッドのサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some examples of Mithril in action</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035745Z" creationid="shibukawa.yoshiki" creationdate="20170131T035745Z">
        <seg>実践的なMithrilのサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the highlights of the template above:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153647Z" creationid="shibukawa.yoshiki" creationdate="20150408T153647Z">
        <seg>このテンプレートの大事なポイントを個別に説明していきます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we specify two routes: &lt;c0&gt;/&lt;/c0&gt; and &lt;c1&gt;/page1&lt;/c1&gt;, which render their respective components when the user navigates to each URL.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T101146Z" creationid="shibukawa.yoshiki" creationdate="20170207T101146Z">
        <seg>このコードでは2つのラウト、&lt;c0&gt;/&lt;/c0&gt;、&lt;c1&gt;/page1&lt;/c1&gt;を定義しています。ユーザーがそれぞれのURLを訪れたら、それぞれ適切なコンポーネントをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we've moved &lt;c0&gt;Contact.save(contact).then(Observable.trigger("updateContact"))&lt;/c0&gt; out of the &lt;c1&gt;ContactForm&lt;/c1&gt; component and into the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T115347Z" creationid="shibukawa.yoshiki" creationdate="20160101T115347Z">
        <seg>このコードでは、&lt;c0&gt;Contact.save(contact).then(Observable.trigger("updateContact"))&lt;/c0&gt;を&lt;c1&gt;ContactForm&lt;/c1&gt;コンポーネントの中から、モデルレイヤの中に移動しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a less trivial example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002409Z" creationid="shibukawa.yoshiki" creationdate="20150413T002409Z">
        <seg>ちょっと応用的なサンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a refactored version of the sample app above to illustrate:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013615Z" creationid="shibukawa.yoshiki" creationdate="20150502T013615Z">
        <seg>以下のコードは上記のコードをリファクタリングしたものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of a more aggressive refactor:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015627Z" creationid="shibukawa.yoshiki" creationdate="20150413T015627Z">
        <seg>もっとアグレッシブなリファクタリングを行うとこうなります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of a not-so-trivial component: a drag-n-drop file uploader.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031830Z" creationid="shibukawa.yoshiki" creationdate="20150502T031802Z">
        <seg>１つ面白いサンプルを紹介します。ドラッグ・アンド・ドロップでファイルをアップロードするコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example using &lt;a0&gt;webpack's code splitting system&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T090222Z" creationid="shibukawa.yoshiki" creationdate="20170208T090151Z">
        <seg>ここでは、&lt;a0&gt;WebPackのコード分割システム&lt;/a0&gt;を使ってみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example using the &lt;a0&gt;Q&lt;/a0&gt; promise library:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135433Z" creationid="shibukawa.yoshiki" creationdate="20150414T135433Z">
        <seg>&lt;a0&gt;Q&lt;/a0&gt;というpromiseライブラリを使うサンプルがこちらです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an expanded version of the example above that implements a loading indicator and an error message:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T144449Z" creationid="shibukawa.yoshiki" creationdate="20170219T144449Z">
        <seg>次のコードは前述のサンプルに、ローディングのインジケーターと、エラーメッセージを追加したサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an illustrative example of a component that uses &lt;c0&gt;m.request&lt;/c0&gt; to retrieve some data from a server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T142710Z" creationid="shibukawa.yoshiki" creationdate="20170219T142710Z">
        <seg>次のコードは&lt;c0&gt;m.request&lt;/c0&gt;を使ってサーバーからデータを取得してくるコンポーネントのサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one last, but relevant variation of the pattern above.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031135Z" creationid="shibukawa.yoshiki" creationdate="20150502T031135Z">
        <seg>次は最後のパターンです。上記で説明したものの変形バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one way to implement cross-communication between single purpose components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015605Z" creationid="shibukawa.yoshiki" creationdate="20150502T015605Z">
        <seg>以下のコードは、上記の単一機能を提供するコンポーネント間のコミュニケーションを提供する方法です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's the application code in its entirety:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162102Z" creationid="shibukawa.yoshiki" creationdate="20150408T162102Z">
        <seg>完全なアプリケーションのコードはこちらになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's the code above as a component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030551Z" creationid="shibukawa.yoshiki" creationdate="20170131T030551Z">
        <seg>上記のコードをコンポーネント化してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's the most basic way of implementing the view-to-model part of the binding:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021122Z" creationid="shibukawa.yoshiki" creationdate="20150408T020244Z">
        <seg>次のコードが、ビューからモデルへのバインディングを行う、最小限の実装になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;c0&gt;Data.todos.list&lt;/c0&gt; is &lt;c1&gt;null&lt;/c1&gt; at the beginning.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T144627Z" creationid="shibukawa.yoshiki" creationdate="20170219T144627Z">
        <seg>まず、&lt;c0&gt;Data.todos.list&lt;/c0&gt;の初期値が&lt;c1&gt;null&lt;/c1&gt;になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the data fetching is still centralized in the top-level component, so that we can avoid duplicate AJAX requests when fetching data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T030721Z" creationid="shibukawa.yoshiki" creationdate="20150502T030721Z">
        <seg>この場合データの取得コードはトップレーベルモジュールに集約されています。これによりAJAXリクエストを何度も行うことを避けられるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we've defined a class called &lt;c0&gt;Contact&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224039Z" creationid="shibukawa.yoshiki" creationdate="20150501T224023Z">
        <seg>&lt;c0&gt;Contact&lt;/c0&gt;(連絡先)クラスを定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical MVC via components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133844Z" creationid="shibukawa.yoshiki" creationdate="20150407T133844Z">
        <seg>コンポーネントによる階層型MVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154247Z" creationid="shibukawa.yoshiki" creationdate="20150412T154247Z">
        <seg>履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History state</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061455Z" creationid="shibukawa.yoshiki" creationdate="20170208T061455Z">
        <seg>ヒストリー状態</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hopefully by now, you're starting to see why Mithril encourages the usage of &lt;c0&gt;m.prop&lt;/c0&gt;: Because Mithril getter-setters are functions, they naturally compose well with functional programming tools, and allow for some very powerful idioms.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152126Z" creationid="shibukawa.yoshiki" creationdate="20150408T152126Z">
        <seg>これまでの説明の中で、なぜMithrilが&lt;c0&gt;m.prop&lt;/c0&gt;を使うことを推奨しているのか、お気づきの方もいると思います。Mithrilのgetter-setterは関数です。それにより、関数型プログラミングの道具と、相性良く組みわせることができて、強力な書き方が使えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hopefully these examples give you an idea of ways requirements can change over time and how Mithril's philosophy allows developers to use standard OOP techniques to refactor their codebases, rather than needing to modify large portions of the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T012924Z" creationid="shibukawa.yoshiki" creationdate="20150409T012924Z">
        <seg>要件は時間とともに変化しますが、これらの例から、Mithrilがどのような哲学を持って、開発者がコードベースをリファクタリングする際に、どのように標準的なオブジェクト指向プログラミングのテクニックを使って欲しいと思っているか、アプリケーションを大きな塊にしないで小さくして欲しいと考えているのかが伝われば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Should Code Be Organized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110751Z" creationid="shibukawa.yoshiki" creationdate="20150420T110751Z">
        <seg>推奨されるコード構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Should Code Be Organized - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110757Z" creationid="shibukawa.yoshiki" creationdate="20150420T110706Z">
        <seg>推奨されるコード構成 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How auto-redrawing works</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152913Z" creationid="shibukawa.yoshiki" creationdate="20150416T152913Z">
        <seg>どのように再描画が行われるか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015649Z" creationid="shibukawa.yoshiki" creationdate="20150417T015649Z">
        <seg>Mithrilと他のフレームワークの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015419Z" creationid="shibukawa.yoshiki" creationdate="20150417T015419Z">
        <seg>Mithrilと他のフレームワークの違い - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How it works</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133233Z" creationid="shibukawa.yoshiki" creationdate="20170206T133233Z">
        <seg>どのように動作するのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to contribute</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024822Z" creationid="shibukawa.yoshiki" creationdate="20170131T024822Z">
        <seg>貢献の仕方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to read signatures</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150434Z" creationid="shibukawa.yoshiki" creationdate="20150413T150434Z">
        <seg>シグニチャの読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as I mentioned before, you can enable an &lt;a1&gt;auto-redrawing system&lt;/a1&gt;, by initializing the &lt;c2&gt;todo&lt;/c2&gt; component via &lt;c3&gt;m.mount&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041650Z" creationid="shibukawa.yoshiki" creationdate="20150502T041650Z">
        <seg>しかし、前に説明したとおり、&lt;c3&gt;m.mount&lt;/c3&gt;を通じて&lt;c2&gt;todo&lt;/c2&gt;コンポーネントを初期化すると、&lt;a1&gt;自動再描画システム&lt;/a1&gt;が有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as the performance tests in the homepage show, this does not necessarily hurt Mithril in a meaningful way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015016Z" creationid="shibukawa.yoshiki" creationdate="20150420T015016Z">
        <seg>しかし、ホームページのパフォーマンス比較が示す通り、Mithrilではこの両方を達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, bindings can be implemented easily:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014119Z" creationid="shibukawa.yoshiki" creationdate="20150413T014119Z">
        <seg>しかし、簡単に実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's important to always write conditional tests in templates to account for the possibility of nullables, because redraws may come to occur more aggressively than data is available (perhaps because a newly introduced 3rd party library calls &lt;c0&gt;m.redraw&lt;/c0&gt;, or because you might want a more aggressive redraw policy to implement a specific feature down the road).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T120834Z" creationid="shibukawa.yoshiki" creationdate="20150502T120834Z">
        <seg>しかし、テンプレート内でnullになりえる可能性がある場合は常にチェックコードを書くことが大切です。新しく導入したサードパーティライブラリが&lt;c0&gt;m.redraw&lt;/c0&gt;を呼び出す可能性がありますし、何かしらの機能を実装する時に積極的な再描画を行う必要が出てくる可能性があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's recommended that you aggregate all of your requests in a single place instead of scattering them across multiple components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084713Z" creationid="shibukawa.yoshiki" creationdate="20150502T084713Z">
        <seg>しかし、複数のコンポーネントに散らばっている複数のリクエストは一箇所にあつめるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's relatively common for a developer to want to synchronize the recreation of the component to the route change event.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054939Z" creationid="shibukawa.yoshiki" creationdate="20170208T054939Z">
        <seg>しかし、0.2.Xのように、ラウト変更イベントに対して、同期的なコンポーネントの再生成を行って欲しいという需要も、開発者の中では比較的一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, note that because the top level component is an anonymous component, jumping from the &lt;c0&gt;/&lt;/c0&gt; route to the &lt;c1&gt;/form&lt;/c1&gt; route (or vice-versa) will tear down the anonymous component and recreate the DOM from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T071121Z" creationid="shibukawa.yoshiki" creationdate="20170208T071121Z">
        <seg>しかし、トップレベルコンポーネントが無名コンポーネントだと、&lt;c0&gt;/&lt;/c0&gt;から&lt;c1&gt;/form&lt;/c1&gt;などのラウトに遷移した時に、無名コンポーネント一度破棄されて、ゼロから再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, realistically, in order for that to work on a production scale, it would be necessary to bundle all of the dependencies for the &lt;c0&gt;Home.js&lt;/c0&gt; module into the file that is ultimately served by the server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T090056Z" creationid="shibukawa.yoshiki" creationdate="20170208T090056Z">
        <seg>しかし、現実的にこの手法をプロダクションレベルで実現するには&lt;c0&gt;Home.js&lt;/c0&gt;に必要なモジュールを、サーバーから返されるファイルにすべてバンドルする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes we do want to be able to redraw before a web service request completes, either because one web service out of many is slow, or because we don't need its response in order to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000147Z" creationid="shibukawa.yoshiki" creationdate="20150415T000147Z">
        <seg>しかし、時々ウェブサービスのリクエストが完了する前に再描画を行いたいと思うことがあります。多くのウェブサービスに並行でアクセスして、アクセスが遅いのがその中の１つだけだったり、もしくは再描画するのにレスポンスがいらない、といったこともありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this mode does not support named anchors and browser history lists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005228Z" creationid="shibukawa.yoshiki" creationdate="20150410T005228Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなりますし、ブラウザの履歴のリストがサポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this mode does not support named anchors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170041Z" creationid="shibukawa.yoshiki" creationdate="20150414T170041Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using &lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt; is only recommended if you want to use Mithril as part of a larger framework that manages the rendering lifecycle on its own.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100251Z" creationid="shibukawa.yoshiki" creationdate="20150502T100218Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt;を使用するのは、他のフレームワークを利用していて、描画の管理はそのシステムに従う場合にのみにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using its entire toolset idiomatically can bring lots of benefits: learning to use functional programming in real world scenarios and solidifying good coding practices for OOP and MVC are just some of them.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142406Z" creationid="shibukawa.yoshiki" creationdate="20150407T142253Z">
        <seg>しかし、このツールセットのレールに乗ることで多くの利益を得ることができます。その中には、実用的なシナリオ上で関数型プログラミングを学んだり、しっかりとしたオブジェクト指向プログラミングやMVCの良いコーディングプラクティスを学ぶことも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hybrid architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180200Z" creationid="shibukawa.yoshiki" creationdate="20150501T180200Z">
        <seg>ハイブリッドアーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hyperscript is the most idiomatic way of writing Mithril views, but &lt;a0&gt;JSX is another popular alternative that you could explore&lt;/a0&gt; once you're more comfortable with the basics:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T123449Z" creationid="shibukawa.yoshiki" creationdate="20170220T123449Z">
        <seg>HyperscriptはMithrilのビューを作成するもっとも一般的な手法ですが、基本的な書き方に慣れてきた後に使う&lt;a0&gt;代替手法として人気のあるJSX&lt;/a0&gt;にも挑戦してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hyperscript offers a terse syntax that can be indented more naturally than HTML for complex tags, and in addition, since its syntax is simply Javascript, it's possible to leverage a lot of Javascript tooling ecosystem: for example &lt;a1&gt;Babel&lt;/a1&gt;, &lt;a2&gt;JSX&lt;/a2&gt; (inline-HTML syntax extension), &lt;a3&gt;eslint&lt;/a3&gt; (linting), &lt;a4&gt;uglifyjs&lt;/a4&gt; (minification), &lt;a5&gt;istanbul&lt;/a5&gt; (code coverage), &lt;a6&gt;flow&lt;/a6&gt; (static type analysis), etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T122125Z" creationid="shibukawa.yoshiki" creationdate="20170220T122125Z">
        <seg>Hyperscriptは、複雑なタグのHTMLよりも自然に字下げできる簡潔な構文を提供します。また、その構文は単純にJavascriptなので、Javascriptツールのエコシステムを多く活用することができます。例えばBabel、JSX（インラインHTML構文拡張 ）、eslint（linting）、uglifyjs（minification）、istanbul（コードカバレッジ）、flow（静的型分析）など。

Hyperscriptを使うと、複雑なタグを持つHTMLよりも自然にインデントできる、完結な構文でテンプレートが記述できます。それに加えて、&lt;a1&gt;Babel&lt;/a1&gt;, &lt;a2&gt;JSX&lt;/a2&gt; (インラインのHTML文法拡張), &lt;a3&gt;eslint&lt;/a3&gt; (構文チェック), &lt;a4&gt;uglifyjs&lt;/a4&gt; (コードサイズ縮小化), &lt;a5&gt;istanbul&lt;/a5&gt; (コードカバレッジ), &lt;a6&gt;flow&lt;/a6&gt; (静的な型解析) などのさまざまなJavaScriptのツールを活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IE also allows running of Javascript via CSS behaviors in &lt;c0&gt;&lt;link&gt;&lt;/c0&gt;/&lt;c1&gt;&lt;style&gt;&lt;/c1&gt; tags and &lt;c2&gt;style&lt;/c2&gt; attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014743Z" creationid="shibukawa.yoshiki" creationdate="20150416T014743Z">
        <seg>IEはCSSの処理の中でのJavaScriptの実行を認めています。&lt;c0&gt;&lt;link&gt;&lt;/c0&gt;/&lt;c1&gt;&lt;style&gt;&lt;/c1&gt; タグと、&lt;c2&gt;style&lt;/c2&gt;属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IE7 and lower do not support cross-domain AJAX requests.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015040Z" creationid="shibukawa.yoshiki" creationdate="20150417T015040Z">
        <seg>IE7以下のブラウザは、クロスドメインのAJAXリクエストをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IMPORTANT NOTE: Due to some unfortunate factors, 0.2.1 is not a stable release.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135636Z" creationid="shibukawa.yoshiki" creationdate="20160412T135636Z">
        <seg>重要なメモ: 不幸なリファクタリングにより、0.2.1は安定バージョンではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, temperature conversion functions (and any functions that deal strictly within the domain of the data) should go in the model layer, not in a component's controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081933Z" creationid="shibukawa.yoshiki" creationdate="20150502T081933Z">
        <seg>理想的には温度変換処理や、データの領域で行われるその他の処理はコンポーネントのコントローラではなく、モデルレイヤーに移動すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idiomatic Mithril code is meant to apply good programming conventions and be easy to refactor.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234007Z" creationid="shibukawa.yoshiki" creationdate="20150408T234007Z">
        <seg>Mithril風のコードとは、良いプログラミングの規約に従っていて、リファクタリングしやすいコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;false&lt;/c0&gt;, redraws mounted components upon completion of the request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075917Z" creationid="shibukawa.yoshiki" creationdate="20170219T075917Z">
        <seg>このパラメータを&lt;c0&gt;false&lt;/c0&gt;にすると、リクエスト完了時にマウントされているコンポーネントを再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;onmatch&lt;/c0&gt; returns a component or a promise that resolves to a component, this component is used as the &lt;c1&gt;vnode.tag&lt;/c1&gt; for the first argument in the RouteResolver's &lt;c2&gt;render&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090410Z" creationid="shibukawa.yoshiki" creationdate="20170207T090410Z">
        <seg>もし&lt;c0&gt;onmatch&lt;/c0&gt;がコンポーネント、あるいはコンポーネントを解決するPromiseを返すと、このコンポーネントはラウトリゾルバーの &lt;c2&gt;render&lt;/c2&gt; メソッドの最初の引数の&lt;c1&gt;vnode.tag&lt;/c1&gt;として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;onmatch&lt;/c0&gt; returns a promise that gets rejected, the router redirects back to &lt;c1&gt;defaultRoute&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090553Z" creationid="shibukawa.yoshiki" creationdate="20170207T090553Z">
        <seg>&lt;c0&gt;onmatch&lt;/c0&gt;がPromiseを返し、それがrジジェクとされたら、ラウターのラウトは&lt;c1&gt;defaultRoute&lt;/c1&gt;に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;path&lt;/c0&gt; has routing parameter slots, the properties of this object are interpolated into the path string</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080649Z" creationid="shibukawa.yoshiki" creationdate="20170207T080649Z">
        <seg>もし&lt;c0&gt;path&lt;/c0&gt;はラウとのパラメータスロットを持っている時は、このオブジェクトのプロパティがパス文字列のパラメータ部として利用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c1&gt;true&lt;/c1&gt;, it does not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075927Z" creationid="shibukawa.yoshiki" creationdate="20170219T075927Z">
        <seg>&lt;c1&gt;true&lt;/c1&gt;の場合は再描画を行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If NPM is installed correctly, a file &lt;c0&gt;package.json&lt;/c0&gt; will be created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071426Z" creationid="shibukawa.yoshiki" creationdate="20170207T071426Z">
        <seg>npmが正しくインストールされていれば、&lt;c0&gt;package.json&lt;/c0&gt;が作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component A contains another component B that calls asynchronous services, when component A is rendered, a &lt;c0&gt;&lt;placeholder&gt;&lt;/c0&gt; tag is rendered in place of component B until B's asynchronous services resolve.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094529Z" creationid="shibukawa.yoshiki" creationdate="20150502T094529Z">
        <seg>もし、コンポーネントAが、非同期処理を行う他のコンポーネントBを含んでいて、Bの非同期タスクが完了する前であれば、描画時に&lt;placeholder&gt;&lt;/c0&gt;タグがレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's controller contains the function &lt;c0&gt;onunload&lt;/c0&gt;, it will be called under one of these circumstances:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090938Z" creationid="shibukawa.yoshiki" creationdate="20150502T090938Z">
        <seg>コンポーネントのコントローラが&lt;c0&gt;onunload&lt;/c0&gt;関数を持っていた場合は、以下の状況のどれかに当てはまった時に呼ばれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's controller implements an instance method called &lt;c0&gt;onunload&lt;/c0&gt;, this method will be called when a route changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135316Z" creationid="shibukawa.yoshiki" creationdate="20150502T135310Z">
        <seg>コンポーネントのコントローラが&lt;c0&gt;onunload&lt;/c0&gt;インスタンスメソッドを定義している場合、ラウトが変更されるとこのメソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's root element is a subtree directive on its first rendering pass, undefined behavior will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100058Z" creationid="shibukawa.yoshiki" creationdate="20150502T100058Z">
        <seg>初回レンダリング時に、コンポーネントのルートのエレメントがサブツリーディレクティブを返した場合は未定義の動作になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a controller is not specified, Mithril will automatically create an empty controller function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T144943Z" creationid="shibukawa.yoshiki" creationdate="20160412T144943Z">
        <seg>もしコントローラが指定されなければ、Mithrilは自動的に空のコントローラ関数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a custom &lt;c4&gt;extract&lt;/c4&gt; callback is set, &lt;c5&gt;options.deserialize&lt;/c5&gt; is ignored and the string returned from the extract callback will not automatically be parsed as JSON.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T075012Z" creationid="shibukawa.yoshiki" creationdate="20170219T075012Z">
        <seg>もし、カスタムの&lt;c4&gt;extract&lt;/c4&gt;コールバックがセットされると、&lt;c5&gt;options.deserialize&lt;/c5&gt;は無視されます。extractコールバックが返す文字列は自動でJSONにパースされなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a method is not listed below, it's meant for advanced usage.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T112015Z" creationid="shibukawa.yoshiki" creationdate="20170206T112015Z">
        <seg>ここに書かれていないメソッドは上級向けです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a promise is passed into &lt;c0&gt;m.prop()&lt;/c0&gt;, a Mithril promise is returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135230Z" creationid="shibukawa.yoshiki" creationdate="20150414T135230Z">
        <seg>promiseが&lt;c0&gt;m.prop()&lt;/c0&gt;Mithrilのpromiseが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a user picks a file, the &lt;c0&gt;onchange&lt;/c0&gt; event is triggered, which calls the &lt;c1&gt;upload&lt;/c1&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155447Z" creationid="shibukawa.yoshiki" creationdate="20170219T155447Z">
        <seg>ユーザーがファイルを選択すると、&lt;c0&gt;onchange&lt;/c0&gt;イベントが起動し、&lt;c1&gt;upload&lt;/c1&gt;関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a vnode is strictly equal to the vnode occupying its place in the last draw, v1.x will skip that part of the tree without checking for mutations or triggering any lifecycle methods in the subtree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T051201Z" creationid="shibukawa.yoshiki" creationdate="20170201T051201Z">
        <seg>もしvnodeが前回の描画時のものと厳格に一致していたときは、v1.xはその部分のサブツリーのチェックや、ライフサイクルメソッドの呼び出しをスキップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an attribute has the same name in Javascript and in HTML, then Mithril assumes you're setting the Javascript property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T012442Z" creationid="shibukawa.yoshiki" creationdate="20150413T012442Z">
        <seg>JavaScriptとHTMLで同じ名前の属性があった場合は、MithrilはJavaScript側の属性を優先します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If another request finishes after the last fired request, the widget would display less relevant (or potentially wrong) data than if the last fired request finished last.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155024Z" creationid="shibukawa.yoshiki" creationdate="20170219T155024Z">
        <seg>もし、最後に実行したリクエストよりも後に他のリクエストが完了すると、本来よりも精度が低い（場合によっては間違った）データが表示されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If available the DOM-Element of the vnode can be accessed at &lt;c0&gt;vnode.dom&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035518Z" creationid="shibukawa.yoshiki" creationdate="20170131T035518Z">
        <seg>もしDOMエレメントにアクセス可能であれば、&lt;c0&gt;vnode.dom&lt;/c0&gt;プロパティを使って参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If build fails, abort</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054528Z" creationid="shibukawa.yoshiki" creationdate="20170220T054528Z">
        <seg>もしビルドが失敗ｓたら中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If calls are more expensive than a repaint window, the browser may drop frames, resulting in choppy animations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020504Z" creationid="shibukawa.yoshiki" creationdate="20150421T020504Z">
        <seg>もし、このメソッドの呼び出しコストがウィンドウの再描画よりも重くなると、フレーム落ちが発生して、アニメーションがなめらかに実行されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If defined, the &lt;c1&gt;xhr&lt;/c1&gt; parameter is the XMLHttpRequest instance used for the request, and &lt;c2&gt;options&lt;/c2&gt; is the object that was passed to the &lt;c3&gt;m.request&lt;/c3&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074734Z" creationid="shibukawa.yoshiki" creationdate="20170219T074734Z">
        <seg>もしこれが定義されると、リクエストに使ったXMLHttpRequestインスタンスが&lt;c1&gt;xhr&lt;/c1&gt;パラメータとして、&lt;c3&gt;m.request&lt;/c3&gt;呼び出し時に渡したオブジェクトが&lt;c2&gt;options&lt;/c2&gt;として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If doing such operations, the final string needs to be flagged as trusted.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015721Z" creationid="shibukawa.yoshiki" creationdate="20150416T015721Z">
        <seg>このような操作を行う場合には、最終的な文字列に対してこの関数を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a &lt;a0&gt;component&lt;/a0&gt;, the component will be instantiated and managed internally by Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T134843Z" creationid="shibukawa.yoshiki" creationdate="20160101T134843Z">
        <seg>もしこれが&lt;a0&gt;component&lt;/a0&gt;だった場合は、コンポーネントはインスタンス化され、Mithrilによって内部で管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a SubtreeDirective with the value "retain", it will retain the existing DOM tree in place, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160432Z" creationid="shibukawa.yoshiki" creationdate="20150413T160432Z">
        <seg>SubtreeDirectiveの値が"retain"だった場合は、もしあれば既存のDOMツリーをその場で保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a VirtualElement, it will be rendered as a DOM Element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155613Z" creationid="shibukawa.yoshiki" creationdate="20150413T155613Z">
        <seg>もし仮想エレメントが指定された場合には、DOMエレメントとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the &lt;c0&gt;root&lt;/c0&gt; element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124825Z" creationid="shibukawa.yoshiki" creationdate="20150416T124825Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、&lt;c0&gt;root&lt;/c0&gt;エレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the element being created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160227Z" creationid="shibukawa.yoshiki" creationdate="20150413T160227Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、生成されたエレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not provided, return the current internally stored value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135923Z" creationid="shibukawa.yoshiki" creationdate="20150414T135923Z">
        <seg>もし渡されなければ、現在の内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not provided, the value of the getter-setter's internal store defaults to &lt;c0&gt;undefined&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135745Z" creationid="shibukawa.yoshiki" creationdate="20150414T135745Z">
        <seg>もし初期値が与えられなければ、getter-setterの内部ストアのデフォルト値は&lt;c0&gt;undefined&lt;/c0&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If onmatch does not return a component or a promise that resolves to a component, the vnode's &lt;c1&gt;tag&lt;/c1&gt; field defaults to &lt;c2&gt;"div"&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T091124Z" creationid="shibukawa.yoshiki" creationdate="20170207T091044Z">
        <seg>もしonmatchがコンポーネントも、コンポーネントを返すPromiseも返さなかった時は、&lt;c1&gt;tag&lt;/c1&gt;　フィールドは&lt;c2&gt;"div"&lt;/c2&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If present, it's equivalent to having the options &lt;c0&gt;{method: "GET", url: url}&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T063141Z" creationid="shibukawa.yoshiki" creationdate="20170219T063141Z">
        <seg>これが存在していたら、&lt;c0&gt;{method: "GET", url: url}&lt;/c0&gt;というオプションと等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If provided, it updates the getter-setter's internal store to the provided value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135908Z" creationid="shibukawa.yoshiki" creationdate="20150414T135908Z">
        <seg>もし引数が渡された場合には、getter-setterの内部ストアの値を、渡された値に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, forces the redraw to be synchronous.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151738Z" creationid="shibukawa.yoshiki" creationdate="20150416T151738Z">
        <seg>もしこれがtrueに設定されると、同期的に再描画を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, rendering a new virtual tree will completely overwrite an existing one without attempting to diff against it</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124954Z" creationid="shibukawa.yoshiki" creationdate="20150416T124954Z">
        <seg>もしこれがtrueに設定されると、差分検知せずに新しい仮想ツリーの完全なレンダリングが行われます。st it</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, replaces the current history entry, instead of adding a new one.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171606Z" creationid="shibukawa.yoshiki" creationdate="20150414T171606Z">
        <seg>もしこのパラメータがtrueに設定されると、新しいページを追加するのではなく、現在のヒストリのエントリーを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;context&lt;/c0&gt; object that is passed to a &lt;c1&gt;config&lt;/c1&gt; function has a property called &lt;c2&gt;onunload&lt;/c2&gt;, this function will be called when the element gets detached from the document by Mithril's diff engine.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130246Z" creationid="shibukawa.yoshiki" creationdate="20150413T130246Z">
        <seg>&lt;c1&gt;config&lt;/c1&gt;関数に渡される&lt;c0&gt;context&lt;/c0&gt;オブジェクトには、&lt;c2&gt;onunload&lt;/c2&gt;と呼ばれるプロパティがあります。この関数は、Mithirilの差分検出エンジンによって対象のエレメントがドキュメントから切り離される時に呼ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c2&gt;controller&lt;/c2&gt; is omitted, Mithril will provide one, pointing to an empty function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142918Z" creationid="shibukawa.yoshiki" creationdate="20160412T142918Z">
        <seg>もしコントローラが省略されると、Mithrilは自動的に空のコントローラ関数を補完します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Layout component had &lt;a2&gt;lifecycle methods&lt;/a2&gt; defined, the &lt;c3&gt;oninit&lt;/c3&gt; and &lt;c4&gt;oncreate&lt;/c4&gt; hooks would fire on every route change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T071821Z" creationid="shibukawa.yoshiki" creationdate="20170208T071821Z">
        <seg>もしレイアウトコンポーネントが&lt;a2&gt;ライフサイクルメソッド&lt;/a2&gt;を持っていたとすると、ラウトの変更のたびに&lt;c3&gt;oninit&lt;/c3&gt;と&lt;c4&gt;oncreate&lt;/c4&gt;フックが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the URL is not in the same domain as the application, the target server must be configured to accept cross-domain requests from the application's domain, i.e. its responses must include the header &lt;c0&gt;Access-Control-Allow-Origin: *&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002310Z" creationid="shibukawa.yoshiki" creationdate="20150415T002310Z">
        <seg>もしURLが違うドメインであれば、対象となるサーバは &lt;c0&gt;Access-Control-Allow-Origin: *&lt;/c0&gt;ヘッダを付与するなど、クロスドメインのリクエストを許可する設定になっている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the controller doesn't already have a success callback to run after a request resolves, you can still bind errors like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125324Z" creationid="shibukawa.yoshiki" creationdate="20150410T125324Z">
        <seg>もしコントローラが、サーバアクセスが成功した時に実行すべき処理がない場合でも、次のように書くことでエラー処理のバインドが行えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current page URL matches a route, its respective component is activated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135805Z" creationid="shibukawa.yoshiki" creationdate="20150502T135805Z">
        <seg>現在のページのURLが、設定されたラウトにマッチした場合には、対応するコンポーネントがアクティブになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the currently active route is &lt;c0&gt;/dashboard/:userID&lt;/c0&gt; and the current URL is &lt;c1&gt;/dashboard/johndoe&lt;/c1&gt;, then calling &lt;c2&gt;m.route.param("userID")&lt;/c2&gt; returns &lt;c3&gt;"johndoe"&lt;/c3&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170711Z" creationid="shibukawa.yoshiki" creationdate="20150414T170711Z">
        <seg>もし、現在アクティブなラウトが&lt;c0&gt;/dashboard/:userID&lt;/c0&gt;で、現在のURLが&lt;c1&gt;/dashboard/johndoe&lt;/c1&gt;だとすると、&lt;c2&gt;m.route.param("userID")&lt;/c2&gt;は&lt;c3&gt;"johndoe"&lt;/c3&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first argument to &lt;c0&gt;m()&lt;/c0&gt; is a component, it acts as an alias of &lt;c1&gt;m.component()&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T144631Z" creationid="shibukawa.yoshiki" creationdate="20160101T133847Z">
        <seg>もし、&lt;c0&gt;m()&lt;/c0&gt;の最初の引数がコンポーネントであれば、&lt;c1&gt;m.component()&lt;/c1&gt;の代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is run more than once with the same root element, it diffs the new tree against the existing one and intelligently modifies only the portions that have changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020105Z" creationid="shibukawa.yoshiki" creationdate="20150416T020105Z">
        <seg>もしこのメソッドが、同じルートエレメントに対して2回以上呼ばれた場合には、このメソッドは新しいツリーと既存のツリーの差分を取り、変更のあった箇所だけ賢く更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the response returned a single object, that object would be used as the &lt;c3&gt;data&lt;/c3&gt; argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004441Z" creationid="shibukawa.yoshiki" creationdate="20170220T004441Z">
        <seg>もしレスポンスが配列ではなくてオブジェクトだった時も、このオブジェクトを&lt;c3&gt;data&lt;/c3&gt;引数に渡してインスタンスが1つ作られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the tag selector is omitted, it defaults to &lt;c0&gt;div&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150640Z" creationid="shibukawa.yoshiki" creationdate="20150413T150640Z">
        <seg>もしタグセレクタが省略されると、&lt;c0&gt;div&lt;/c0&gt;がデフォルトで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user picks a file, an upload is initiated, and in the &lt;c0&gt;config&lt;/c0&gt; callback, a &lt;c1&gt;progress&lt;/c1&gt; event handler is registered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T191607Z" creationid="shibukawa.yoshiki" creationdate="20170219T191607Z">
        <seg>ユーザーがファイルを選択すると、&lt;c0&gt;config&lt;/c0&gt;コールバック内でアップロードが初期化されます。&lt;c1&gt;progress&lt;/c1&gt;イベントハンドラが登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this argument is a string, it will be rendered as a text node.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155516Z" creationid="shibukawa.yoshiki" creationdate="20150413T155516Z">
        <seg>この属性が文字列の場合は、テキストノードとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this function returns undefined, then it passes the &lt;c0&gt;value&lt;/c0&gt; argument to the next step in the thenable queue, if any</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T051003Z" creationid="shibukawa.yoshiki" creationdate="20160423T051003Z">
        <seg>もしこの関数がundefinedを返してきたら、値がどんなでものであろうと、&lt;c0&gt;value&lt;/c0&gt;引数がthenableキューの次のキューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this option is set to true, then the request does NOT call &lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; internally, and therefore the completion of the request does not trigger an update of the view, even if data has been changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134319Z" creationid="shibukawa.yoshiki" creationdate="20150502T134319Z">
        <seg>このオプションがtrueであれば、requestメソッドは&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt;を呼びません。そのため、リクエストの完了がビュー更新のトリガーにはならず、データ更新があってもビューが更新されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this parameter is falsy, the default value is a function that returns &lt;c0&gt;xhr.responseText&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013502Z" creationid="shibukawa.yoshiki" creationdate="20150415T013502Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、&lt;c0&gt;xhr.responseText&lt;/c0&gt;を返す関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this parameter is falsy, the deserialized data will not be wrapped.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013825Z" creationid="shibukawa.yoshiki" creationdate="20150415T013825Z">
        <seg>もしこのパラメータがfalxyな値だった時は、デシリアライズされたデータはそのまま渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you already have your HTML written and want to convert it into a Mithril template, you can use the tool below for one-off manual conversion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013549Z" creationid="shibukawa.yoshiki" creationdate="20150417T013549Z">
        <seg>もしすでにHTMLを作成済みで、それをMithirlのテンプレートに変換したい場合は、一度だけマニュアルの変換しかできませんが、下記のツールを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are an experienced developer and want to know how Mithril compares to other frameworks, see the &lt;a0&gt;framework comparison&lt;/a0&gt; page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025238Z" creationid="shibukawa.yoshiki" creationdate="20170131T025238Z">
        <seg>もし、すでにJavaScriptのフレームワークでの開発経験があり、他のフレームワークとなにが違うのかを知りたければ、&lt;a0&gt;フレームワークの比較&lt;/a0&gt;のページを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are developing an asynchronous model-level service and finding that Mithril is not redrawing the view after your code runs, you should consider using &lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; and &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; to integrate with Mithril's auto-redrawing system instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130208Z" creationid="shibukawa.yoshiki" creationdate="20150502T130208Z">
        <seg>もし非同期のモデルレベルのサービスを開発しているとします。コードが実行されていても、Mithrilがビューを更新しないことに気づきました。この場合は、&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt;と&lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt;を呼んで、Mithrilの自動再描画システムと統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are migrating, consider using the &lt;a0&gt;mithril-codemods&lt;/a0&gt; tool to help automate the most straightforward migrations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033704Z" creationid="shibukawa.yoshiki" creationdate="20170131T033704Z">
        <seg>もし移行を考えている時は&lt;a0&gt;mithril-codemods&lt;/a0&gt;の使用を検討してください。このツールはほとんどのシンプルな移行を自動化するツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call this method more often than that, Mithril may ignore calls or defer them to the next browser repaint cycle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020407Z" creationid="shibukawa.yoshiki" creationdate="20150421T020407Z">
        <seg>もしこれよりも早いペースで呼び出すと、Mithrilは関数呼び出しを無視して、次のブラウザの再描画のサイクルまで実行を遅らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do use it, you are responsible for determining what constitutes a scenario where the virtual DOM tree is changed/unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124157Z" creationid="shibukawa.yoshiki" creationdate="20150416T124157Z">
        <seg>この機能を使う場合は、仮想DOMツリーのどこに変更があったか/なかったかについて、開発者が決定する責任を持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find yourself needing to redraw before the browsers normal redraw cycle, you can force a synchronous redraw by passing a boolean &lt;c0&gt;true&lt;/c0&gt; as a parameter to &lt;c1&gt;m.redraw&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151336Z" creationid="shibukawa.yoshiki" creationdate="20150416T151336Z">
        <seg>もしブラウザの通常の再描画サイクルよりも前に再描画を行わせたい場合は、&lt;c1&gt;m.redraw&lt;/c1&gt;のオプションとして&lt;c0&gt;true&lt;/c0&gt;を渡すと、強制的に同期再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a hierarchy of components, you can recursively call &lt;c0&gt;onunload&lt;/c0&gt; on all the components in the tree or use a &lt;a1&gt;pubsub&lt;/a1&gt; library to unload specific components on demand.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020118Z" creationid="shibukawa.yoshiki" creationdate="20150414T020118Z">
        <seg>コンポーネントが階層化されている場合は、階層の中のモジュールのすべての&lt;c0&gt;onunload&lt;/c0&gt;を呼ぶこともできますし、特定のコンポーネントをアンロードするときには&lt;a1&gt;pubsub&lt;/a1&gt;ライブラリを呼ぶこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have an existing application that does use a server-side templating system, and you wish to re-architecture it, first decide whether the effort is feasible at all to begin with.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024206Z" creationid="shibukawa.yoshiki" creationdate="20170220T024206Z">
        <seg>サーバーサイドのテンプレートシステムを使う既存のアプリケーションを作り直す場合は、アーキテクチャを再構築してそのような作業が可能かどうか判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have components inside a sortable list, you should add &lt;c0&gt;key&lt;/c0&gt; attributes to your components to ensure that DOM elements are not recreated from scratch, but merely moved when possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080315Z" creationid="shibukawa.yoshiki" creationdate="20150502T080315Z">
        <seg>もしソート可能なリストの中にコンポーネントを置く場合には、&lt;c0&gt;key&lt;/c0&gt; 属性をコンポーネントに追加して、単なる移動時にDOM要素が再生成されないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to add separate widgets to different places on a same page, you can simply initialize each widget as you would a regular Mithril application (i.e. use &lt;c0&gt;m.render&lt;/c0&gt;, &lt;c1&gt;m.mount&lt;/c1&gt; or &lt;c2&gt;m.route&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045357Z" creationid="shibukawa.yoshiki" creationdate="20150502T045357Z">
        <seg>もし、個別のウィジェットを同じページ内の異なる場所に置きたい場合には、通常のMithrilアプリケーションと同じように、&lt;c0&gt;m.render&lt;/c0&gt;、&lt;c1&gt;m.mount&lt;/c1&gt;、&lt;c2&gt;m.route&lt;/c2&gt;などを使ってそれぞれのウィジェットを初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to change how Mithril performs a redraw, you can change the value of the &lt;c0&gt;m.redraw.strategy&lt;/c0&gt; getter-setter to either &lt;c1&gt;"all"&lt;/c1&gt;, &lt;c2&gt;"diff"&lt;/c2&gt; or &lt;c3&gt;"none"&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130801Z" creationid="shibukawa.yoshiki" creationdate="20150416T130801Z">
        <seg>Mithrilの再描画の実行パターンを変更する必要があれば、&lt;c0&gt;m.redraw.strategy&lt;/c0&gt; getter-setterを、&lt;c1&gt;"all"&lt;/c1&gt;、&lt;c2&gt;"diff"&lt;/c2&gt;、&lt;c3&gt;"none"&lt;/c3&gt;のどれかに設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing automatically, you should consider using &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000610Z" creationid="shibukawa.yoshiki" creationdate="20150506T000610Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;を使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing, you should consider using &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T113931Z" creationid="shibukawa.yoshiki" creationdate="20150502T113931Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;を使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to explicitly trigger a redraw within a lifecycle method, you should call &lt;c0&gt;m.redraw()&lt;/c0&gt;, which will trigger an asynchronous redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121709Z" creationid="shibukawa.yoshiki" creationdate="20170206T121709Z">
        <seg>ライフサイクルメソッド内で再描画を明示的に行う時は&lt;c0&gt;m.redraw()&lt;/c0&gt;を呼びます。この関数は非同期で再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to persist DOM state across route changes, it's recommended that you use the &lt;c2&gt;ctx.retain&lt;/c2&gt; flag instead of &lt;c3&gt;m.redraw.strategy("diff")&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133349Z" creationid="shibukawa.yoshiki" creationdate="20150502T133349Z">
        <seg>ラウト間でDOMの状態を維持する必要があるときは、&lt;c3&gt;m.redraw.strategy("diff")&lt;/c3&gt;ではなく、&lt;c2&gt;ctx.retain&lt;/c2&gt;フラグを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to read DOM values, try to read them all at once, because alternating reading and writing to the DOM causes multiple browser repaints, and repaints are expensive.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151714Z" creationid="shibukawa.yoshiki" creationdate="20150416T151714Z">
        <seg>もしDOMの値を読む必要が出てきた場合は、すべての必要なDOMの値を一度に読むようにしてください。少しずつ読み書きすると、高価なブラウザの再描画が何度も発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to sort lists, or delete items from them, or splice them in any way, you should &lt;a0&gt;use the &lt;c1&gt;key&lt;/c1&gt; attribute&lt;/a0&gt; to maintain referential integrity between the data and the DOM.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020944Z" creationid="shibukawa.yoshiki" creationdate="20150421T020944Z">
        <seg>リストをソートしたり、リストから要素を削除する場合や、スプライスを行う場合は、データとDOM間の参照を維持するために、 &lt;a0&gt;&lt;c1&gt;key&lt;/c1&gt;属性を使用してください&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you see an alert box, ensuring security with that framework is more work for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135415Z" creationid="shibukawa.yoshiki" creationdate="20150407T135415Z">
        <seg>もしアラートボックスが表示された場合には、そのフレームワーク上ではセキュリティを維持するための仕事がたくさんあるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set strategy to &lt;c0&gt;"none"&lt;/c0&gt; but then proceed to trigger a redraw asynchronously, either via &lt;c1&gt;start/endComputation&lt;/c1&gt;, &lt;c2&gt;m.redraw&lt;/c2&gt; or &lt;c3&gt;m.request&lt;/c3&gt;, a redraw &lt;e4&gt;will&lt;/e4&gt; occur, using the &lt;c5&gt;"diff"&lt;/c5&gt; strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152806Z" creationid="shibukawa.yoshiki" creationdate="20150416T150752Z">
        <seg>このメソッドを使って&lt;c0&gt;"none"&lt;/c0&gt;に設定したにもかかわらず、&lt;c1&gt;start/endComputation&lt;/c1&gt;や&lt;c2&gt;m.redraw&lt;/c2&gt;、&lt;c3&gt;m.request&lt;/c3&gt;によって非同期での再描画のトリガーが引かれた場合は、 &lt;c5&gt;"diff"&lt;/c5&gt; 戦略で再描画が&lt;e4&gt;先のフレーム&lt;/e4&gt;で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to a recurring callback (such as &lt;c0&gt;setInterval&lt;/c0&gt; or a web socket event handler) to trigger redraws, you should call &lt;c1&gt;m.startComputation&lt;/c1&gt; at the beginning of the function, not outside of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175327Z" creationid="shibukawa.yoshiki" creationdate="20150501T175327Z">
        <seg>もし、&lt;c0&gt;setInterval&lt;/c0&gt;やウェブソケットのイベントハンドラなど、繰り返し呼ばれるコールバックから再描画を行わせたい場合は、コールバックの外ではなく、コールバック関数の先頭で&lt;c1&gt;m.startComputation&lt;/c1&gt;を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to be able to handle a condition as an error in a promise rejection handler, you can throw an &lt;c0&gt;Error&lt;/c0&gt; from &lt;c1&gt;extract&lt;/c1&gt; to reject the promise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181142Z" creationid="shibukawa.yoshiki" creationdate="20150414T181142Z">
        <seg>もし、promiseのリジェクトハンドラ内でエラー条件のハンドリングを行いたい場合は、&lt;c1&gt;extract&lt;/c1&gt;の中から、promiseのリジェクトに向けて&lt;c0&gt;Error&lt;/c0&gt;を投げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to have multiple elements:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030211Z" creationid="shibukawa.yoshiki" creationdate="20170131T030211Z">
        <seg>複数のエレメントを追加してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to keep a DOM element intact across a route change, you can set the &lt;c1&gt;retain&lt;/c1&gt; flag in the config's context object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130751Z" creationid="shibukawa.yoshiki" creationdate="20150413T130751Z">
        <seg>もし、ラウトの変更前後で、DOMエレメントを破棄せずに残しておきたい場合には、configのコンテキストオブジェクト内の&lt;c1&gt;retain&lt;/c1&gt;フラグを設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to repeatedly redraw the view without necessarily waiting for user input, you should manually call &lt;a1&gt;&lt;c2&gt;m.redraw&lt;/c2&gt;&lt;/a1&gt; within the repeatable context.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193557Z" creationid="shibukawa.yoshiki" creationdate="20150411T193557Z">
        <seg>もし、ユーザの入力を待つことなく、繰り返し再描画を行いたい場合は、繰り返し可能なコンテキストの中で、手動で&lt;a1&gt;&lt;c2&gt;m.redraw&lt;/c2&gt;&lt;/a1&gt;を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to save as many files as possible in the event of a network failure, you should consider uploading each file in a separate request instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T190755Z" creationid="shibukawa.yoshiki" creationdate="20170219T190755Z">
        <seg>ネットワークエラーが発生したときに、ひとつでも多くのファイルを保存したいのであれば、それぞれのファイルを個別音リクエストでアップロードすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use the bleeding edge version, you can &lt;a0&gt;fork the development repository&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000353Z" creationid="shibukawa.yoshiki" creationdate="20150408T000353Z">
        <seg>もし、最先端のバージョンを使いたいのであれば、&lt;a0&gt;開発版のリポジトリをフォーク&lt;/a0&gt;することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to support IE6, you'll need &lt;a0&gt;a shim for it&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015011Z" creationid="shibukawa.yoshiki" creationdate="20150417T015011Z">
        <seg>もしIE6をサポートするには、そのクラスの&lt;a0&gt;シミュレートコード&lt;/a0&gt;が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to use third party asynchronous libraries (for example, &lt;c0&gt;jQuery.ajax&lt;/c0&gt;), you should also consider using &lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt; if you want views to redraw after requests complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135033Z" creationid="shibukawa.yoshiki" creationdate="20150415T135033Z">
        <seg>もし、&lt;c0&gt;jQuery.ajax&lt;/c0&gt;)などのサードパーティの非同期ライブラリと一緒に使って、リクエストの完了時に再描画をさせたい時は&lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt;を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you would prefer to have the Layout component be diffed and maintained intact rather than recreated from scratch, you should instead use a RouteResolver as the root object:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073100Z" creationid="shibukawa.yoshiki" creationdate="20170208T073100Z">
        <seg>Layoutコンポーネントをゼロから再作成するのではなく、そのままの状態で差分更新を有効にしたい場合は、代わりにラウトリゾルバーをルートオブジェクトとして使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're integrating other non-recurring services (e.g. calling setTimeout), you should use &lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020049Z" creationid="shibukawa.yoshiki" creationdate="20150421T020049Z">
        <seg>setTimeoutなどの、繰り返し行われないサービスと統合する場合は、&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt;の方が推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're interested in helping improve Mithril, you're welcome to use the bleeding edge version and report any bugs that you find.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000614Z" creationid="shibukawa.yoshiki" creationdate="20150408T000614Z">
        <seg>もし、Mithrilを改善することに興味があるのであれば、最先端バージョンを使用して、見つけたバグを報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using &lt;a1&gt;Grunt&lt;/a1&gt; to create a build system, you can use NPM to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165958Z" creationid="shibukawa.yoshiki" creationdate="20150407T165842Z">
        <seg>もしすでにNodeJSを使っていていたり、&lt;a1&gt;Grunt&lt;/a1&gt;を使ったビルドシステムを作ろうとしているのであれば、NPMを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using &lt;a2&gt;Grunt&lt;/a2&gt; to create a build system, you can use Bower to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235636Z" creationid="shibukawa.yoshiki" creationdate="20150407T235056Z">
        <seg>もしすでにNodeJSを使っていていたり、&lt;a2&gt;Grunt&lt;/a2&gt;を使ったビルドシステムを作ろうとしているのであれば、Bowerを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using &lt;a2&gt;Grunt&lt;/a2&gt; to create a build system, you can use Component to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235953Z" creationid="shibukawa.yoshiki" creationdate="20150407T235932Z">
        <seg>もしすでにNodeJSを使っていていたり、&lt;a2&gt;Grunt&lt;/a2&gt;を使ったビルドシステムを作ろうとしているのであれば、Componentを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're wondering about performance, it turns out Mithril is very fast at rendering updates, because it only touches the parts of the DOM it absolutely needs to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031707Z" creationid="shibukawa.yoshiki" creationdate="20170131T031707Z">
        <seg>パフォーマンスについて気になる方もいるでしょう。Mithrilは、本当に必要なDOMの部分にしか触れないため、レンダリングの更新時を非常に高速に行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're writing a template for a view, use &lt;c0&gt;m()&lt;/c0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013520Z" creationid="shibukawa.yoshiki" creationdate="20150416T013520Z">
        <seg>もしビューのためにテンプレートを作成しているのであれば、&lt;c0&gt;m()&lt;/c0&gt;を代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've been interested in learning or using Functional Programming in the real world, Mithril provides very pragmatic opportunities to get into it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015625Z" creationid="shibukawa.yoshiki" creationdate="20150409T015613Z">
        <seg>もし関数型プログラミングを学習したり、実世界で使ってみたいと考えているのであれば、Mithrilがとても実践的な場を提供してくれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your exit animation is not running, make sure to attach the &lt;c2&gt;onbeforeremove&lt;/c2&gt; handler as high up the tree as it makes sense to ensure that your animation code is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111300Z" creationid="shibukawa.yoshiki" creationdate="20170206T111300Z">
        <seg>終了アニメーションが実行されない場合は、ツリーの上位の削除される要素に&lt;c2&gt;onbeforeremove&lt;/c2&gt;ハンドラーを移動して、アニメーションが実行されるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignoring the fact that the parseCSV function above doesn't handle a lot of cases that a proper CSV parser would, the code above logs an array of arrays.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005158Z" creationid="shibukawa.yoshiki" creationdate="20170220T005158Z">
        <seg>このparseCSV関数が、適切に実装されたCSVパーサーが行っていることをほぼ行っていない簡易実装であることに目をつぶれば、このを実行すると文字列の配列の配列がログ出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; all interaction w/ the current route happened via &lt;c1&gt;m.route()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141748Z" creationid="shibukawa.yoshiki" creationdate="20170131T141748Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では現在のラウトに関することはすべて&lt;c1&gt;m.route()&lt;/c1&gt;メソッド経由で行っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; components could be created using either &lt;c1&gt;m(component)&lt;/c1&gt; or &lt;c2&gt;m.component(component)&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034838Z" creationid="shibukawa.yoshiki" creationdate="20170131T034838Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、&lt;c1&gt;m(component)&lt;/c1&gt;か&lt;c2&gt;m.component(component)&lt;/c2&gt;のどちらをつかってもコンポーネントを作ることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; mithril provided a single lifecycle method, &lt;c1&gt;config&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034936Z" creationid="shibukawa.yoshiki" creationdate="20170131T034936Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、Mithrilはライフサイクルメソッドとして&lt;c1&gt;config&lt;/c1&gt;だけを提供していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; reading route params was entirely handled through &lt;c1&gt;m.route.param()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T142922Z" creationid="shibukawa.yoshiki" creationdate="20170131T142922Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;ではラウトパラメータの読み込みは&lt;c1&gt;m.route.param()&lt;/c1&gt;を使って行っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; the routing mode could be set by assigning a string of &lt;c1&gt;"pathname"&lt;/c1&gt;, &lt;c2&gt;"hash"&lt;/c2&gt;, or &lt;c3&gt;"search"&lt;/c3&gt; to &lt;c4&gt;m.route.mode&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T140705Z" creationid="shibukawa.yoshiki" creationdate="20170131T140629Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、&lt;c1&gt;"pathname"&lt;/c1&gt;、&lt;c2&gt;"hash"&lt;/c2&gt;、&lt;c3&gt;"search"&lt;/c3&gt;を&lt;c4&gt;m.route.mode&lt;/c4&gt;に設定することでラウティングモードを変更できました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; view functions are passed a reference to the &lt;c1&gt;controller&lt;/c1&gt; instance and (optionally) any options passed to the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T122042Z" creationid="shibukawa.yoshiki" creationdate="20170131T122042Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;ではビュー関数は&lt;c1&gt;controller&lt;/c1&gt;インスタンスの参照と、オプションのコンポーネントの引数を受け取りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt; you could pass components as the second argument of &lt;c1&gt;m()&lt;/c1&gt; w/o any wrapping required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T135656Z" creationid="shibukawa.yoshiki" creationdate="20170131T135656Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、コンポーネントを&lt;c1&gt;m()&lt;/c1&gt;の第二引数に直接渡すことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt;, &lt;c1&gt;m.mount(element, component)&lt;/c1&gt; tolerated &lt;a2&gt;vnodes&lt;/a2&gt; as second arguments instead of &lt;a3&gt;components&lt;/a3&gt; (even though it wasn't documented).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T140350Z" creationid="shibukawa.yoshiki" creationdate="20170131T140350Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、ドキュメントには書かれてませんでしたが、&lt;c1&gt;m.mount(element, component)&lt;/c1&gt;は&lt;a3&gt;components&lt;/a3&gt;の代わりに&lt;a2&gt;vnodes&lt;/a2&gt;を第二引数として渡すことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v0.2.x&lt;/c0&gt;, the &lt;c1&gt;xlink&lt;/c1&gt; namespace was the only supported attribute namespace, and it was supported via special casing behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050355Z" creationid="shibukawa.yoshiki" creationdate="20170201T050355Z">
        <seg>&lt;c0&gt;v0.2.x&lt;/c0&gt;では、&lt;c1&gt;xlink&lt;/c1&gt;名前空間は属性の名前空間として唯一サポートされていて、特別な場合だけサポートしていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v1.x&lt;/c0&gt; there is no more &lt;c1&gt;controller&lt;/c1&gt; property in components, use &lt;c2&gt;oninit&lt;/c2&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121629Z" creationid="shibukawa.yoshiki" creationdate="20170131T121629Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt;のコンポーネントには&lt;c1&gt;controller&lt;/c1&gt;プロパティはありません。代わりに&lt;c2&gt;oninit&lt;/c2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v1.x&lt;/c0&gt;, &lt;c1&gt;m.prop()&lt;/c1&gt; is now a more powerful stream micro-library, but it's no longer part of core.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034716Z" creationid="shibukawa.yoshiki" creationdate="20170131T034702Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt;では、&lt;c1&gt;m.prop()&lt;/c1&gt;はより強力でコンパクトなストリームとしてライブラリ化されました。Mithrilのコアからは外れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c0&gt;v1.x&lt;/c0&gt;, components are required instead in both cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T140512Z" creationid="shibukawa.yoshiki" creationdate="20170131T140512Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt;ではどちらの場合もコンポーネントが必要となりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c2&gt;v1.x&lt;/c2&gt; they are passed &lt;s3&gt;only&lt;/s3&gt; the &lt;c4&gt;vnode&lt;/c4&gt;, exactly like the &lt;c5&gt;controller&lt;/c5&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T122140Z" creationid="shibukawa.yoshiki" creationdate="20170131T122140Z">
        <seg>&lt;c2&gt;v1.x&lt;/c2&gt;では&lt;c5&gt;controller&lt;/c5&gt;と同じように、&lt;c4&gt;vnode&lt;/c4&gt;&lt;s3&gt;のみ&lt;/s3&gt;を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c2&gt;v1.x&lt;/c2&gt; this has been broken out into two functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141811Z" creationid="shibukawa.yoshiki" creationdate="20170131T141811Z">
        <seg>&lt;c2&gt;v1.x&lt;/c2&gt;ではこれは２つの関数に分離されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c5&gt;v.1.x&lt;/c5&gt; it is replaced by &lt;c6&gt;m.route.prefix(prefix)&lt;/c6&gt; where &lt;c7&gt;prefix&lt;/c7&gt; can be &lt;c8&gt;#&lt;/c8&gt;, &lt;c9&gt;?&lt;/c9&gt;, or an empty string (for "pathname" mode).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T140822Z" creationid="shibukawa.yoshiki" creationdate="20170131T140822Z">
        <seg>&lt;c5&gt;v.1.x&lt;/c5&gt;では&lt;c6&gt;m.route.prefix(prefix)&lt;/c6&gt;に変更されました。&lt;c7&gt;prefix&lt;/c7&gt;としては、&lt;c8&gt;#&lt;/c8&gt;、&lt;c9&gt;?&lt;/c9&gt;あるいは空文字列（"pathname"）が使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using &lt;a0&gt;mod_rewrite&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012855Z" creationid="shibukawa.yoshiki" creationdate="20150410T012855Z">
        <seg>Apacheを使っている場合は、&lt;a0&gt;mod_rewrite&lt;/a0&gt;を使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using ModRewrite.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170200Z" creationid="shibukawa.yoshiki" creationdate="20150414T170200Z">
        <seg>Apacheを使っている場合は、mod_rewriteを使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, UI state is understood to be model data, even though it doesn't necessarily map to a database ORM entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152904Z" creationid="shibukawa.yoshiki" creationdate="20150407T152904Z">
        <seg>Mithrilでは、UIの状態というのはデータベースのORMエンティティにマップされる必要はないが、モデルデータとなるべきもの、と考えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, a &lt;e0&gt;component&lt;/e0&gt; is an object that contains a &lt;c1&gt;view&lt;/c1&gt; function and optionally a &lt;c2&gt;controller&lt;/c2&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T124214Z" creationid="shibukawa.yoshiki" creationdate="20160101T124214Z">
        <seg>Mithrilにおいて、&lt;e0&gt;コンポーネント&lt;/e0&gt;は&lt;c1&gt;view&lt;/c1&gt;関数と、&lt;c2&gt;controller&lt;/c2&gt;関数(オプション)を含むオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, a component is nothing more than an object that has a &lt;c0&gt;view&lt;/c0&gt; function and, optionally, a &lt;c1&gt;controller&lt;/c1&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061341Z" creationid="shibukawa.yoshiki" creationdate="20150502T061341Z">
        <seg>Mithrilのコンポーネントは、&lt;c0&gt;view&lt;/c0&gt;関数と、オプションの&lt;c1&gt;controller&lt;/c1&gt;関数を持つ以外のルールはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, an application typically lives in a namespace and contains components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040153Z" creationid="shibukawa.yoshiki" creationdate="20150502T040153Z">
        <seg>Mithrilでは基本的に、アプリケーションは名前空間の中に作り、コンポーネントをその中に格納していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, this can be accomplished by returning a promise from the &lt;c0&gt;onmatch&lt;/c0&gt; hook:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T085819Z" creationid="shibukawa.yoshiki" creationdate="20170208T085819Z">
        <seg>Mithrilでは&lt;c0&gt;onmatch&lt;/c0&gt;フックでPromiseを返すことで簡単に実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, views are plain Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040855Z" creationid="shibukawa.yoshiki" creationdate="20150502T040855Z">
        <seg>MithrilではビューはプレーンなJavaScriptコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a command line, type:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150201Z" creationid="shibukawa.yoshiki" creationdate="20150412T150201Z">
        <seg>コマンドラインで次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a large application, it may be desirable to download the code for each route on demand, rather than upfront.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T085712Z" creationid="shibukawa.yoshiki" creationdate="20170208T085712Z">
        <seg>巨大なアプリケーションでは、事前に全部のプログラムをダウンロードするのではなく、ラウトごとにオンデマンドでコードをダウンロードするほうが望ましいことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real life application, a user would obviously have to supply proper login credentials, and clicking the login button would trigger a request to a server to authenticate the user:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075909Z" creationid="shibukawa.yoshiki" creationdate="20170208T075824Z">
        <seg>実際のアプリケーションでは、ユーザーは適切なログインクレデンシャルを持つ必要があるでしょう。ログインボタンを押すとサーバーにユーザーの認証リクエストを送る実装になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a typical Mithril application, that JSON data is then usually consumed by a view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022746Z" creationid="shibukawa.yoshiki" creationdate="20170220T022746Z">
        <seg>一般的なMithrilアプリケーションでは、このJSONデータはビューから利用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to being aware of data availability when deciding to redraw, Mithril is also aware of browser availability: if several redraws are triggered in a short amount of time, Mithril batches them so that at most only one redraw happens within a single animation frame (around 16ms).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191406Z" creationid="shibukawa.yoshiki" creationdate="20150411T191406Z">
        <seg>このように、再描画の決定にデータの可用性を判断基準にしていますが、これ以外にも、ブラウザの可用性についても考慮しています。もし、短時間で何度も再描画が行われようとしている場合には、Mithrilはこれらの再描画をまとめて、単一のアニメーションフレーム(16ミリ秒)に最大1回のみ再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to bi-directional data binding, we can also bind parameterized functions to events:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151223Z" creationid="shibukawa.yoshiki" creationdate="20150408T151223Z">
        <seg>双方向バインディング以外の機能では、パラメータ付き関数をイベントにバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to holding a controller and a view, a component can also be used to store data that pertains to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040327Z" creationid="shibukawa.yoshiki" creationdate="20150502T040327Z">
        <seg>コンポーネントはコントローラとビューを保持するだけではなく、関連するデータを格納するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to route parameters, it's possible to pass arbitrary data to &lt;c0&gt;m.route.param&lt;/c0&gt; using the querystring</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154349Z" creationid="shibukawa.yoshiki" creationdate="20150414T154349Z">
        <seg>ラウトパラメータ以外にも、クエリー文字列を使って任意のデータを&lt;c0&gt;m.route.param&lt;/c0&gt;に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to routing parameters, the &lt;c0&gt;attrs&lt;/c0&gt; object also includes a &lt;c1&gt;path&lt;/c1&gt; property that contains the current route path, and a &lt;c2&gt;route&lt;/c2&gt; property that contains the matched routed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054350Z" creationid="shibukawa.yoshiki" creationdate="20170208T054350Z">
        <seg>&lt;c0&gt;attrs&lt;/c0&gt;には、ラウトのパラメータだけではなく、現在のラウトのパスを格納する&lt;c1&gt;path&lt;/c1&gt;プロパティと、マッチしたラウトを含む&lt;c2&gt;route&lt;/c2&gt;プロパティもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the &lt;c0&gt;controller&lt;/c0&gt; and &lt;c1&gt;view&lt;/c1&gt; properties that make the &lt;c2&gt;Uploader&lt;/c2&gt; object usable as a component, it also has an &lt;c3&gt;upload&lt;/c3&gt; convenience function that provides a basic upload model method, and a &lt;c4&gt;serialize&lt;/c4&gt; function that allows files to be serialized as JSON in regular requests encoded as &lt;c5&gt;application/x-www-form-urlencoded&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034456Z" creationid="shibukawa.yoshiki" creationdate="20150502T032543Z">
        <seg>&lt;c2&gt;Uploader&lt;/c2&gt;オブジェクトをそのままコンポーネントとして使えるように&lt;c0&gt;controller&lt;/c0&gt;と&lt;c1&gt;view&lt;/c1&gt;プロパティを提供しています。また、それに追加して基本的なアップロードの機能を提供する&lt;c3&gt;upload&lt;/c3&gt;関数もモデルのメソッドとして提供しています。また、通常はJSONでシリアライズされるサーバリクエストで、&lt;c5&gt;application/x-www-form-urlencoded&lt;/c5&gt;エンコードでファイル送信ができるようにする&lt;c4&gt;serialize&lt;/c4&gt;関数も提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, &lt;c2&gt;initialValue&lt;/c2&gt;, &lt;c3&gt;unwrapSuccess&lt;/c3&gt; and &lt;c4&gt;unwrapError&lt;/c4&gt; are no longer supported options.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045254Z" creationid="shibukawa.yoshiki" creationdate="20170201T045254Z">
        <seg>これに加えて、&lt;c2&gt;initialValue&lt;/c2&gt;、&lt;c3&gt;unwrapSuccess&lt;/c3&gt;、&lt;c4&gt;unwrapError&lt;/c4&gt;はオプションからはサポートされなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Mithril attempts to intelligently redraw only when it is appropriate in an application lifecycle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184427Z" creationid="shibukawa.yoshiki" creationdate="20150411T184427Z">
        <seg>これに加えて、Mithrilはアプリケーションのライフサイクルを考え、適切なタイミングでのみ再描画を実行するようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Mithril's XHR module is optimized for JSON-based endpoints and makes that most common case appropriately terse - i.e. &lt;c0&gt;m.request(url)&lt;/c0&gt; - whereas &lt;c1&gt;fetch&lt;/c1&gt; requires an additional explicit step to parse the response data as JSON: &lt;c2&gt;fetch(url).then(function(response) {return response.json()})&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T033748Z" creationid="shibukawa.yoshiki" creationdate="20170220T033748Z">
        <seg>さらに、MithrilのXHRはJSONベースのエンドポイントを利用するのに最適化されており、一般的な用途でシンプルに利用できます。&lt;c0&gt;m.request(url)&lt;/c0&gt;の代わりに&lt;c1&gt;fetch&lt;/c1&gt;を使うと、レスポンスのJSONデータを変換するには、&lt;c2&gt;fetch(url).then(function(response) {return response.json()})&lt;/c2&gt;などの追加の明示的なステップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, an application can be organizationally divided into three major layers: Model, Controller and View.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T145325Z" creationid="shibukawa.yoshiki" creationdate="20150407T144808Z">
        <seg>アプリケーションはModel、Controller、Viewの大きく3つのレイヤーにきれいに分割することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, components can be reused in different contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005453Z" creationid="shibukawa.yoshiki" creationdate="20150502T005453Z">
        <seg>それに加えて、さまざまなコンテキストでコンポーネントを再利用しやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, having a deeply nested tree of components can result in a lot of intermediate "pass-through" arguments and event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013517Z" creationid="shibukawa.yoshiki" creationdate="20150502T013517Z">
        <seg>それに加えて、ツリーのネストが深くなると、コンポーネント間の引数のパススルーや、イベントハンドラが増えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it stores the unsaved contact entity internally within the component (&lt;c3&gt;this.contact = m.prop(args.contact || new Contact())&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002318Z" creationid="shibukawa.yoshiki" creationdate="20150502T002318Z">
        <seg>それに加えて、未保存の連絡先情報をコンポーネント内に保管しています(&lt;c3&gt;this.contact = m.prop(args.contact || new Contact())&lt;/c3&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it's possible for non-Mithril asynchronous callbacks to trigger auto-redrawing by calling &lt;c0&gt;m.startComputation&lt;/c0&gt; and &lt;c1&gt;m.endComputation&lt;/c1&gt; in appropriate places (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185216Z" creationid="shibukawa.yoshiki" creationdate="20150411T185216Z">
        <seg>これに加えて、Mithril外の非同期のコールバックからも、&lt;c0&gt;m.startComputation&lt;/c0&gt;関数と&lt;c1&gt;m.endComputation&lt;/c1&gt;関数を適切な場所に配置することで(あとで説明します)、再描画のシステムを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that most &lt;c0&gt;m.route&lt;/c0&gt; modes rely on &lt;c1&gt;history.pushState&lt;/c1&gt; in order to allow moving from one page to another without a browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015141Z" creationid="shibukawa.yoshiki" creationdate="20150417T015141Z">
        <seg>また、多くの&lt;c0&gt;m.route&lt;/c0&gt;モードは、ブラウザをリフレッシュしないで他のページにジャンプするために&lt;c1&gt;history.pushState&lt;/c1&gt;を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that template performance, both in Mithril templates as well as in general, is dependent on markup complexity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020742Z" creationid="shibukawa.yoshiki" creationdate="20150421T020742Z">
        <seg>また、Mithrilだけではなく他のテンプレートにも共通することとして、マークアップの複雑性がテンプレートのパフォーマンスに影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, requests no longer have &lt;c0&gt;m.startComputation&lt;/c0&gt;/&lt;c1&gt;m.endComputation&lt;/c1&gt; semantics.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045320Z" creationid="shibukawa.yoshiki" creationdate="20170201T045320Z">
        <seg>さらに、&lt;c0&gt;m.startComputation&lt;/c0&gt;/&lt;c1&gt;m.endComputation&lt;/c1&gt;セマンティクスはサポートされなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, setting &lt;c0&gt;context.retain = false&lt;/c0&gt; will also cause the element to be recreated, even if it is not considered different enough.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135454Z" creationid="shibukawa.yoshiki" creationdate="20150413T135435Z">
        <seg>&lt;c0&gt;context.retain = false&lt;/c0&gt;が設定された場合は、変更が小さくてもエレメントは破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, this guide section covers topics related to how to fit all the pieces together.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114636Z" creationid="shibukawa.yoshiki" creationdate="20150417T114636Z">
        <seg>また、ガイドのセクションでは、すべての部品をどのように組み合わせていくかという内容もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you cannot call &lt;c0&gt;m.request&lt;/c0&gt; from templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094829Z" creationid="shibukawa.yoshiki" creationdate="20150502T094829Z">
        <seg>それに加えて、テンプレート内で&lt;c0&gt;m.request&lt;/c0&gt;は使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In classic MVC, the role of the controller is to dispatch actions from the view to the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163947Z" creationid="shibukawa.yoshiki" creationdate="20150407T163947Z">
        <seg>クラシカルなMVCでは、ビューからやってきたアクションを、モデルのレイヤーにディスパッチするのがコントローラの役割です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In client-side MVC, however, this dissonance doesn't exist, and controllers can be extremely simple.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002248Z" creationid="shibukawa.yoshiki" creationdate="20150408T002248Z">
        <seg>クライアントサイドMVCではこのような定義との不一致は存在しないため、コントローラは極めてシンプルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; calls to avoid clutter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010544Z" creationid="shibukawa.yoshiki" creationdate="20150412T010544Z">
        <seg>階層に分けた統合と比べると、&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; to avoid clutter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160320Z" creationid="shibukawa.yoshiki" creationdate="20150416T160320Z">
        <seg>階層に分けた統合と比べると、&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, &lt;c2&gt;m.redraw&lt;/c2&gt; is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114429Z" creationid="shibukawa.yoshiki" creationdate="20150502T114429Z">
        <seg>これとは対照的に&lt;c2&gt;m.redraw&lt;/c2&gt;は「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, &lt;c3&gt;m.redraw&lt;/c3&gt; is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130609Z" creationid="shibukawa.yoshiki" creationdate="20150502T130609Z">
        <seg>これとは対照的に&lt;c3&gt;m.redraw&lt;/c3&gt;は「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril avoids "magic" types.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110513Z" creationid="shibukawa.yoshiki" creationdate="20150420T110513Z">
        <seg>Mithrilではこのように「魔法」の型を避ける実装になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril encourages you to develop applications using the patterns found throughout this guide, and discourages the use of "bastardized" MVC pattern variations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020610Z" creationid="shibukawa.yoshiki" creationdate="20150420T020610Z">
        <seg>Mithrilはこれとは対照的に、このガイドで示しているようなアプリケーション開発のパターンを共通言語として広めようとしています。それにより、「質の悪いMVCもどきのパターン」が広まるのを防ごうとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril separates the two layers more distinctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105625Z" creationid="shibukawa.yoshiki" creationdate="20150420T105625Z">
        <seg>それに対して、Mithrilははっきりと2つのレイヤーを分離しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In example 2, since &lt;c0&gt;Layout&lt;/c0&gt; is the top-level component in both routes, the DOM for the &lt;c1&gt;Layout&lt;/c1&gt; component is diffed (i.e. left intact if it has no changes), and only the change from &lt;c2&gt;Home&lt;/c2&gt; to &lt;c3&gt;Form&lt;/c3&gt; triggers a recreation of that subsection of the DOM.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T074619Z" creationid="shibukawa.yoshiki" creationdate="20170208T074619Z">
        <seg>例2では、どちらのラウトでも&lt;c0&gt;Layout&lt;/c0&gt;がトップレベルコンポーネントでした。そのため、&lt;c1&gt;Layout&lt;/c1&gt;コンポーネントでは完全再作成ではなく、差分検知が行われ、変更がない部分はそのまま残り、DOMの子要素の&lt;c2&gt;Home&lt;/c2&gt;から&lt;c3&gt;Form&lt;/c3&gt;への再作成だけが行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, Mithril is able to render a fully functional application - with working event handlers - before the "DOM ready" event fires!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013547Z" creationid="shibukawa.yoshiki" creationdate="20150409T013547Z">
        <seg>実際に、Mithrilは完全に機能を持ちイベントハンドラができる状態になってから描画を行います。DOMの準備ができるというイベントが発生する前にです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, unavoidable abstraction leaks (such as network-bound asynchrony) are laid out in such a way as to make idiomatic code organization elegant, and conversely, to make it so that the abstraction leak problems themselves discourage attempts to misplace entity logic in the controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032301Z" creationid="shibukawa.yoshiki" creationdate="20150421T014824Z">
        <seg>抽象化が漏れて、レイヤーを超えてコードが密結合してしまうコードというのはあります。例えばネットワークの非同期性を取り扱う場合にこのようなことがあります。この場合も、エンティティのロジックがコントローラの中に取り残されがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, when not using the &lt;a0&gt;MSX&lt;/a0&gt; HTML syntax preprocessor, it's recommended that you embrace using CSS selectors (e.g. &lt;c1&gt;m(".modal-body")&lt;/c1&gt;) to really benefit from their inherent semantic expressiveness.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041537Z" creationid="shibukawa.yoshiki" creationdate="20150502T041537Z">
        <seg>&lt;a0&gt;MSX&lt;/a0&gt;HTML文法プリプロセッサを使っていなくても、本来のセマンティック表現の恩恵を受けられるため、&lt;c1&gt;m(".modal-body")&lt;/c1&gt;のようなCSSセレクタ形式を使うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In functional programming, this is called &lt;a1&gt;&lt;e2&gt;partial application&lt;/e2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151412Z" creationid="shibukawa.yoshiki" creationdate="20150408T151412Z">
        <seg>関数型プログラミングの世界では、これは&lt;a1&gt;&lt;e2&gt;部分適用(partial application)&lt;/e2&gt;&lt;/a1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In it, the count is stored in the context object and re-accessed on each redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125936Z" creationid="shibukawa.yoshiki" creationdate="20150413T125936Z">
        <seg>このコードの中で、再描画のカウントはコンテキストオブジェクト内に格納されます。このオブジェクトは再描画のたびにアクセスができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its place, &lt;c2&gt;ContactForm&lt;/c2&gt; merely emits an action, which is then handled by this model layer observer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031544Z" creationid="shibukawa.yoshiki" creationdate="20150502T031544Z">
        <seg>&lt;c2&gt;ContactForm&lt;/c2&gt;では単に、アクションを送信しています。これはモデルレイヤーのオブザーバが受け取って処理をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In jQuery it's common to use the DOM as a data storage mechanism, whereas Mithril encourages data to exist in an isolated model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015734Z" creationid="shibukawa.yoshiki" creationdate="20150420T015734Z">
        <seg>jQueryはDOMをデータ構造のための箱として使いますが、Mithrilはデータをそれと分離したモデルレイヤーに分けようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many frameworks UI state is typically stored in a controller, but doing so makes the code harder to scale since controllers aren't designed to be data providers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152609Z" creationid="shibukawa.yoshiki" creationdate="20150407T152609Z">
        <seg>多くのフレームワークでは、UIの状態はコントローラの内部に保持されます。しかし、コントローラはデータプロバイダとしてデザインされていないため、このような構造にしてしまうと、コードをスケールさせるのが難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In model-level methods if client-side processing is needed to make the data useful for a controller or view</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125646Z" creationid="shibukawa.yoshiki" creationdate="20150410T125646Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve that, Mithril supports parameterized routes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053658Z" creationid="shibukawa.yoshiki" creationdate="20170208T053658Z">
        <seg>この機能を実現するために、Mithrilはパラメータ化したラウトをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to allow a user to navigate between different pages by loading and unloading components, consider using &lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125327Z" creationid="shibukawa.yoshiki" creationdate="20150502T125327Z">
        <seg>もし、複数のページ間でユーザをナビゲーションをして、その時にコンポーネントのロード/リロードを行いたい場合は、&lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt;を代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to deal with that type of refactoring, one can explicitly decide to support only a subset of the Array API, and implement another class with the same interface as this subset API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003539Z" creationid="shibukawa.yoshiki" creationdate="20150409T003539Z">
        <seg>TodoListのようなクラスをリファクタリングする時は、ArrayクラスのAPIの一部だけをサポートするか、似た機能を持つまったく他のクラスを実装するか決定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to do that, you first need to create a component that contains the common markup that will wrap around the various different components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T065805Z" creationid="shibukawa.yoshiki" creationdate="20170208T065805Z">
        <seg>まずさまざまなコンポーネントをラップする、共通のマークアップを含むコンポーネントを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable auto-redrawing, the &lt;c1&gt;todo&lt;/c1&gt; component must be initialized by either calling &lt;c2&gt;m.mount&lt;/c2&gt; or by creating a route definition with &lt;c3&gt;m.route&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041601Z" creationid="shibukawa.yoshiki" creationdate="20150502T041601Z">
        <seg>自動再描画システムを利用する場合は、 &lt;c2&gt;m.mount&lt;/c2&gt;を使って&lt;c1&gt;todo&lt;/c1&gt;コンポーネントを初期化するか、&lt;c3&gt;m.route&lt;/c3&gt;を使ってラウト(route)を定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to force a redraw after a background request, use &lt;a0&gt;&lt;c1&gt;m.redraw&lt;/c1&gt;&lt;/a0&gt;, or &lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012022Z" creationid="shibukawa.yoshiki" creationdate="20150415T012022Z">
        <seg>バックグラウンドのリクエスト後に再描画を行わせたい場合は、&lt;a0&gt;&lt;c1&gt;m.redraw&lt;/c1&gt;&lt;/a0&gt;もしくは&lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt;を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to implement this principle, the rendering engine must run a redraw algorithm globally to ensure no parts of the UI are out of sync with the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183754Z" creationid="shibukawa.yoshiki" creationdate="20150411T183754Z">
        <seg>この原則をきちんと実装するためには、データとの同期が漏れているUI部品がなくならないようにするために、再描画のアルゴリズムをビュー全体に対して漏れ無く実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate an asynchronous code to Mithril's autoredrawing system, you should call &lt;c0&gt;m.startComputation&lt;/c0&gt; BEFORE making an asynchronous call, and &lt;c1&gt;m.endComputation&lt;/c1&gt; after the asynchronous callback completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153136Z" creationid="shibukawa.yoshiki" creationdate="20150416T153136Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」&lt;c0&gt;m.startComputation&lt;/c0&gt;を呼び出し、非同期のコールバックの最後で&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate asynchronous code to Mithril's autoredrawing system, you should call &lt;c0&gt;m.startComputation&lt;/c0&gt; BEFORE making an asynchronous call, and &lt;c1&gt;m.endComputation&lt;/c1&gt; at the end of the asynchronous callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192747Z" creationid="shibukawa.yoshiki" creationdate="20150411T192747Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」&lt;c0&gt;m.startComputation&lt;/c0&gt;を呼び出し、非同期のコールバックの最後で&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code to Mithril's auto-redrawing system, you need to ensure all execution threads call &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155920Z" creationid="shibukawa.yoshiki" creationdate="20150416T155920Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドで&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code with Mithril's auto-redrawing system, you need to ensure all execution threads call &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004625Z" creationid="shibukawa.yoshiki" creationdate="20150412T004625Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドで&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to migrate, search for &lt;c0&gt;m.module&lt;/c0&gt; calls and replace them with &lt;c1&gt;m.mount&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141350Z" creationid="shibukawa.yoshiki" creationdate="20160412T141350Z">
        <seg>移行する場合は、&lt;c0&gt;m.module&lt;/c0&gt;呼び出しを探しだして、&lt;c1&gt;m.mount&lt;/c1&gt;にリネームすること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent redraws in &lt;e0&gt;some parts&lt;/e0&gt; of an application, but not others, see &lt;a1&gt;subtree directives&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T145222Z" creationid="shibukawa.yoshiki" creationdate="20150416T145222Z">
        <seg>アプリケーション内の&lt;e0&gt;一部分&lt;/e0&gt;の再描画だけを止めたい場合は、&lt;a1&gt;サブツリーディレクティブ&lt;/a1&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to retrieve the currently active route in a controller, you can use &lt;c0&gt;m.route()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171909Z" creationid="shibukawa.yoshiki" creationdate="20150414T171909Z">
        <seg>コントローラ内で、現在アクティブなラウトを取得するには、&lt;c0&gt;m.route()&lt;/c0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to specify the name of the querystring parameter that indicates the callback function, use the &lt;c2&gt;callbackKey&lt;/c2&gt; option:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235625Z" creationid="shibukawa.yoshiki" creationdate="20150414T235625Z">
        <seg>コールバック関数を表すクエリー文字列を指定するには、&lt;c2&gt;callbackKey&lt;/c2&gt;を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to stay flexible, Mithril doesn't provide helpers for bi-directional bindings out of the box.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014108Z" creationid="shibukawa.yoshiki" creationdate="20150413T014108Z">
        <seg>柔軟性を維持するために、Mithrilでは双方向バインディングを生成するヘルパーは提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to turn the virtual element into a real DOM element, you must call &lt;a1&gt;&lt;c2&gt;m.render()&lt;/c2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000156Z" creationid="shibukawa.yoshiki" creationdate="20150413T000156Z">
        <seg>仮想DOMを本物のDOMに変換するには&lt;a1&gt;&lt;c2&gt;m.render()&lt;/c2&gt;&lt;/a1&gt;を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to update a forked version of Mithril, &lt;a0&gt;follow the instructions on this page&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000743Z" creationid="shibukawa.yoshiki" creationdate="20150408T000743Z">
        <seg>フォークしたMithrilを更新したい場合は、&lt;a0&gt;このページの説明(英語)&lt;/a0&gt;.に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use Mithril, extract it from the zip file and point a script tag to the &lt;c0&gt;.js&lt;/c0&gt; file:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164806Z" creationid="shibukawa.yoshiki" creationdate="20150407T164806Z">
        <seg>Mithrilを使用する場合は、zipファイルを展開し、その中の&lt;c0&gt;.js&lt;/c0&gt;ファイルをscriptタグを使って指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, all our controller needs to do is this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004121Z" creationid="shibukawa.yoshiki" creationdate="20150408T004109Z">
        <seg>Mithrilのコントローラが行うべきことは、次のコードがすべてです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, don't add the hashbang &lt;c0&gt;#!&lt;/c0&gt; in front of the route path when linking via &lt;c1&gt;m.route.link&lt;/c1&gt; or redirecting.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053503Z" creationid="shibukawa.yoshiki" creationdate="20170208T053503Z">
        <seg>むしろ、&lt;c1&gt;m.route.link&lt;/c1&gt;やリダイレクトを行う時には、&lt;c0&gt;#!&lt;/c0&gt;をラウトパスの前に追加してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, don't do this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100006Z" creationid="shibukawa.yoshiki" creationdate="20150502T100006Z">
        <seg>別の説明をすると、以下のようなことをしてはならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, since the whole application lives in one component, we're going to use the component as a namespace for our model entities.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040727Z" creationid="shibukawa.yoshiki" creationdate="20150502T040727Z">
        <seg>今回のサンプルではすべてのアプリケーションが1つのコンポーネントに収まっているため、コンポーネントを名前空間として使い、モデルの実体もその中にいれてしまいましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means performing operations like shifting an item from the beginning of a list would cause every element in the list to be diffed and potentially recreated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141226Z" creationid="shibukawa.yoshiki" creationdate="20150413T141226Z">
        <seg>例えば、リストの先頭に挿入するような操作は、すべての要素が変更されたとみなして、すべてが再生成されてしまう可能性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling &lt;c0&gt;m.component(MyComponent, {foo: "bar"})&lt;/c0&gt; will return a component that behaves exactly the same as &lt;c1&gt;MyComponent&lt;/c1&gt;, but &lt;c2&gt;{foo: "bar"}&lt;/c2&gt; will be bound as an argument to both the &lt;c3&gt;controller&lt;/c3&gt; and &lt;c4&gt;view&lt;/c4&gt; functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075727Z" creationid="shibukawa.yoshiki" creationdate="20150502T075727Z">
        <seg>&lt;c0&gt;m.component(MyComponent, {foo: "bar"})&lt;/c0&gt;という呼び出しをすると、&lt;c1&gt;MyComponent&lt;/c1&gt;と同じコンポーネントを返しますが、&lt;c2&gt;{foo: "bar"}&lt;/c2&gt;という引数が&lt;c3&gt;controller&lt;/c3&gt;と&lt;c4&gt;view&lt;/c4&gt;関数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling &lt;c3&gt;m.redraw&lt;/c3&gt; may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115057Z" creationid="shibukawa.yoshiki" creationdate="20150502T115057Z">
        <seg>&lt;c3&gt;m.redraw&lt;/c3&gt;を使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling &lt;c4&gt;m.redraw&lt;/c4&gt; may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130619Z" creationid="shibukawa.yoshiki" creationdate="20150502T130619Z">
        <seg>&lt;c4&gt;m.redraw&lt;/c4&gt;を使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that if the two components were in a &lt;c0&gt;ContactsWidget&lt;/c0&gt; component as before, saving a contact would not update the list without some extra code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015527Z" creationid="shibukawa.yoshiki" creationdate="20150502T015527Z">
        <seg>実際、&lt;c0&gt;ContactsWidget&lt;/c0&gt;内にコンポーネントが2つあるとすると、何もコードを追加しなければリストが更新されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In real life, given a choice, you should always pick the simplest idiom for your use case.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152802Z" creationid="shibukawa.yoshiki" creationdate="20150408T152802Z">
        <seg>実際のコーディングでは、いくつか選択肢があった場合には、ユースケースを実現するもっともシンプルな方法を選択すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In situations where you would have used &lt;c5&gt;m.deferred&lt;/c5&gt;, you should use Promises instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050111Z" creationid="shibukawa.yoshiki" creationdate="20170201T050111Z">
        <seg>&lt;c5&gt;m.deferred&lt;/c5&gt;を使用していたところではPromiseを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, it's the view-model's responsibility to track the current state of the input vs the original state and to apply a cancellation, if required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160811Z" creationid="shibukawa.yoshiki" creationdate="20150407T160650Z">
        <seg>このケースでは、ビュー・モデルは、オリジナルの状態とテキスト入力の現在の状態の差のトラッキングと、キャンセル処理の提要に関する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, simply omit the m.startComputation/m.endComputation calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135804Z" creationid="shibukawa.yoshiki" creationdate="20150415T135804Z">
        <seg>その場合は、単にm.startComputation/m.endComputation呼び出しを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In terms of architecture, one of Mithril's main differences is that it does not provide base classes to extend from.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114958Z" creationid="shibukawa.yoshiki" creationdate="20150417T114958Z">
        <seg>アーキテクチャ面でみると、Mithrilが他のフレームワークと大きく異るのは、拡張する元となるベースクラスを提供していない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it's possible to skip redrawing altogether by calling &lt;c0&gt;m.redraw.strategy("none")&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150228Z" creationid="shibukawa.yoshiki" creationdate="20150416T150228Z">
        <seg>この場合、&lt;c0&gt;m.redraw.strategy("none")&lt;/c0&gt;を呼ぶことで、再描画をスキップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the application above, notice how the Todo class can easily be moved to a different component if code re-organization is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041831Z" creationid="shibukawa.yoshiki" creationdate="20150502T041831Z">
        <seg>上記のコードのTodoクラスは、もしコードを再構成する必要が出てきたとしても、とても簡単に他のコンポーネントに移動できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case above, Mithril only touches the &lt;c0&gt;value&lt;/c0&gt; attribute of the input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015644Z" creationid="shibukawa.yoshiki" creationdate="20150408T015644Z">
        <seg>上記の場合、Mithrilはテキスト入力の&lt;c0&gt;value&lt;/c0&gt;属性しか変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of our todo application, the view-model needs a few things: it needs to track a running list of todos and a field for adding new todos, and it needs to handle the logic of adding to the todo and the implications of this action of the UI.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161612Z" creationid="shibukawa.yoshiki" creationdate="20150407T161441Z">
        <seg>われわれのToDoアプリケーションでは、ビュー・モデルに必要とされるものはそれほど多くありません。アクティブなToDoのリストと、新しいToDoを追加するためのフィールドの管理、ToDoを追加するロジックや、UIのアクションとの連携です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, &lt;c0&gt;:id&lt;/c0&gt; is populated with the data from the &lt;c1&gt;{id: 123}&lt;/c1&gt; object, and the request becomes &lt;c2&gt;GET /api/v1/users/123&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T151757Z" creationid="shibukawa.yoshiki" creationdate="20170219T151757Z">
        <seg>上記の例では&lt;c0&gt;:id&lt;/c0&gt;の項目はオブジェクト&lt;c1&gt;{id: 123}&lt;/c1&gt;を使って置き換えられ、リクエスト先は&lt;c2&gt;GET /api/v1/users/123&lt;/c2&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, &lt;c0&gt;todo.vm.list&lt;/c0&gt; is an Array, and &lt;c1&gt;map&lt;/c1&gt; is one of its native functional methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153022Z" creationid="shibukawa.yoshiki" creationdate="20150408T153022Z">
        <seg>上記のコードの&lt;c0&gt;todo.vm.list&lt;/c0&gt;はJavaScriptの配列です。&lt;c1&gt;map&lt;/c1&gt;は関数型プログラミング的な機能を提供する、標準の関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, the &lt;c0&gt;oninput&lt;/c0&gt; event handler updates the &lt;c1&gt;name&lt;/c1&gt; getter-setter, and the Mithril auto-redrawing system redraws the template in order to update the displayed value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014815Z" creationid="shibukawa.yoshiki" creationdate="20150413T014815Z">
        <seg>この上記のサンプルを実行すると、&lt;c0&gt;oninput&lt;/c0&gt;イベントハンドラが&lt;c1&gt;name&lt;/c1&gt; getter-setterを更新します。Mithrilの自動再描画システムが表示される値の更新にともなって再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, the request becomes &lt;c0&gt;GET /api/v1/users/foo:bar&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152506Z" creationid="shibukawa.yoshiki" creationdate="20170219T152506Z">
        <seg>上記のコードではリクエスト先は&lt;c0&gt;GET /api/v1/users/foo:bar&lt;/c0&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, we are simply using the native Javascript &lt;c0&gt;Function::bind&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151318Z" creationid="shibukawa.yoshiki" creationdate="20150408T151318Z">
        <seg>上記のコードは、標準的なJavaScriptの&lt;c0&gt;Function::bind&lt;/c0&gt;メソッドを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller layer: to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123840Z" creationid="shibukawa.yoshiki" creationdate="20150410T123840Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123813Z" creationid="shibukawa.yoshiki" creationdate="20150410T123726Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller, to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125741Z" creationid="shibukawa.yoshiki" creationdate="20150410T125741Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller, to redirect after a model service resolves</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125727Z" creationid="shibukawa.yoshiki" creationdate="20150410T125727Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the event the form was saved, then view-model would delegate saving to a more appropriate ORM model entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160932Z" creationid="shibukawa.yoshiki" creationdate="20150407T160923Z">
        <seg>フォームが保存されるというイベントが発生したら、ビュー・モデルはより適切なORMモデルエンティティに保存処理を移譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, A+ promises are required to log &lt;c0&gt;2&lt;/c0&gt; before logging &lt;c1&gt;1&lt;/c1&gt;, whereas Mithril logs &lt;c2&gt;1&lt;/c2&gt; before &lt;c3&gt;2&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140509Z" creationid="shibukawa.yoshiki" creationdate="20150415T140509Z">
        <seg>このサンプルを実行すると、A+ promisesの場合は、 &lt;c1&gt;1&lt;/c1&gt;の前に&lt;c0&gt;2&lt;/c0&gt;をログ出力しますが、Mithrilは&lt;c3&gt;2&lt;/c3&gt;の前に&lt;c2&gt;1&lt;/c2&gt;を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, a file input is rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T191309Z" creationid="shibukawa.yoshiki" creationdate="20170219T191309Z">
        <seg>上記のサンプルではファイルのinputタグを表示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, assuming &lt;c0&gt;/api/v1/users&lt;/c0&gt; returns an array of objects, the &lt;c1&gt;User&lt;/c1&gt; constructor will be instantiated (i.e. called as &lt;c2&gt;new User(data)&lt;/c2&gt;) for each object in the array.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004340Z" creationid="shibukawa.yoshiki" creationdate="20170220T004340Z">
        <seg>この例では、&lt;c0&gt;/api/v1/users&lt;/c0&gt;はオブジェクトの配列を返すことを想定しています。その配列の各要素のオブジェクトごとに&lt;c1&gt;User&lt;/c1&gt;コンストラクタが呼ばれます。内部では要素ごとに&lt;c2&gt;new User(data)&lt;/c2&gt;というコンストラクタ呼び出しが行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, input focus would be maintained correctly after a redraw even if &lt;c0&gt;items&lt;/c0&gt; got sorted or reversed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142321Z" creationid="shibukawa.yoshiki" creationdate="20150413T142321Z">
        <seg>上記のサンプルでは、&lt;c0&gt;items&lt;/c0&gt;がソートされたり、順序が逆転したあとに再描画されても、正しくフォーカスが維持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, on the first render, the UI displays &lt;c0&gt;"loading"&lt;/c0&gt; since &lt;c1&gt;state.users&lt;/c1&gt; is an empty array before the request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T081456Z" creationid="shibukawa.yoshiki" creationdate="20170208T081456Z">
        <seg>上記のサンプルは、最初のレンダリングでは&lt;c1&gt;state.users&lt;/c1&gt; が空配列なので、リクエストが完了するまでは&lt;c0&gt;"ロード中"&lt;/c0&gt;と表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, since the key is different, the ProjectList component is recreated from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085849Z" creationid="shibukawa.yoshiki" creationdate="20150502T085849Z">
        <seg>上記の例では、キーが異なるため、ProjectListのコンポーネントは一度破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c0&gt;Menu&lt;/c0&gt; component has two links.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T052959Z" creationid="shibukawa.yoshiki" creationdate="20170208T052959Z">
        <seg>上記のサンプルでは&lt;c0&gt;Menu&lt;/c0&gt;コンポーネントは2つリンクを持っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the layout merely consists of a &lt;c0&gt;&lt;div class="layout"&gt;&lt;/c0&gt; that contains the children passed to the component, but in a real life scenario it could be as complex as neeeded.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T070849Z" creationid="shibukawa.yoshiki" creationdate="20170208T070849Z">
        <seg>上記の例ではレイアウトの構成要素は、引数で渡された子供のコンポーネントをラップする&lt;c0&gt;&lt;div class="layout"&gt;&lt;/c0&gt;しかありませんが、現実世界ではより複雑なコードになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the request retrieves an SVG file, does nothing to parse it (because &lt;c0&gt;deserialize&lt;/c0&gt; merely returns the value as-is), and then renders the SVG string as trusted HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004827Z" creationid="shibukawa.yoshiki" creationdate="20170220T004827Z">
        <seg>この上記のサンプルのリクエストはSVGファイルを取得しています。このサンプルの&lt;c0&gt;deserialize&lt;/c0&gt;関数は入力値をそのまま返しているため、パースは何も行われません。SVG文字列をそのまま信用できるHTMLとしてレンダリングしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the text input is bi-directionally bound to a &lt;c0&gt;temp&lt;/c0&gt; getter-setter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081318Z" creationid="shibukawa.yoshiki" creationdate="20150502T081318Z">
        <seg>上記のサンプルは、テキスト入力と、&lt;c0&gt;temp&lt;/c0&gt; getter-setterが双方向のバインディングで接続されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the usage of &lt;c0&gt;m.prop&lt;/c0&gt; allows the developer to change the implementation of the user name getter/setter without the need for code changes in the controller and view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134725Z" creationid="shibukawa.yoshiki" creationdate="20150414T134725Z">
        <seg>上記のサンプルでは、&lt;c0&gt;m.prop&lt;/c0&gt;を使うことで、コントローラとビュー内のコードを変更することなく、ユーザ名のgetter/setterの実装を変更できるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, there are 3 components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001408Z" creationid="shibukawa.yoshiki" creationdate="20150502T001408Z">
        <seg>上記のサンプルには3つのコンポーネントが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, there are two components: &lt;c0&gt;Home&lt;/c0&gt; and &lt;c1&gt;Page1&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100742Z" creationid="shibukawa.yoshiki" creationdate="20170207T100742Z">
        <seg>このサンプルには、&lt;c0&gt;Home&lt;/c0&gt;と&lt;c1&gt;Page1&lt;/c1&gt;の2つのコンポーネントが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, we defined a route &lt;c0&gt;/edit/:id&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053744Z" creationid="shibukawa.yoshiki" creationdate="20170208T053744Z">
        <seg>このサンプルでは&lt;c0&gt;/edit/:id&lt;/c0&gt;というラウトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, &lt;c0&gt;User.list&lt;/c0&gt; returns a list of &lt;c1&gt;User&lt;/c1&gt; instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170638Z" creationid="shibukawa.yoshiki" creationdate="20150410T170552Z">
        <seg>次のサンプルでは、&lt;c0&gt;User.list&lt;/c0&gt;メソッドは、&lt;c1&gt;User&lt;/c1&gt;インスタンスのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, clicking the button triggers the component's &lt;c0&gt;onunload&lt;/c0&gt; event and logs "unloaded!".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092735Z" creationid="shibukawa.yoshiki" creationdate="20150502T092735Z">
        <seg>次のサンプルはボタンを押すとコンポーネントの&lt;c0&gt;onunload&lt;/c0&gt;イベントが呼ばれ、"アンロード!"とログに出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the &lt;c0&gt;listEven&lt;/c0&gt; method returns a getter-setter that resolves to a list of users containing only users whose id is even.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124205Z" creationid="shibukawa.yoshiki" creationdate="20150410T124205Z">
        <seg>下記のサンプルの&lt;c0&gt;listEven&lt;/c0&gt;メソッドは、IDが偶数のユーザを含むリストのみを返すgetter-setterを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, there are two routes, each of which loads a component when a user navigates to their respective URLs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124551Z" creationid="shibukawa.yoshiki" creationdate="20150502T124551Z">
        <seg>下記のサンプルには、2つのラウトがあります。ユーザがどちらかのURLにアクセスすると、それぞれのコンポーネントをロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we bind an error getter-setter to our previous controller so that the &lt;c0&gt;error&lt;/c0&gt; variable gets populated if the server throws an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125140Z" creationid="shibukawa.yoshiki" creationdate="20150410T125140Z">
        <seg>下記のサンプルでは、error getter-setterと、前のサンプルで紹介したコントローラをバインドしています。&lt;c0&gt;error&lt;/c0&gt;変数は、サーバアクセスがうまく行かなかった時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175107Z" creationid="shibukawa.yoshiki" creationdate="20150414T175107Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130243Z" creationid="shibukawa.yoshiki" creationdate="20150410T125757Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we use the previously defined &lt;c0&gt;listEven&lt;/c0&gt; model method and queue a controller-level function that redirects to another page if the user list is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124651Z" creationid="shibukawa.yoshiki" creationdate="20150410T124651Z">
        <seg>下記の例では、前の例で定義したモデルの&lt;c0&gt;listEven&lt;/c0&gt;メソッドを使用します。ユーザのリストが空の場合に他のページにリダイレクトするというコントローラレベルの機能をモデル完了後の操作としてキューイングしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123731Z" creationid="shibukawa.yoshiki" creationdate="20150410T123712Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the view-model, we aliased the native Array class for &lt;c0&gt;TodoList&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002657Z" creationid="shibukawa.yoshiki" creationdate="20150409T002628Z">
        <seg>サンプルのビュー・モデルの中で、&lt;c0&gt;TodoList&lt;/c0&gt;クラスを単なる配列のエイリアスとして定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it means &lt;c4&gt;fetch&lt;/c4&gt; returns, and the component is rendered using the original empty array as &lt;c5&gt;Data.todos.list&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143951Z" creationid="shibukawa.yoshiki" creationdate="20170219T143951Z">
        <seg>このサンプルの場合、&lt;c4&gt;fetch&lt;/c4&gt;が完了したときにはまだサーバーからレスポンスが返ってきていないので、&lt;c5&gt;Data.todos.list&lt;/c5&gt;に格納されているオリジナルの空の配列を使って表示を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it waits half a second, giving the exit animation the exact time it needs to complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110530Z" creationid="shibukawa.yoshiki" creationdate="20170206T110530Z">
        <seg>このサンプルでは、終了時のアニメーションが完了するのとちょうど同じ時間である0.5秒待っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route &lt;c0&gt;"/dashboard/johndoe"&lt;/c0&gt; and, under the hood, it calls &lt;c1&gt;m.mount(document.body, dashboard)&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140257Z" creationid="shibukawa.yoshiki" creationdate="20150502T140257Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの&lt;c0&gt;"/dashboard/johndoe"&lt;/c0&gt;にリダイレクトして、フレームワーク内で&lt;c1&gt;m.mount(document.body, dashboard)&lt;/c1&gt;が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route &lt;c0&gt;"/dashboard/johndoe"&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153557Z" creationid="shibukawa.yoshiki" creationdate="20150414T153557Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの&lt;c0&gt;"/dashboard/johndoe"&lt;/c0&gt;にリダイレクトされます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the callback assigns the &lt;c2&gt;result.data&lt;/c2&gt; array to &lt;c3&gt;User.list&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T120849Z" creationid="shibukawa.yoshiki" creationdate="20170220T120849Z">
        <seg>この場合、このコールバックは&lt;c2&gt;result.data&lt;/c2&gt;の配列を&lt;c3&gt;User.list&lt;/c3&gt;に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, we're using them in a way that resembles C pointers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152219Z" creationid="shibukawa.yoshiki" creationdate="20150408T152219Z">
        <seg>上記の例の場合は、Cのポインタのような機能を実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this iteration, both the &lt;c0&gt;ContactForm&lt;/c0&gt; and &lt;c1&gt;ContactList&lt;/c1&gt; components are now children of the &lt;c2&gt;ContactsWidget&lt;/c2&gt; component and they appear simultaneously on the same page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020806Z" creationid="shibukawa.yoshiki" creationdate="20150502T020806Z">
        <seg>ここでは、&lt;c0&gt;ContactForm&lt;/c0&gt;コンポーネントと&lt;c1&gt;ContactList&lt;/c1&gt;コンポーネントは&lt;c2&gt;ContactsWidget&lt;/c2&gt;コンポーネントの子供になっていて、どちらも同じページ内で表示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this sense, one could argue that Mithril isn't really a framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T142604Z" creationid="shibukawa.yoshiki" creationdate="20150417T142604Z">
        <seg>この意味では、Mithrilは本当はフレームワークではないと言われる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases, you can call &lt;a0&gt;&lt;c1&gt;m.redraw&lt;/c1&gt;&lt;/a0&gt; instead of using m.startComputation/m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135913Z" creationid="shibukawa.yoshiki" creationdate="20150415T135913Z">
        <seg>この場合は、m.startComputation/m.endComputationを呼ぶ代わりに、&lt;a0&gt;&lt;c1&gt;m.redraw&lt;/c1&gt;&lt;/a0&gt;を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases, you must manually call &lt;a3&gt;&lt;c4&gt;m.redraw()&lt;/c4&gt;&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121421Z" creationid="shibukawa.yoshiki" creationdate="20170206T121421Z">
        <seg>この場合は、手動で&lt;a3&gt;&lt;c4&gt;m.redraw()&lt;/c4&gt;&lt;/a3&gt;を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In traditional server-side frameworks, the controller layer is of large significance because the nature of HTTP requests, responses and the framework abstractions that are exposed to developers require that the controller act as an adapter layer to transform the serialized data from HTTP requests to something that can be passed to ORM model methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002057Z" creationid="shibukawa.yoshiki" creationdate="20150408T002057Z">
        <seg>伝統的なサーバーサイドフレームワークでは、HTTPのリクエスト、レスポンスおよび、開発者に公開されているフレームワークの抽象化という性質を考えると、コントローラレイヤはとても大きな役割を持つレイヤです。コントローラはHTTPのリクエストからシリアライズされたデータを取り出して変換して、ORMのモデルのメソッドに渡したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In typical scenarios, streaming won't provide noticeable performance benefits because it's generally not advisable to download megabytes of data to begin with.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034219Z" creationid="shibukawa.yoshiki" creationdate="20170220T034219Z">
        <seg>しかし、メガバイトの単位のデータをダウンロードしない限りは、一般的な用途ではストリーミングのメリットが目に見えることはほぼありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In v0.2.x it was possible to force mithril to redraw immediately by passing a truthy value to &lt;c0&gt;m.redraw()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121220Z" creationid="shibukawa.yoshiki" creationdate="20170131T121220Z">
        <seg>v0.2.xでは、&lt;c0&gt;m.redraw()&lt;/c0&gt;にtrueを渡すことで即座にMithrilに再描画を行わせることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In v0.2.x, Mithril allowed 'redraw locks' which temporarily prevented blocked draw logic: by default, &lt;c0&gt;m.request&lt;/c0&gt; would lock the draw loop on execution and unlock when all pending requests had resolved - the same behaviour could be invoked manually using &lt;c1&gt;m.startComputation()&lt;/c1&gt; and &lt;c2&gt;m.endComputation()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120421Z" creationid="shibukawa.yoshiki" creationdate="20170131T120421Z">
        <seg>v0.2.xでは、Mithrilはデフォルトで一時的な描画ロジックのブロックを行っていました。&lt;c0&gt;m.request()&lt;/c0&gt;は実行時に描画ループをロックし、すべての大気中のリクエストが完了したときにアンロックしていました。同様のことは手動で&lt;c1&gt;m.startComputation()&lt;/c1&gt;と&lt;c2&gt;m.endComputation()&lt;/c2&gt;を呼び出すことで実現できました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140627Z" creationid="shibukawa.yoshiki" creationdate="20150407T140627Z">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164330Z" creationid="shibukawa.yoshiki" creationdate="20150407T164330Z">
        <seg>インストール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T144428Z" creationid="shibukawa.yoshiki" creationdate="20160101T144428Z">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of copying arguments to the controller object and then passing the controller object to the view (thereby creating internal state in the component), it is often desirable that views update based on the current value of arguments initially passed to a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081032Z" creationid="shibukawa.yoshiki" creationdate="20150502T081032Z">
        <seg>コントローラオブジェクトに引数を渡して、コントローラオブジェクトからビューに渡すという実装の場合はコンポーネントの内部状態ができてしまいます。初期化時に渡される引数にもとづいてビューを更新するほうが望ましい場面が多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of locking developers down to very specific implementations of design patterns, Mithril's approach is to provide an idiomatic pattern to follow, and tools to aid the developer when required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144352Z" creationid="shibukawa.yoshiki" creationdate="20150417T144352Z">
        <seg>決まった設計のパターンでプログラマを拘束して、画一化された実装をさせるのではなく、Mithrilは従うべきイディオムのパターンを提供し、必要であればツールを提供するというアプローチをとっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of mapping a component to a route, you can specify a RouteResolver object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064702Z" creationid="shibukawa.yoshiki" creationdate="20170208T064702Z">
        <seg>コンポーネントをラウトにマッピングする代わりに、ラウトリゾルバーオブジェクトを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead you should explicitly call &lt;c2&gt;m.route.set&lt;/c2&gt; when the expected conditions are met.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T143830Z" creationid="shibukawa.yoshiki" creationdate="20170131T143830Z">
        <seg>その代わりに、中断条件にマッチしたときは&lt;c2&gt;m.route.set&lt;/c2&gt;を呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Mithril relies on &lt;c1&gt;m.startComputation&lt;/c1&gt; and &lt;c2&gt;m.endComputation&lt;/c2&gt; calls to figure out when to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154046Z" creationid="shibukawa.yoshiki" creationdate="20150416T154046Z">
        <seg>Mithrilは再描画のタイミングを、&lt;c1&gt;m.startComputation&lt;/c1&gt;と&lt;c2&gt;m.endComputation&lt;/c2&gt;の呼び出しで決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Mithril's redrawing system relies on &lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt; and &lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134021Z" creationid="shibukawa.yoshiki" creationdate="20150414T134021Z">
        <seg>Mithrilの再描画システムは、&lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt;と&lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt;の呼び出しをトリガーとして実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it's composed of &lt;a0&gt;pure functions&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080644Z" creationid="shibukawa.yoshiki" creationdate="20150502T080644Z">
        <seg>実際には、&lt;a0&gt;純粋関数&lt;/a0&gt;の集合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, let's split the code into &lt;e0&gt;modules&lt;/e0&gt;, and assemble these modules into a &lt;e1&gt;bundle&lt;/e1&gt; &lt;c2&gt;bin/app.js&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071046Z" creationid="shibukawa.yoshiki" creationdate="20170207T071046Z">
        <seg>コードを複数の&lt;e0&gt;モジュール&lt;/e0&gt;に分割し、それらのモジュールから&lt;c2&gt;bin/app.js&lt;/c2&gt;という名前の&lt;e1&gt;バンドル&lt;/e1&gt; を作成するようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, redraws are always triggered when a request promise chain completes (unless &lt;c2&gt;background:true&lt;/c2&gt; is set).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045410Z" creationid="shibukawa.yoshiki" creationdate="20170201T045410Z">
        <seg>これらはサポートされませんが、Promiseのチェーンが完了するときには、&lt;c2&gt;background:true&lt;/c2&gt;がセットされていない時は再描画が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, routing in Single Page Applications retains the same HTML file throughout its lifetime, but changes the state of the application via Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T052639Z" creationid="shibukawa.yoshiki" creationdate="20170221T052639Z">
        <seg>シングルページアプリケーションのラウティングを使うと、同じHTMLファイルがブラウザを閉じられるまで継続して使われますが、JavaScriptを使ってアプリケーションの状態が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T003701Z" creationid="shibukawa.yoshiki" creationdate="20150412T003701Z">
        <seg>複数実行スレッドの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads can be done in a two different ways: in a layered fashion or in comprehensive fashion</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155947Z" creationid="shibukawa.yoshiki" creationdate="20150416T155947Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads can be done in two different ways: in a layered fashion or in comprehensive fashion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004835Z" creationid="shibukawa.yoshiki" creationdate="20150412T004835Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating to legacy code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140345Z" creationid="shibukawa.yoshiki" creationdate="20150412T140345Z">
        <seg>レガシーコードとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating to the Mithril redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014919Z" creationid="shibukawa.yoshiki" creationdate="20150415T014919Z">
        <seg>Mithrilの再描画システムへの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with Other Libraries</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140911Z" creationid="shibukawa.yoshiki" creationdate="20150407T140911Z">
        <seg>他のライブラリとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with Other Libraries - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013529Z" creationid="shibukawa.yoshiki" creationdate="20150412T013529Z">
        <seg>他のライブラリとの統合 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with The Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192317Z" creationid="shibukawa.yoshiki" creationdate="20150411T192317Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with the Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015846Z" creationid="shibukawa.yoshiki" creationdate="20150409T015846Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integration with third party libraries or vanilla javascript code can be achieved via the &lt;a0&gt;&lt;c1&gt;config&lt;/c1&gt; attribute of virtual elements&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013900Z" creationid="shibukawa.yoshiki" creationdate="20150412T013900Z">
        <seg>サードパーティライブラリや、pure JavaScriptのコードと統合するには&lt;a0&gt;、仮想エレメントの&lt;c1&gt;config&lt;/c1&gt;属性&lt;/a0&gt;を使って行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intelligent auto-redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134217Z" creationid="shibukawa.yoshiki" creationdate="20150407T134217Z">
        <seg>インテリジェントな自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Mithril keeps a virtual representation of the DOM in cache, scans for changes, and then only modifies the absolute minimum required to apply the change to the DOM. In practice, this results in surprisingly fast re-rendering.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015608Z" creationid="shibukawa.yoshiki" creationdate="20150408T015608Z">
        <seg>Mitril内部では、仮想的に表現されたDOMをキャッシュとして持っていて、変更を検知して変更に必要な最小限の更新だけどDOMに対して行います。そのため、極めて高速に再レンダリングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Mithril uses this data representation of the DOM to probe for data changes and update the DOM only where necessary.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072523Z" creationid="shibukawa.yoshiki" creationdate="20150502T072523Z">
        <seg>内部的にMithrilはこのDOMのデータ構造を使用して、データの変更を検知し、必要なところだけDOMを更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet Explorer 8 lacks native support for some of these features.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014525Z" creationid="shibukawa.yoshiki" creationdate="20150417T014525Z">
        <seg>Internet Explorer 8では、これらの機能のうちのいくつかが使えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet Explorer Compatibility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014414Z" creationid="shibukawa.yoshiki" creationdate="20150417T014414Z">
        <seg>Internet Explorerの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolations are ignored if no matching data exists in the &lt;c0&gt;data&lt;/c0&gt; property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152436Z" creationid="shibukawa.yoshiki" creationdate="20170219T152232Z">
        <seg>I&lt;c0&gt;data&lt;/c0&gt;プロパティにマッチするデータがなければ、変数は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024555Z" creationid="shibukawa.yoshiki" creationdate="20170131T024555Z">
        <seg>イントロダクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows us to iterate over the list and merge transformed versions of the list items into an output array.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153155Z" creationid="shibukawa.yoshiki" creationdate="20150408T153155Z">
        <seg>このメソッドを使うと、配列の全要素に対して変換処理を行い、その結果の要素で構成される配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also causes page refreshes in IE8.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005455Z" creationid="shibukawa.yoshiki" creationdate="20150410T005455Z">
        <seg>このモードも、IE8でページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It always causes page refreshes in IE8.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170121Z" creationid="shibukawa.yoshiki" creationdate="20150414T170121Z">
        <seg>IE8上では、常にページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be one of three values:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152254Z" creationid="shibukawa.yoshiki" creationdate="20150416T152254Z">
        <seg>これには次の3つの値のうちの1つを設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used in conjunction with &lt;a0&gt;&lt;c1&gt;m.withAttr&lt;/c1&gt;&lt;/a0&gt; to implement data binding in the view-to-model direction and to provide uniform data access for model entity properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134502Z" creationid="shibukawa.yoshiki" creationdate="20150414T134502Z">
        <seg>この関数を&lt;a0&gt;&lt;c1&gt;m.withAttr&lt;/c1&gt;&lt;/a0&gt;と一緒に使うことで、ビューとモデル間のデータバインディングを作成し、モデルエンティティのプロパティのデータアクセス方法を平準化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to run logic before a component initializes (for example authentication logic, data preloading, redirection analytics tracking, etc)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085252Z" creationid="shibukawa.yoshiki" creationdate="20170207T085252Z">
        <seg>これはコンポーネントの初期化前位にロジックを実行することができます。例えば認証ロジックはデータのプリロード、リダイレクト分析とかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to store instances of 3rd party classes that need to be accessed more than one time throughout the lifecycle of a page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155420Z" creationid="shibukawa.yoshiki" creationdate="20150413T155420Z">
        <seg>このオブジェクトはページのライフサイクルを通じて何度もアクセスする必要がある、サードパーティのクラスのインスタンスを保持するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can call model methods directly or from methods inside the resulting object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061620Z" creationid="shibukawa.yoshiki" creationdate="20150502T061620Z">
        <seg>オブジェクトから、モデルのメソッドを直接呼び出したり、あるいはオブジェクトのメソッド内部から呼び出すことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can contain methods meant to be called by a &lt;c0&gt;view&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061539Z" creationid="shibukawa.yoshiki" creationdate="20150502T061539Z">
        <seg>&lt;c0&gt;view&lt;/c0&gt;と呼ばれるメソッドを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can hold a reference to a view model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061819Z" creationid="shibukawa.yoshiki" creationdate="20150502T061819Z">
        <seg>ビューモデルへの参照を持つことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can store contextual data returned from model methods (i.e. a &lt;a0&gt;promise&lt;/a0&gt; from a &lt;a1&gt;request&lt;/a1&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061807Z" creationid="shibukawa.yoshiki" creationdate="20150502T061807Z">
        <seg>&lt;a1&gt;request&lt;/a1&gt;が返す&lt;a0&gt;promise&lt;/a0&gt;などのモデルメソッドが返すデータを保持することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot return that data directly because an HTTP request may take a long time to complete (due to network latency), and if Javascript waited for it, it would freeze the application until the data was available.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034524Z" creationid="shibukawa.yoshiki" creationdate="20170220T034524Z">
        <seg>HTTP要求が完了するまでに長い時間待ちがかかることがあるため（ネットワーク待ち時間のため）、データを直接返すことはできません。また、JavaScript上で同期待ちをおkナウと、データが利用可能になるまでアプリケーションがフリーズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains &lt;c1&gt;controller&lt;/c1&gt; and &lt;c2&gt;view&lt;/c2&gt; properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003534Z" creationid="shibukawa.yoshiki" creationdate="20150410T003534Z">
        <seg>モジュールは&lt;c1&gt;controller&lt;/c1&gt;プロパティと&lt;c2&gt;view&lt;/c2&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains a &lt;c1&gt;controller&lt;/c1&gt; and a &lt;c2&gt;view&lt;/c2&gt; properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153622Z" creationid="shibukawa.yoshiki" creationdate="20150414T153622Z">
        <seg>モジュールは&lt;c1&gt;controller&lt;/c1&gt;プロパティと&lt;c2&gt;view&lt;/c2&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not, however, de-dupe classes if the same class is declared twice.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153331Z" creationid="shibukawa.yoshiki" creationdate="20150413T153331Z">
        <seg>ただし、同じクラスが2度宣言されていたら、重複は取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this because people expect unexpected errors like null reference exceptions to be thrown to the console for debugging purposes, and these errors are always subclasses of Error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174459Z" creationid="shibukawa.yoshiki" creationdate="20150415T174459Z">
        <seg>Mithrilがこのような動作をするのは、多くのプログラマにとって、null参照例外などの未知の例外はデバッグのためにコンソールに出力される方がうれしいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enables seamless navigability while preserving the ability to bookmark each page individually, and the ability to navigate the application via the browser's history mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020245Z" creationid="shibukawa.yoshiki" creationdate="20150409T020245Z">
        <seg>この機能を使うと、各ページをブックマークしたり、ブラウザの履歴の機能はそのままに、シームレスなナビゲーションが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes a &lt;c0&gt;promise&lt;/c0&gt; property which can &lt;e1&gt;bind&lt;/e1&gt; callbacks to build a computation tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133727Z" creationid="shibukawa.yoshiki" creationdate="20150415T133512Z">
        <seg>deferredは、コールバックを&lt;e1&gt;バインド&lt;/e1&gt;して、グラフ構造の計算木を構築するのに使える&lt;c0&gt;promise&lt;/c0&gt;プロパティを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes an event called &lt;c2&gt;onsave&lt;/c2&gt; which is fired when the Save button is pressed on the form.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002029Z" creationid="shibukawa.yoshiki" creationdate="20150502T002029Z">
        <seg>このモジュールは、フォーム上の保存ボタンが押された時に起動される&lt;c2&gt;onsave&lt;/c2&gt;イベントを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a method &lt;c5&gt;then&lt;/c5&gt; which takes a &lt;c6&gt;successCallback&lt;/c6&gt; and a &lt;c7&gt;errorCallback&lt;/c7&gt; callbacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134220Z" creationid="shibukawa.yoshiki" creationdate="20150415T134220Z">
        <seg>このプロパティは、&lt;c6&gt;successCallback&lt;/c6&gt;コールバックと、&lt;c7&gt;errorCallback&lt;/c7&gt;コールバックを受け取る、&lt;c5&gt;then&lt;/c5&gt;メソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It includes support for the &lt;a0&gt;MSX&lt;/a0&gt; HTML templating syntax from Jonathan Buchanan.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000150Z" creationid="shibukawa.yoshiki" creationdate="20150408T000150Z">
        <seg>これは、Jonathan Buchananが作成した、HTMLテンプレートの文法の&lt;a0&gt;MSX&lt;/a0&gt;も含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called once per router path changes, but not on subsequent redraws while on the same path.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085156Z" creationid="shibukawa.yoshiki" creationdate="20170207T085156Z">
        <seg>これはラウターのパスが一回変更されるたびに呼ばれます。ただし、同じパスに対して再帰的に子要素が呼び出されて行われる再描画では呼びされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is expected that such an error would bubble up to the console and display a developer-friendly error message and line number there.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172954Z" creationid="shibukawa.yoshiki" creationdate="20150415T172954Z">
        <seg>このようなエラーに対しては、例外が発生したときにエラーメッセージと行番号をコンソールに表示する方が開発者にやさしいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is modified internally by Mithril to the value &lt;c0&gt;"all"&lt;/c0&gt; before running controller constructors, and to the value &lt;c1&gt;"diff"&lt;/c1&gt; after all redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152628Z" creationid="shibukawa.yoshiki" creationdate="20150416T152628Z">
        <seg>コントローラの構築が行われると、Mithrilは内部的にこのフラグを&lt;c0&gt;"all"&lt;/c0&gt;に設定し、再描画が行われると&lt;c1&gt;"diff"&lt;/c1&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is no longer possible to prevent unmounting via &lt;c0&gt;onunload&lt;/c0&gt;'s &lt;c1&gt;e.preventDefault()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T143657Z" creationid="shibukawa.yoshiki" creationdate="20170131T143657Z">
        <seg>&lt;c0&gt;onunload&lt;/c0&gt;の&lt;c1&gt;e.preventDefault()&lt;/c1&gt;を使ってアンマウントを中断させることはもうできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not a full MVC framework, but it is similar to Angular templates, and uses the same terminology for its features (e.g. directives and filters).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110014Z" creationid="shibukawa.yoshiki" creationdate="20150420T110014Z">
        <seg>これは完全なMVCフレームワークではありませんが、Angularのテンプレートと似ています。ディレクティブやフィルタなど、機能に対して同じ用語を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not an MVC framework in the traditional sense, but idiomatic Knockout code uses the similar concept of view models.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105504Z" creationid="shibukawa.yoshiki" creationdate="20150420T105504Z">
        <seg>これは伝統的な意味でのMVCフレームワークではありませんが、Knockoutが推奨しているスタイルに従ったコードは、ビュー・モデルと似たコンセプトを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is similar to the &lt;c1&gt;view&lt;/c1&gt; method in components and it exists to simplify &lt;a2&gt;component composition&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090826Z" creationid="shibukawa.yoshiki" creationdate="20170207T090826Z">
        <seg>これはコンポーネントの&lt;c1&gt;view&lt;/c1&gt;メソッドに似ていますが、&lt;a2&gt;コンポーネント合成&lt;/a2&gt;をシンプルにおこなうために存在しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended that you always set this option to avoid future surprises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012549Z" creationid="shibukawa.yoshiki" creationdate="20150415T012549Z">
        <seg>このオプションは将来落とし穴に落ちないように設定することを強く勧めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the developer's responsibility to ensure the input to &lt;c0&gt;m.trust&lt;/c0&gt; cannot be maliciously modified by user-entered data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015328Z" creationid="shibukawa.yoshiki" creationdate="20150416T015328Z">
        <seg>悪意をもってユーザが入力したデータを&lt;c0&gt;m.trust&lt;/c0&gt;に通す責任は開発者にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful for injecting a mock &lt;c1&gt;window&lt;/c1&gt; dependency for the purposes of testing and for running Mithril in non-browser environments.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160736Z" creationid="shibukawa.yoshiki" creationdate="20150416T160736Z">
        <seg>このカンスを使うと、モックの&lt;c1&gt;window&lt;/c1&gt;の依存性を注入できます。非ブラウザ環境でテストしたり、Mithrilを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful for teams where styling and functionality are done by different people, and for those who prefer to maintain templates in HTML syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013844Z" creationid="shibukawa.yoshiki" creationdate="20150417T013844Z">
        <seg>このツールは、スタイリングと機能の実装が異なるチームで行われていて、テンプレートのメンテナンスにHTML文法が使いたい場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It leverages developer experience with server-side MVC frameworks, and in many ways, is very similar in scope to Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025052Z" creationid="shibukawa.yoshiki" creationdate="20150420T025052Z">
        <seg>サーバサイドのMVCフレームワークのある人がすぐに使いこなせるように作られている点など、多くの面でMithrilと非常に似通っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be useful to inspect a server response in more detail, this can be accomplished by passing a custom &lt;c1&gt;options.extract&lt;/c1&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005915Z" creationid="shibukawa.yoshiki" creationdate="20170220T005915Z">
        <seg>カスタムの&lt;c1&gt;options.extract&lt;/c1&gt;関数をオプションで渡すことで、サーバーのレスポンスの詳細を知ることができるます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may differ from the path displayed in the location bar while an asynchronous route is &lt;a0&gt;pending resolution&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082545Z" creationid="shibukawa.yoshiki" creationdate="20170207T082545Z">
        <seg>非同期で&lt;a0&gt;解決が遅延&lt;/a0&gt;されている時は、ブラウザのロケーションバーに表示されているパスと異なることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may sound expensive to recompute an entire view any time there's a change to be displayed, but this operation actually turns out to be quite fast, compared to rendering strategies used by older frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074725Z" creationid="shibukawa.yoshiki" creationdate="20150502T074725Z">
        <seg>一見、変更を表示するたびに、このビュー全体に対する再計算を行うのは高コストな処理に見えるかもしれませんが、以前からあったフレームワークが使うレンダリングの方法論に比べると極めて高速です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It pre-processes the &lt;c0&gt;m()&lt;/c0&gt; call and replaces it with its output:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145827Z" creationid="shibukawa.yoshiki" creationdate="20150412T145827Z">
        <seg>このマクロは&lt;c0&gt;m()&lt;/c0&gt;関数の呼び出しを事前に処理してし次のような関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a number of useful features out of the box:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014234Z" creationid="shibukawa.yoshiki" creationdate="20150410T014234Z">
        <seg>提供される便利な機能には次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a templating engine with a virtual DOM diff implementation for performant rendering, utilities for high-level modelling via functional composition, as well as support for routing and componentization.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141605Z" creationid="shibukawa.yoshiki" creationdate="20150407T141605Z">
        <seg>Mithrilは、ハイパフォーマンスなレンダリング速度を持つ、仮想DOMの差分更新機能を持ったテンプレートエンジンや、関数型によるハイレベルなモデリングのサポート、ルーティング機能、コンポーネント化をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides full Turing completeness: full control over evaluation eagerness/laziness and caching in templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021616Z" creationid="shibukawa.yoshiki" creationdate="20150409T021616Z">
        <seg>Mithrilのテンプレートはチューリング完全です。先行評価と遅延評価を完全に制御できますし、テンプレートのキャッシュも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a function that stores information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133846Z" creationid="shibukawa.yoshiki" creationdate="20150414T133846Z">
        <seg>この関数は、情報を保持する関数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a method that can be bound to a DOM element's event listener.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140211Z" creationid="shibukawa.yoshiki" creationdate="20150414T140211Z">
        <seg>この関数は、DOMエレメントのイベントリスナとして使えるメソッドを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be set before any calls to &lt;c1&gt;m.route&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140316Z" creationid="shibukawa.yoshiki" creationdate="20160101T140316Z">
        <seg>これは必ず&lt;c1&gt;m.route&lt;/c1&gt;呼び出しよりも先に設定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It'll cover the majority of the API surface (including routing and XHR) but it'll only take 10 minutes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025452Z" creationid="shibukawa.yoshiki" creationdate="20170131T025452Z">
        <seg>このチュートリアルはラウティングやXHRも含めて、主要なAPIを紹介しますが、10分程度しかかかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good idea to wrap exception-prone code in a &lt;c2&gt;try&lt;/c2&gt; block and call &lt;c3&gt;m.endComputation&lt;/c3&gt; from within the respective &lt;c4&gt;finally&lt;/c4&gt; block, in order to prevent rendering from halting.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153521Z" creationid="shibukawa.yoshiki" creationdate="20150416T153521Z">
        <seg>例外が発生する可能性のあるコードを&lt;c2&gt;try&lt;/c2&gt;ブロックで囲み、対応する&lt;c3&gt;m.endComputation&lt;/c3&gt;を&lt;c4&gt;finally&lt;/c4&gt;ブロック内で呼ぶようにすると、再描画システムが停止することを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good practice to always use the idiom above, instead of hardcoding &lt;c1&gt;?&lt;/c1&gt; or &lt;c2&gt;#&lt;/c2&gt; in the href attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013514Z" creationid="shibukawa.yoshiki" creationdate="20150410T013514Z">
        <seg>href属性の中に&lt;c1&gt;?&lt;/c1&gt;や&lt;c2&gt;#&lt;/c2&gt;をハードコードするのではなく、常に上記のようなイディオムを使うのが良いプラクティスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good practice to make components stateless because they are more predictable, and easier to reason about, test and troubleshoot.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080824Z" creationid="shibukawa.yoshiki" creationdate="20150502T080824Z">
        <seg>コンポーネントをステートレスにすると、挙動が予測しやすくなり、テストやトラブルシューティングがやりやすくなるため、良いプラクティスと言えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a modified version of the Thenable API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015847Z" creationid="shibukawa.yoshiki" creationdate="20150415T015847Z">
        <seg>これはthenable APIのカスタム版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to have variadic routes, i.e. a route with an argument that contains URL pathnames that contain slashes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061435Z" creationid="shibukawa.yoshiki" creationdate="20170208T061435Z">
        <seg>可変個引数をもったラウトを作ることもできます。例えば、スラッシュを含むURLのパス名を引数に取るラウトなどを実現することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to modify the strategy that Mithril uses for any given redraw, by using &lt;a0&gt;&lt;c1&gt;m.redraw.strategy&lt;/c1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155613Z" creationid="shibukawa.yoshiki" creationdate="20150416T155613Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.redraw.strategy&lt;/c1&gt;&lt;/a0&gt;を使うと、任意で行う再描画の戦略を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to set values to Javascript-only properties, such as &lt;c0&gt;hash&lt;/c0&gt; in a &lt;c1&gt;&lt;a&gt;&lt;/c1&gt; element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154808Z" creationid="shibukawa.yoshiki" creationdate="20150413T154808Z">
        <seg>&lt;c1&gt;&lt;a&gt;&lt;/c1&gt;エレメントの&lt;c0&gt;hash&lt;/c0&gt;属性のように、JavaScriptだけで使用できるプロパティの値も設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also recommended that you avoid the &lt;c0&gt;box-shadow&lt;/c0&gt; rule and selectors like &lt;c1&gt;:nth-child&lt;/c1&gt;, since these are also resource intensive options.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111601Z" creationid="shibukawa.yoshiki" creationdate="20170206T111601Z">
        <seg>また、&lt;c0&gt;box-shadow&lt;/c0&gt;ルールや、&lt;c1&gt;:nth-child&lt;/c1&gt;などのセレクターを使うとパフォーマンスに大きな影響があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's automatically placed in the appropriate section of the request with the appropriate serialization based on &lt;c0&gt;method&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002503Z" creationid="shibukawa.yoshiki" creationdate="20150415T002503Z">
        <seg>設定されている&lt;c0&gt;method&lt;/c0&gt;によって、適切な方法でシリアライズされて、適切なペイロードに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's of course possible to use both aggregation of responsibility and the observer pattern at the same time.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113528Z" creationid="shibukawa.yoshiki" creationdate="20150502T030529Z">
        <seg>もちろん、責務の統合と、オブザーバパターンを同時に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often desirable to wrap all or most of the routed components in a reusable shell (often called a "layout").</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T065716Z" creationid="shibukawa.yoshiki" creationdate="20170208T065716Z">
        <seg>ラウトで選択されるコンポーネントであっても、レイアウトと呼ばれる再利用可能な枠組みでラップして使われることがよくあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often said that &lt;e0&gt;frameworks&lt;/e0&gt;, in contrast to &lt;e1&gt;libraries&lt;/e1&gt;, dictate how code should be written.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T112534Z" creationid="shibukawa.yoshiki" creationdate="20150417T142540Z">
        <seg>よく言われることは、&lt;e1&gt;ライブラリ&lt;/e1&gt;と異なり、&lt;e0&gt;フレームワーク&lt;/e0&gt;はどのようにコーディングをするかを指示してくるものであると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's perfectly valid to define controllers and views separately, and only bring them together when mounting them:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071547Z" creationid="shibukawa.yoshiki" creationdate="20150502T071547Z">
        <seg>コントローラとビューを分割して定義しても問題ありません。マウントするときに統合することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to auto-cast a JSON response to a class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130512Z" creationid="shibukawa.yoshiki" creationdate="20150410T130512Z">
        <seg>JSON表現をクラスに自動変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to configure this string it via &lt;a1&gt;&lt;c2&gt;m.route.prefix&lt;/c2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115825Z" creationid="shibukawa.yoshiki" creationdate="20170221T115825Z">
        <seg>この文字列は&lt;a1&gt;&lt;c2&gt;m.route.prefix&lt;/c2&gt;&lt;/a1&gt;を使って設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to defer a redraw by calling &lt;c0&gt;m.request&lt;/c0&gt; or by manually nesting &lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt; and &lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt; contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185615Z" creationid="shibukawa.yoshiki" creationdate="20150411T185615Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;を呼び出したり、&lt;a1&gt;&lt;c2&gt;m.startComputation&lt;/c2&gt;と&lt;c3&gt;m.endComputation&lt;/c3&gt;&lt;/a1&gt;のコンテキストをネストすることで、 再描画を遅らせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to have multiple arguments in a route, for example &lt;c0&gt;/edit/:projectID/:userID&lt;/c0&gt; would yield the properties &lt;c1&gt;projectID&lt;/c1&gt; and &lt;c2&gt;userID&lt;/c2&gt; on the component's vnode attributes object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054207Z" creationid="shibukawa.yoshiki" creationdate="20170208T054207Z">
        <seg>&lt;c0&gt;/edit/:projectID/:userID&lt;/c0&gt;のように、複数の引数をラウトに持たせることができます。これらの引数も、コンポーネントのvnode属性オブジェクトの&lt;c1&gt;projectID&lt;/c1&gt;、&lt;c2&gt;userID&lt;/c2&gt;プロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to opt out of the redrawing schedule by using the &lt;c0&gt;background&lt;/c0&gt; option for &lt;c1&gt;m.request&lt;/c1&gt;, or by simply not calling &lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt; when calling non-Mithril asynchronous functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155241Z" creationid="shibukawa.yoshiki" creationdate="20150416T155143Z">
        <seg>&lt;c1&gt;m.request&lt;/c1&gt;の&lt;c0&gt;background&lt;/c0&gt;オプションを使用したり、Mithril外の非同期関数を呼ぶ時は単に&lt;c2&gt;m.startComputation&lt;/c2&gt; / &lt;c3&gt;m.endComputation&lt;/c3&gt;の呼び出しをしなければ再描画のスケジューリングをやめ、再描画が積極的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to take full advantage of the underlying &lt;c0&gt;history.pushState&lt;/c0&gt; API to improve user's navigation experience.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061552Z" creationid="shibukawa.yoshiki" creationdate="20170208T061552Z">
        <seg>ユーザのナビゲーションの使いやすさを向上させるために、裏で動作している&lt;c0&gt;history.pushState&lt;/c0&gt; APIのすべての機能を使いこなせるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to upload multiple files in one request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160204Z" creationid="shibukawa.yoshiki" creationdate="20170219T160204Z">
        <seg>ひとつのリクエストで複数ファイルの同時アップロードも行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's recommended that you encapsulate integration code in a component or a helper function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013947Z" creationid="shibukawa.yoshiki" creationdate="20150412T013947Z">
        <seg>統合コードやヘルパー関数をコンポーネント内にカプセル化できるため、この方法が推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's recommended that you use the &lt;a1&gt;&lt;c2&gt;ctx.retain&lt;/c2&gt;&lt;/a1&gt; flag instead of changing the redraw strategy in controller constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095840Z" creationid="shibukawa.yoshiki" creationdate="20150502T095840Z">
        <seg>再描画の戦略を変更する代わりに、&lt;a1&gt;&lt;c2&gt;ctx.retain&lt;/c2&gt;&lt;/a1&gt;フラグを使うのを推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's relevant for comparison because it uses the same architecture as Mithril's templating engine: i.e. it acknowledges that DOM operations are the bottleneck of templating systems, and implements a virtual DOM tree which keeps track of changes and only applies diffs to the real DOM where needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095952Z" creationid="shibukawa.yoshiki" creationdate="20150420T095952Z">
        <seg>ReactはMithrilと似たようなアーキテクチャを持っています。DOM操作がテンプレートシステムのボトルネックであるという考えを共有し、仮想DOMツリーを持って差分だけを実際のDOMに反映するという実装を持っています。この比較はしやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's small (&lt; 8kb gzip), fast and provides routing and XHR utilities out of the box.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025037Z" creationid="shibukawa.yoshiki" creationdate="20170131T024951Z">
        <seg>サイズは小さく（&lt; 8kb gzip）高速で、ラウティングやXHRといったユーティリティもパッケージ内に内蔵しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's strongly recommended that you set an &lt;c0&gt;initialValue&lt;/c0&gt; option in ALL requests if you set the &lt;c1&gt;background&lt;/c1&gt; option to true.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134351Z" creationid="shibukawa.yoshiki" creationdate="20150502T134351Z">
        <seg>&lt;c1&gt;background&lt;/c1&gt;をtrueに設定するリクエストの「全ての」リクエストに対して&lt;c0&gt;initialValue&lt;/c0&gt;オプションを設定するのを強く推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the only mode in which routing changes do not cause page refreshes in any browser.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005153Z" creationid="shibukawa.yoshiki" creationdate="20150410T005153Z">
        <seg>このモードは唯一、どのブラウザでもページリフレッシュが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's useful for manipulating URLs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133306Z" creationid="shibukawa.yoshiki" creationdate="20170206T133306Z">
        <seg>これはURLを作成するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's worth mentioning that Mithril has built-in mechanisms elsewhere that take care of real bottlenecks like browser repaint management and DOM updating.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144619Z" creationid="shibukawa.yoshiki" creationdate="20150412T144619Z">
        <seg>Mithrilでは、ブラウザの再描画の管理やDOMの更新などの、本物のボトルネック以外をあまり気にする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's worth noting that the execution points listed above are commonly used for security attacks in combination with malformed markup, e.g. strings with mismatched attribute quotes like &lt;c0&gt;" onload="alert(1)&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015120Z" creationid="shibukawa.yoshiki" creationdate="20150416T015120Z">
        <seg>このような実行ポイントを羅列することは、malformed(奇形)なタグと&lt;c0&gt;" onload="alert(1)&lt;/c0&gt;のようなクオートが揃ってない属性文字列の組み合わせによる攻撃に対しては意味がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's your responsibility to make sure single iterations of animation rendering code don't take longer than 16ms (for a frequency of 60 frames-per-second).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020637Z" creationid="shibukawa.yoshiki" creationdate="20150421T020637Z">
        <seg>秒間60フレームを維持するために、この関数の単体の呼び出しのコストを16ミリ秒以下に抑えるのは開発者の責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its return value is used to diff against the previous virtual DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074544Z" creationid="shibukawa.yoshiki" creationdate="20150502T074544Z">
        <seg>この返り値は以前の仮想DOMのツリーに対する差分を検知するのに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its value can be set to either "search", "hash" or "pathname".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004833Z" creationid="shibukawa.yoshiki" creationdate="20150410T004833Z">
        <seg>このプロパティには、"search"、"hash"、"pathname"のいづれかの文字列を設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jordan Humphreys created a gem to allow integration with Rails:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000054Z" creationid="shibukawa.yoshiki" creationdate="20150408T000054Z">
        <seg>Jordan Humphreysが、Railsと統合できるようにするgemを作成しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just add an animation to a CSS class normally:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105517Z" creationid="shibukawa.yoshiki" creationdate="20170206T105517Z">
        <seg>CSSクラスにアニメーションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key concepts</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024726Z" creationid="shibukawa.yoshiki" creationdate="20170131T024726Z">
        <seg>重要なコンセプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054950Z" creationid="shibukawa.yoshiki" creationdate="20170208T054950Z">
        <seg>Keyパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024745Z" creationid="shibukawa.yoshiki" creationdate="20170131T024745Z">
        <seg>キー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys are expected to be absolute pathnames, but can include dynamic parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155928Z" creationid="shibukawa.yoshiki" creationdate="20150414T155928Z">
        <seg>キーは絶対パスを指定しますが、動的パラメータを含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys must be unique within a list of sibling DOM elements, and they must be either a string or a number:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080337Z" creationid="shibukawa.yoshiki" creationdate="20150502T080337Z">
        <seg>キーは兄弟のDOM要素の中でユニークである必要があります。キーの値は文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Knockout is a library focused on data binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105414Z" creationid="shibukawa.yoshiki" creationdate="20150420T105414Z">
        <seg>Knockoutはデータバインディングにフォーカスしたライブラリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lastly, be aware that if a user action triggers more than one event handler (for example, oninput and onkeypress, or an event bubbling up to event handlers in multiple ancestor elements), every event triggers a redraw by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151039Z" creationid="shibukawa.yoshiki" creationdate="20150416T151039Z">
        <seg>最後に、ユーザアクションがoninputとonkeypressなどの複数のイベントハンドラを起動したり、複数の祖先エレメントのイベントハンドラに対してバブリングした場合は、デフォルトではすべてのイベントが再描画を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Later in this guide, we'll pass the &lt;c0&gt;description&lt;/c0&gt; property as the parameter to this function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163419Z" creationid="shibukawa.yoshiki" creationdate="20150407T163419Z">
        <seg>このガイドの後半では、&lt;c0&gt;description&lt;/c0&gt;プロパティをこの関数の引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered integration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004902Z" creationid="shibukawa.yoshiki" creationdate="20150412T004844Z">
        <seg>階層に分けて統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered integration is recommended for modular code where many different APIs may be put together at the application level.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005008Z" creationid="shibukawa.yoshiki" creationdate="20150412T005008Z">
        <seg>たくさんのさまざまなAPIがアプリケーションレベルで使われている時は、階層に分けて統合する方法がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135632Z" creationid="shibukawa.yoshiki" creationdate="20150407T135632Z">
        <seg>Mithrilについて知る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn More</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015637Z" creationid="shibukawa.yoshiki" creationdate="20150409T015637Z">
        <seg>より詳しく学ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn the ropes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135552Z" creationid="shibukawa.yoshiki" creationdate="20150407T135552Z">
        <seg>コツを覚えましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add a splash page that appears before our click counter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031904Z" creationid="shibukawa.yoshiki" creationdate="20170131T031904Z">
        <seg>クリックカウンターの前に、スプラッシュページを追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add another route to our application for editing users.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120007Z" creationid="shibukawa.yoshiki" creationdate="20170221T120007Z">
        <seg>それではユーザーを編集するための別のラウトをアプリケーションに追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add routing to our application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T052218Z" creationid="shibukawa.yoshiki" creationdate="20170221T052218Z">
        <seg>ラウティングをアプリケーションに追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add some code to our &lt;c0&gt;User&lt;/c0&gt; model in &lt;c1&gt;src/models/User.js&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120848Z" creationid="shibukawa.yoshiki" creationdate="20170221T120848Z">
        <seg>&lt;c1&gt;src/models/User.js&lt;/c1&gt;に実装されている&lt;c0&gt;User&lt;/c0&gt;にいくつかコードを追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's assume making a request to the server URL &lt;c0&gt;/api/items&lt;/c0&gt; returns an array of objects in JSON format.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143321Z" creationid="shibukawa.yoshiki" creationdate="20170219T143321Z">
        <seg>サーバーURL&lt;c0&gt;/api/items&lt;/c0&gt;がJSONオブジェクトの配列を返すものとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's call it &lt;c0&gt;loadList&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055533Z" creationid="shibukawa.yoshiki" creationdate="20170220T055533Z">
        <seg>&lt;c0&gt;loadList&lt;/c0&gt;という名前にしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's change our click counter to make it save data on a server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T143533Z" creationid="shibukawa.yoshiki" creationdate="20170204T143533Z">
        <seg>クリックカウンターを修正して、サーバーにデータを保存できるようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040339Z" creationid="shibukawa.yoshiki" creationdate="20150502T040339Z">
        <seg>それではコンポーネントを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a file called &lt;c0&gt;src/models/User.js&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055327Z" creationid="shibukawa.yoshiki" creationdate="20170220T055327Z">
        <seg>&lt;c0&gt;src/models/User.js&lt;/c0&gt;という名前のファイルを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a simple model entity which we'll use in a simple application, to illustrate different usage patterns for components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T223633Z" creationid="shibukawa.yoshiki" creationdate="20150501T223633Z">
        <seg>まずはシンプルなモデルのエンティティを作ってみます。これはさまざまなコンポーネントの使用方法を説明するアプリケーションで使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create an &lt;c0&gt;exit&lt;/c0&gt; animation that fades &lt;c1&gt;opacity&lt;/c1&gt; from 1 to 0.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105816Z" creationid="shibukawa.yoshiki" creationdate="20170206T105816Z">
        <seg>それでは&lt;c1&gt;opacity&lt;/c1&gt;を1から0までフェードさせる&lt;c0&gt;exit&lt;/c0&gt;アニメーションを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create an HTML file to follow along:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025512Z" creationid="shibukawa.yoshiki" creationdate="20170131T025512Z">
        <seg>それでは次のようなHTMLファイルを作ってみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's develop a simple application that covers some of the major aspects of Single Page Applications</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000220Z" creationid="shibukawa.yoshiki" creationdate="20170205T000220Z">
        <seg>シングルページアプリケーションを構成する主要な要素をカバーするシンプルなアプリケーションを開発してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's implement a &lt;s0&gt;data binding&lt;/s0&gt; on the text input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014731Z" creationid="shibukawa.yoshiki" creationdate="20150408T014731Z">
        <seg>次に、テキスト入力に&lt;s0&gt;データバインディング&lt;/s0&gt;を実装していきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's implement the &lt;c0&gt;UserForm&lt;/c0&gt; component so that it can respond to those route parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120626Z" creationid="shibukawa.yoshiki" creationdate="20170221T120626Z">
        <seg>それではこれらのラウとパラメータを受け取れるように&lt;c0&gt;UserForm&lt;/c0&gt;コンポーネントを実装しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's render the view from the entry point file &lt;c0&gt;src/index.js&lt;/c0&gt; we created earlier:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T151234Z" creationid="shibukawa.yoshiki" creationdate="20170220T151234Z">
        <seg>それでは最初に作成したエントリーポイントのファイル&lt;c0&gt;src/index.js&lt;/c0&gt;からビューのレンダリングを行いましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's replace the event handler in the component to call the &lt;c0&gt;increment&lt;/c0&gt; function instead of incrementing the &lt;c1&gt;count&lt;/c1&gt; variable directly:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T152207Z" creationid="shibukawa.yoshiki" creationdate="20170204T152207Z">
        <seg>それではコンポーネントのイベントハンドラーを修正しましょう。今までは&lt;c1&gt;count&lt;/c1&gt;変数を直接扱っていましたが、&lt;c0&gt;increment&lt;/c0&gt;関数を代わりに呼びだします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's start as small as well can: render some text on screen.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025624Z" creationid="shibukawa.yoshiki" creationdate="20170131T025624Z">
        <seg>まずはなるべく小さなステップから始めましょう。スクリーンにテキストを表示してみます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's start by creating a module to store our state.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055315Z" creationid="shibukawa.yoshiki" creationdate="20170220T055315Z">
        <seg>状態を保存するモジュールを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's use &lt;c3&gt;m.request&lt;/c3&gt; to make an XHR request and populate our data with the response of that endpoint.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T060532Z" creationid="shibukawa.yoshiki" creationdate="20170220T060532Z">
        <seg>&lt;c3&gt;m.request&lt;/c3&gt;を使ってXHRのリクエストを行い、そのエンドポイントのレスポンスを取得しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's use Mithril hyperscript to create a list of items.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T122156Z" creationid="shibukawa.yoshiki" creationdate="20170220T122156Z">
        <seg>それでは、MithrilのHyperscriptを使って要素のリストを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's wrap our text in an &lt;c0&gt;&lt;h1&gt;&lt;/c0&gt; tag.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030000Z" creationid="shibukawa.yoshiki" creationdate="20170131T030000Z">
        <seg>次に、テキストを&lt;c0&gt;&lt;h1&gt;&lt;/c0&gt;タグでくくってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lifecycle methods</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024740Z" creationid="shibukawa.yoshiki" creationdate="20170131T024740Z">
        <seg>ライフサイクルメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Light-weight</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133256Z" creationid="shibukawa.yoshiki" creationdate="20150407T133256Z">
        <seg>軽量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, &lt;c4&gt;m.route(element, defaultRoute, routes)&lt;/c4&gt; accepted vnodes as values in the &lt;c5&gt;routes&lt;/c5&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T140450Z" creationid="shibukawa.yoshiki" creationdate="20170131T140450Z">
        <seg>また、&lt;c4&gt;m.route(element, defaultRoute, routes)&lt;/c4&gt;も&lt;c5&gt;routes&lt;/c5&gt;の値としてvnodeを受け入れることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, it intelligently waits for asynchronous services inside event handlers to complete before redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161700Z" creationid="shibukawa.yoshiki" creationdate="20150408T161700Z">
        <seg>同様に、このシステムはイベントハンドラ内部の非同期サービスについても、再描画前にきちんと完了することを賢く待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Limitations and caveats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050715Z" creationid="shibukawa.yoshiki" creationdate="20150502T050715Z">
        <seg>制限と制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Links to older versions can be found in the &lt;a0&gt;change log&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164634Z" creationid="shibukawa.yoshiki" creationdate="20150407T164634Z">
        <seg>&lt;a0&gt;変更履歴&lt;/a0&gt;のページ内に、古いバージョンへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linting is run (but doesn't fail build)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054229Z" creationid="shibukawa.yoshiki" creationdate="20170220T054229Z">
        <seg>Lintの実行（ただしビルドを失敗させません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loading</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135014Z" creationid="shibukawa.yoshiki" creationdate="20150407T135014Z">
        <seg>ロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loading data this way renders the component twice (once upon routing, and once after the request completes).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T080014Z" creationid="shibukawa.yoshiki" creationdate="20170208T080014Z">
        <seg>この方法でロードすると、コンポーネントはラウティング時と、リクエスト完了時の二回レンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loading icons and error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T144314Z" creationid="shibukawa.yoshiki" creationdate="20170219T144246Z">
        <seg>ローディングアイコンとエラーメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mailing List</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135718Z" creationid="shibukawa.yoshiki" creationdate="20150407T135718Z">
        <seg>メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure to add null checks if your request value can be null</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134806Z" creationid="shibukawa.yoshiki" creationdate="20150502T134806Z">
        <seg>リクエスト値がnullになる可能性がある場合は、nullチェックを行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Makes XHR (aka AJAX) requests, and returns a &lt;a0&gt;promise&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T090629Z" creationid="shibukawa.yoshiki" creationdate="20170208T090629Z">
        <seg>XHR (別名 AJAX) リクエストを行い、&lt;a0&gt;Promise&lt;/a0&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manually throwing an instance of the Error class itself (or any other objects or primitives) does trigger the rejection callback path as per the Promises/A+ spec.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172438Z" creationid="shibukawa.yoshiki" creationdate="20150415T141210Z">
        <seg>Promises/A+の仕様通りであれば、例外クラスそのもののインスタンス、もしくは何らかのプリミティブなオブジェクトを手動で投げるとrejectionコールバックが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many server-side frameworks provide a view engine that interpolates database data into a template before serving HTML (on page load or via AJAX) and then employ jQuery to handle user interactions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T010251Z" creationid="shibukawa.yoshiki" creationdate="20170220T010251Z">
        <seg>多くのサーバーサイドフレームワークは、テンプレートエンジンを使って、データベースの値をテンプレートに挿入してHTMLを作成します。例えそのHTMLがページロードによるものでも、AJAXのためのものでも基本は同じです。その後jQueryを使ってユーザのインタラクションを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Markdown Editor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035651Z" creationid="shibukawa.yoshiki" creationdate="20170131T035651Z">
        <seg>Markdownエディター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to deserialize the response data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013153Z" creationid="shibukawa.yoshiki" creationdate="20150415T013153Z">
        <seg>レスポンスデータをデシリアライズするメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to extract the data from the raw XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013314Z" creationid="shibukawa.yoshiki" creationdate="20150415T013314Z">
        <seg>XMLHttpRequest.からデータを取り出す時に使うメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to serialize the request data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013102Z" creationid="shibukawa.yoshiki" creationdate="20150415T013102Z">
        <seg>リクエストデータをシリアライズするときに使用するメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migrating from &lt;c0&gt;v0.2.x&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033536Z" creationid="shibukawa.yoshiki" creationdate="20170131T033536Z">
        <seg>v0.2.xからの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migrating from a thick server architecture to a thick client architecture is typically a somewhat large effort, and involves refactoring logic out of templates into logical data services (and the testing that goes with it).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024410Z" creationid="shibukawa.yoshiki" creationdate="20170220T024403Z">
        <seg>シック・サーバー・アーキテクチャから、シック・クライアント・アーキテクチャへの移行には多くの労力が必要となります。ロジックをテンプレートから取り出して、ロジックのデータサービスに入れる必要が発生したりします。それにともなってテストの修正も必要でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migrating from v0.2.x</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033505Z" creationid="shibukawa.yoshiki" creationdate="20170131T033505Z">
        <seg>v0.2.xからの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Misc</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140947Z" creationid="shibukawa.yoshiki" creationdate="20150407T140947Z">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril Jobs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024813Z" creationid="shibukawa.yoshiki" creationdate="20170131T024813Z">
        <seg>Mithrilの求人</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril Template Compiler</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014148Z" creationid="shibukawa.yoshiki" creationdate="20150417T014148Z">
        <seg>Mithrilテンプレートコンパイラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril allows writing asynchronous code in a procedural way through a high-level utility for working with web services.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140811Z" creationid="shibukawa.yoshiki" creationdate="20160101T140811Z">
        <seg>Mithrilはウェブサービス側と連係をするための高度なユーティリティを提供しており、非同期のコードを手続き的に書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril allows you to unwrap the relevant data, by providing two callback hooks: &lt;c0&gt;unwrapSuccess&lt;/c0&gt; and &lt;c1&gt;unwrapError&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174329Z" creationid="shibukawa.yoshiki" creationdate="20150410T174329Z">
        <seg>Mithrilは&lt;c0&gt;unwrapSuccess&lt;/c0&gt;、&lt;c1&gt;unwrapError&lt;/c1&gt;という2つのコールバックを提供しており、これらを使って、それぞれのデータをアンラアップすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also does not auto-camel-case CSS properties on inline style attributes, so you should use the Javascript syntax when setting them via Javascript objects:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013653Z" creationid="shibukawa.yoshiki" creationdate="20150413T013653Z">
        <seg>Mithrilはまた、インラインのスタイル属性のCSSのプロパティ名を自動でcamel-caseに変換することはありません。そのため、JavaScriptのオブジェクトを経由してJavaScript文法を使って設定すべきです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also does not redraw after lifecycle methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121440Z" creationid="shibukawa.yoshiki" creationdate="20170206T121440Z">
        <seg>Mithrilはライフサイクルメソッド後にも再描画は行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also has a dependency on XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014921Z" creationid="shibukawa.yoshiki" creationdate="20150417T014921Z">
        <seg>MithrilはXMLHttpRequestにも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also provides several hooks to control its redrawing behavior with a deep level of granularity: &lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; and &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; create redrawable contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191929Z" creationid="shibukawa.yoshiki" creationdate="20150411T191929Z">
        <seg>Mithrilはより深いレベルでエンジンの再描画の動作を制御できるように、いくつかのフックを提供しています。&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt;と&lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt;は再描画のコンテキストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also uses certain methods on the DOM node object</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162043Z" creationid="shibukawa.yoshiki" creationdate="20150416T162043Z">
        <seg>DOMノードオブジェクトの特定のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically figures out the correct XML namespaces when it sees an SVG island in the virtual DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140855Z" creationid="shibukawa.yoshiki" creationdate="20150413T140843Z">
        <seg>仮想のDOMツリーの中にSVGの要素が現れると、Mithrilは自動で正しいXML名前空間を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically figures out the most efficient way of updating the text, rather than blindly recreating it from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025940Z" creationid="shibukawa.yoshiki" creationdate="20170131T025940Z">
        <seg>Mithrilは自動的にテキストを更新するためのもっとも効率的な方法を判断して実行します。盲目的にすべてを再作成することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically redraws after &lt;a0&gt;&lt;c1&gt;m.request&lt;/c1&gt;&lt;/a0&gt; completes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121026Z" creationid="shibukawa.yoshiki" creationdate="20170206T121026Z">
        <seg>Mithrilは&lt;a0&gt;&lt;c1&gt;m.request&lt;/c1&gt;&lt;/a0&gt;の処理が完了した後に自動で再描画を行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically redraws after &lt;a0&gt;&lt;c1&gt;m.route.set()&lt;/c1&gt;&lt;/a0&gt; calls (or route changes via links that use &lt;a2&gt;&lt;c3&gt;m.route.link&lt;/c3&gt;&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121234Z" creationid="shibukawa.yoshiki" creationdate="20170206T121155Z">
        <seg>Mithrilは&lt;a0&gt;&lt;c1&gt;m.route.set()&lt;/c1&gt;&lt;/a0&gt;を呼び出したり、&lt;a2&gt;&lt;c3&gt;m.route.link&lt;/c3&gt;&lt;/a2&gt;を使用したリンクをクリックした後に再描画を自動で行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically redraws after DOM event handlers that are defined in a Mithril view:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120809Z" creationid="shibukawa.yoshiki" creationdate="20170206T120809Z">
        <seg>Mithrilは、Mithrilのビューで定義されたDOMイベントハンドラの実行後に再描画を自動で行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril controllers can be stripped down to a bare minimum, so that they only perform a single essential role: to expose a scoped set of model-level functionality.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002426Z" creationid="shibukawa.yoshiki" creationdate="20150408T002426Z">
        <seg>Mithrilのコントローラは、モデルレベルの機能の中からいくつか限定したものだけを公開するという、最小限の機能にまで落とし込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not auto-redraw vnode trees that are rendered via &lt;c0&gt;m.render&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121738Z" creationid="shibukawa.yoshiki" creationdate="20170206T121738Z">
        <seg>Mithrilは&lt;c0&gt;m.render&lt;/c0&gt;で描画されたvnodeツリーの再描画は行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not hook into the browser's &lt;c0&gt;onbeforeunload&lt;/c0&gt; event.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092249Z" creationid="shibukawa.yoshiki" creationdate="20150502T092249Z">
        <seg>Mithrilはブラウザの&lt;c0&gt;onbeforeunload&lt;/c0&gt;イベントはフックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not provide any animation APIs per se, since these other options are more than sufficient to achieve rich, complex animations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105207Z" creationid="shibukawa.yoshiki" creationdate="20170206T105026Z">
        <seg>Mithrilそのものはアニメーションのための　APIを提供していませんが、これらのさまざまなライブラリを活用することで、よりリッチで複雑なアニメーションが実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not redraw after &lt;c0&gt;setTimeout&lt;/c0&gt;, &lt;c1&gt;setInterval&lt;/c1&gt;, &lt;c2&gt;requestAnimationFrame&lt;/c2&gt; and 3rd party library event handlers (e.g. Socket.io callbacks).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121407Z" creationid="shibukawa.yoshiki" creationdate="20170206T121407Z">
        <seg>Mithrilは&lt;c0&gt;setTimeout&lt;/c0&gt;, &lt;c1&gt;setInterval&lt;/c1&gt;, &lt;c2&gt;requestAnimationFrame&lt;/c2&gt;の呼び出しや、サードパーティーライブラリが提供するイベントハンドラ（例: Socket.ioのコールバック）では再描画を行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not rely on unpolyfillable features, so developers can support browsers all the way back to IE6 and Blackberry by using shims if support for those older browsers is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110248Z" creationid="shibukawa.yoshiki" creationdate="20150420T110248Z">
        <seg>MithrilはPolyfillで補完できない機能は使ってないので、もしIE6以降ののブラウザやBlackberryに対応させる必要があれば、足りない機能を補間して対応させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does, however, offer hooks to make life easier in some specific cases where it's traditionally difficult to make animations work.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105344Z" creationid="shibukawa.yoshiki" creationdate="20170206T105344Z">
        <seg>Mithril自身は、以前はアニメーションが扱いにくかったいくつかのケースに対して、とても簡単に扱えるようなフックを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril employs a variety of mechanisms to decide the best time and the best strategy to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184821Z" creationid="shibukawa.yoshiki" creationdate="20150411T184821Z">
        <seg>Mithrilは、再描画をいつどんな戦略で行うかを決定するメカニズムをいくつか提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril has an internal counter, which is incremented every time &lt;c0&gt;m.startComputation&lt;/c0&gt; is called, and decremented every time &lt;c1&gt;m.endComputation&lt;/c1&gt; is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154152Z" creationid="shibukawa.yoshiki" creationdate="20150416T154152Z">
        <seg>Mithrilは内部カウンタを持っています。このカウンタは&lt;c0&gt;m.startComputation&lt;/c0&gt;が呼ばれるたびに増加し、&lt;c1&gt;m.endComputation&lt;/c1&gt;が呼ばれると減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril has more documentation in its Github repo than source code, and none of the documentation is auto-generated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114341Z" creationid="shibukawa.yoshiki" creationdate="20150417T114341Z">
        <seg>Mithrilは、github上で見ても、ソースコードそのものよりもドキュメントの方が大量にあります。また、自動生成のドキュメントはひとつもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril implements a virtual DOM diffing system for fast rendering, and in addition, it offers various mechanisms to gain granular control over the rendering of an application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032529Z" creationid="shibukawa.yoshiki" creationdate="20170131T032529Z">
        <seg>Mithrilは、高速なレンダリングのために仮想DOM差分システムを実装しています。また、それに加えてアプリケーションがレンダリングをコントロールできるように、適切な粒度のさまざまなメカニズムを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril internally calls this pair of functions when you call &lt;a2&gt;&lt;c3&gt;m.mount&lt;/c3&gt;&lt;/a2&gt;, &lt;a4&gt;&lt;c5&gt;m.route&lt;/c5&gt;&lt;/a4&gt;, &lt;a6&gt;&lt;c7&gt;m.request&lt;/c7&gt;&lt;/a6&gt;, and whenever an event defined with &lt;a8&gt;&lt;c9&gt;m()&lt;/c9&gt;&lt;/a8&gt; is triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T051404Z" creationid="shibukawa.yoshiki" creationdate="20160423T051404Z">
        <seg>Mithrilは、&lt;a2&gt;&lt;c3&gt;m.mount&lt;/c3&gt;&lt;/a2&gt;、&lt;a4&gt;&lt;c5&gt;m.route&lt;/c5&gt;&lt;/a4&gt;、&lt;a6&gt;&lt;c7&gt;m.request&lt;/c7&gt;&lt;/a6&gt;の中と、&lt;a8&gt;&lt;c9&gt;m()&lt;/c9&gt;&lt;/a8&gt; で定義されたイベント呼び出しの中で、この関数のペアを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is a client-side Javascript MVC framework, i.e. it's a tool to make application code divided into a data layer (called &lt;s0&gt;M&lt;/s0&gt;odel), a UI layer (called &lt;s1&gt;V&lt;/s1&gt;iew), and a glue layer (called &lt;s2&gt;C&lt;/s2&gt;ontroller)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110641Z" creationid="shibukawa.yoshiki" creationdate="20150407T141220Z">
        <seg>MithrilはクライアントサイドのJavaScript MVCフレームワークです。このツールを使うと、アプリケーションのコードはデータレイヤ(&lt;s0&gt;M&lt;/s0&gt;odel)、UIレイヤー(&lt;s1&gt;V&lt;/s1&gt;iew)、接続レイヤー(&lt;s2&gt;C&lt;/s2&gt;ontroller)に分割されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is a client-side MVC framework - a tool to organize code in a way that is easy to think about and to maintain.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133223Z" creationid="shibukawa.yoshiki" creationdate="20150407T133223Z">
        <seg>MithrilはクライアントサイドMVCフレームワークです。コードをきれいに構成して、構造について考えるのを簡単にしたり、メンテナンスしやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is a modern client-side Javascript framework for building Single Page Applications.&lt;br0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024925Z" creationid="shibukawa.yoshiki" creationdate="20170131T024925Z">
        <seg>Mithrilはシングルページアプリケーションを構築するためのモダンなクライアントサイドのJavaScriptフレームワークです。&lt;br0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is around 7.8 kB gzipped thanks to its &lt;a0&gt;small, focused, API&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142237Z" creationid="shibukawa.yoshiki" creationdate="20160412T142237Z">
        <seg>&lt;a0&gt;小さく、ムダのないAPI&lt;/a0&gt;のおかげで、Mithrilはgzipされた状態でたったの7.8kbしかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is available from a variety of sources:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164441Z" creationid="shibukawa.yoshiki" creationdate="20150407T164441Z">
        <seg>Mithrilはさまざまなインストール手段を提供しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is designed around the principle that data always flows from the model to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183448Z" creationid="shibukawa.yoshiki" creationdate="20150411T183448Z">
        <seg>Mithrilは、データは常にモデルからビューに流れる、という原則のもとに設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is designed for Single Page Applications, so these "pages" aren't necessarily different HTML files in the traditional sense of the word.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T052514Z" creationid="shibukawa.yoshiki" creationdate="20170221T052514Z">
        <seg>Mithrilはシングルページアプリケーションを念頭に設計されています。この「ページ」は古い価値観ではそれぞれ個別のHTMLファイルですが、シングルページアプリケーションではページごとにファイルを分ける必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is used by companies like Vimeo and Nike, and open source platforms like Lichess.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025132Z" creationid="shibukawa.yoshiki" creationdate="20170131T025115Z">
        <seg>MithrilはVimeoやNikeといった企業や、Lichessのようなオープンソースプラットフォームで利用されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril may also avoid auto-redrawing if the frequency of requested redraws is higher than one animation frame (typically around 16ms).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T132857Z" creationid="shibukawa.yoshiki" creationdate="20170206T132857Z">
        <seg>Mithrilは1アニメーションフレーム（通常16ミリ秒）以内に再度再描画が行われると、自動再描画をスキップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril modules will be referred to as &lt;e0&gt;components&lt;/e0&gt; from now on.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140802Z" creationid="shibukawa.yoshiki" creationdate="20160412T140802Z">
        <seg>Mithrilモジュールは今から&lt;e0&gt;コンポーネント&lt;/e0&gt;と呼ばれるようになった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril promises are also getter-setter functions, which are populated with the resolved value if the promise is fulfilled successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135338Z" creationid="shibukawa.yoshiki" creationdate="20150414T135338Z">
        <seg>Mithrilのpromiseもまたgetter-setter関数で、promiseが果たされると、解決された値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140220Z" creationid="shibukawa.yoshiki" creationdate="20150415T140220Z">
        <seg>可能であればMithrilのpromiseは同期実行しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril provides a few more facilities that are not demonstrated in this page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015709Z" creationid="shibukawa.yoshiki" creationdate="20150409T015709Z">
        <seg>Mithrilには、このページ内で紹介しきれなかった機能がまだいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril provides utilities to handle three different aspect of routing:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162147Z" creationid="shibukawa.yoshiki" creationdate="20150409T162147Z">
        <seg>Mithrilは、ラウティングに関して、3種類の異なるサポートを提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril relies on some ECMAScript 5 features, namely: &lt;c0&gt;Array::indexOf&lt;/c0&gt;, &lt;c1&gt;Array::map&lt;/c1&gt; and &lt;c2&gt;Object::keys&lt;/c2&gt;, as well as the &lt;c3&gt;JSON&lt;/c3&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014511Z" creationid="shibukawa.yoshiki" creationdate="20150417T014511Z">
        <seg>Mithrilは&lt;c0&gt;Array::indexOf&lt;/c0&gt;、&lt;c1&gt;Array::map&lt;/c1&gt;、&lt;c2&gt;Object::keys&lt;/c2&gt;、&lt;c3&gt;JSON&lt;/c3&gt;オブジェクトなどのECMAScript 5の機能を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril takes some learnings from that and implements a templating redrawing system that renders less aggressively, is less complex and is easier to profile.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094919Z" creationid="shibukawa.yoshiki" creationdate="20150420T094919Z">
        <seg>MithrilはAngularからの学びにより、控えめな実装で複雑さを下げ、プロファイリングしやすい実装にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are also more collision-proof than other component systems since there's no way to pollute the HTML tag namespace by defining ad-hoc tag names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015301Z" creationid="shibukawa.yoshiki" creationdate="20150409T015301Z">
        <seg>Mithrilのテンプレートは他のコンポーネントシステムよりも衝突に対して安全です。アドホックにタグ名を決定してHTMLタグの名前空間を汚すことができないようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are defended against these attacks by default, except when markup is injected via &lt;c0&gt;m.trust&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015237Z" creationid="shibukawa.yoshiki" creationdate="20150416T015237Z">
        <seg>Mithrilのテンプレートは、&lt;c0&gt;m.trust&lt;/c0&gt;でマークアップを挿入するのを除けば、デフォルトではこのような攻撃を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are safe by default, i.e. you can't unintentionally create security holes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T161828Z" creationid="shibukawa.yoshiki" creationdate="20150407T135140Z">
        <seg>Mithrilのテンプレートはデフォルトで安全な動作をするようになっています。無理やり作ろうとしなければセキュリティホールを作ることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril thenables take two functions as optional parameters: the first parameter is called if the web service request completes successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140954Z" creationid="shibukawa.yoshiki" creationdate="20160101T140954Z">
        <seg>Mithrilのthenableは、2つのオプションのパラメータを持っています。最初のパラメータはウェブサービスへのリクエストが問題なく完了した時に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril thennables take two functions as optional parameters: the first parameter is called if the web service request completes successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124829Z" creationid="shibukawa.yoshiki" creationdate="20150410T124829Z">
        <seg>Mithrilのthennableは、2つのオプションのパラメータを持っています。最初のパラメータはウェブサービスへのリクエストが問題なく完了した時に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril updates the native &lt;c0&gt;location&lt;/c0&gt; object after rendering in order to allow the browser's &lt;c1&gt;history.pushState&lt;/c1&gt; API to correctly show descriptive history entries (e.g. for Chrome's Ctrl+H page).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171822Z" creationid="shibukawa.yoshiki" creationdate="20150414T171822Z">
        <seg>Mithrilはレンダリングの後に、ネイティブの&lt;c0&gt;location&lt;/c0&gt;を更新して、&lt;c1&gt;history.pushState&lt;/c1&gt; APIが正しい履歴のエントリーが表示されるようにします(Chromeの場合はCtrl+H page)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril uses certain &lt;c0&gt;window&lt;/c0&gt; methods that will need to be made available for complete test coverage, depending on your application:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161926Z" creationid="shibukawa.yoshiki" creationdate="20150416T161926Z">
        <seg>Mithrilは完全なテストのカバレッジを得たり、アプリケーションの機能の実現のために、特定の&lt;c0&gt;window&lt;/c0&gt;のメソッドを呼んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril uses them in other interesting ways elsewhere.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152259Z" creationid="shibukawa.yoshiki" creationdate="20150408T152248Z">
        <seg>Mithrilは、これ以外のさまざまなところでも、これらのテクニックを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril views can provide accurate and informative error reporting, with line numbers and meaningful stack traces.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013929Z" creationid="shibukawa.yoshiki" creationdate="20150409T013929Z">
        <seg>また、Mithrilのビューは、行番号と分かりやすいスタックトレース付きの正確で意味のあるエラーを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's &lt;c0&gt;m.request&lt;/c0&gt; uses &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; instead of &lt;c2&gt;fetch()&lt;/c2&gt; for a number of reasons:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024945Z" creationid="shibukawa.yoshiki" creationdate="20170220T024945Z">
        <seg>Mithrilの &lt;c0&gt;m.request&lt;/c0&gt;はいくつかの理由により、&lt;c2&gt;fetch()&lt;/c2&gt;の代わりに&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's auto-redrawing system keeps track of controller stability, and only redraws the view once it detects that the controller has finished running all of its code, including asynchronous AJAX payloads.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114401Z" creationid="shibukawa.yoshiki" creationdate="20150408T161344Z">
        <seg>Mithrilの自動再描画システムはコントローラの安定性を崩しません。ビューの再描画はコントローラの処理がすべて終わった時にのみ行われます。このコントローラの処理には、AJAXによるデータのロードも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's design strongly encourages all entity logic to be handled in atomic model layer methods (in the sense of entity state stability).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032116Z" creationid="shibukawa.yoshiki" creationdate="20150421T014353Z">
        <seg>Mithrilの設計としては、エンティティの状態の安定性を鑑みて、エンティティのロジックはモデルレイヤーのアトミックなメソッドで行うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's diffing algorithm makes sure expensive DOM operations are performed only if absolutely necessary, and as an extra benefit, the global nature of the redraw makes it easy to reason about and troubleshoot the state of the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074956Z" creationid="shibukawa.yoshiki" creationdate="20150502T074956Z">
        <seg>Mithrilは差分検知アルゴリズムを利用することで、高コストなDOM操作を本当に必要な箇所だけ実行することができます。また、全体を再描画するという仕組み上、アプリケーションの状態がビューとモデルの2つに存在するのではなく、モデルの状態によってのみ管理されるため、トラブルシューティングが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's on-demand tooling approach means there are no hidden performance costs when implementing core MVC patterns, and there's also no extra learning curve for framework-specific syntax for those patterns.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145613Z" creationid="shibukawa.yoshiki" creationdate="20150417T145404Z">
        <seg>Mithrilの必要な時に必要なツールだけを提供するアプローチでは、コアのMVCパターンを実装するときに、隠れたパフォーマンスのコストを負わされることはありません。また、フレームワークに対して、特定のパターンに対する特殊なシンタックスを覚えさせるような無用なラーニングカーブはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's rendering engine still operates on the basis of semi-automated global redraws, but some APIs and behaviours differ:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120119Z" creationid="shibukawa.yoshiki" creationdate="20170131T120119Z">
        <seg>Mithrilのレンダリングエンジンは基本的に半自動グローバル再描画を行いますが、いくつかのAPIと挙動が変わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's view layer paradigm is designed to be &lt;s0&gt;declarative&lt;/s0&gt;, much like HTML, such that the same code implicitly does everything it needs to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T115211Z" creationid="shibukawa.yoshiki" creationdate="20160101T115211Z">
        <seg>Mithrilのビューレイヤーは&lt;s0&gt;宣言的&lt;/s0&gt;なコードになるように設計されていて、よりHTMLに近くなっています。表示するコードを書くだけですべて完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril, on the other hand, purposely avoids the observer pattern in an attempt to abolish "come-from hell", a class of debugging problems where you don't know what triggers some code because of a long chain of events triggering other events.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021100Z" creationid="shibukawa.yoshiki" creationdate="20150420T020944Z">
        <seg>Mithrilはこれとは対照的に、「どこから来たのか分からない」といった種類の問題を避けるために、オブザーバパターンをなるべく避ける実装になっています。イベントからイベントへ、長いチェーンになっていると、何がコードを起動しているトリガーになっているのか理解が難しくなることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril, on the other hand, tries to provide only features that support a more classic MVC paradigm.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095131Z" creationid="shibukawa.yoshiki" creationdate="20150420T095131Z">
        <seg>Mithrilはそれとは対照的に、よりクラシックなMVCをサポートするのに必要な機能だけを備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril-objectify requires a &lt;a0&gt;NodeJS&lt;/a0&gt; environment.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T050029Z" creationid="shibukawa.yoshiki" creationdate="20160423T050029Z">
        <seg>Mithril-objectifyを実行するには&lt;a0&gt;NodeJS&lt;/a0&gt;環境が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mode abstraction</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013122Z" creationid="shibukawa.yoshiki" creationdate="20150410T013122Z">
        <seg>モードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Model</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T144138Z" creationid="shibukawa.yoshiki" creationdate="20150407T144138Z">
        <seg>モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Models are also responsible for centralizing tasks such as filtering of entity lists and validation routines, so that access to these methods is available across the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033522Z" creationid="shibukawa.yoshiki" creationdate="20150421T033411Z">
        <seg>エンティティのリストのフィルタリングや、バリデーションもモデルの責務になります。モデルに定義することで、アプリケーション全体でこれらのメソッドが利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring progress</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160858Z" creationid="shibukawa.yoshiki" creationdate="20170219T160858Z">
        <seg>進捗のモニタリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More documentation on these new methods is available in &lt;a0&gt;lifecycle-methods.md&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T035131Z" creationid="shibukawa.yoshiki" creationdate="20170131T035131Z">
        <seg>これらの新しいメソッドについては、&lt;a0&gt;ライフサイクルメソッド&lt;/a0&gt;のドキュメントで紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most frameworks redraw aggressively and err on the side of redrawing too many times because, as it turns out, determining the best time to do a redraw is quite complicated if we want to be as efficient as possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184717Z" creationid="shibukawa.yoshiki" creationdate="20150411T184717Z">
        <seg>ほとんどのフレームワークでは、再描画を積極的に行いますが、やりすぎてしまうという間違いをおかしています。というのも、なるべく効率よくやろうとすると、再描画を行うベストなタイミングを決定するのはとても難しい問題だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the popular frameworks have at least a bare minimum amount of documentation nowadays, but many leave a bit to be desired: some lack usage examples, and some frameworks' communities need to rely heavily on third party sites for explanations of more advanced topics, and sometimes even for learning the basics.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114143Z" creationid="shibukawa.yoshiki" creationdate="20150417T114143Z">
        <seg>人気のフレームワークのほとんどは、最低限のドキュメントしか提供していませんが、多くの人は便利なサンプルが欠けていると感じていたり、上級のトピックは外部の情報まかせになっていたり、場合によっては基本的な情報すら外部の方が詳しかったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mounting is the process of rendering a &lt;a0&gt;component&lt;/a0&gt; into a DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125046Z" creationid="shibukawa.yoshiki" creationdate="20150502T125046Z">
        <seg>マウントは、&lt;a0&gt;コンポーネント&lt;/a0&gt;をDOMエレメントにレンダリングするプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple file uploads</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160147Z" creationid="shibukawa.yoshiki" creationdate="20170219T160147Z">
        <seg>複数ファイルのアップロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be either &lt;c0&gt;"GET"&lt;/c0&gt;, &lt;c1&gt;"POST"&lt;/c1&gt;, &lt;c2&gt;"PUT"&lt;/c2&gt;, &lt;c3&gt;"DELETE"&lt;/c3&gt;, &lt;c4&gt;"HEAD"&lt;/c4&gt; or &lt;c5&gt;"OPTIONS"&lt;/c5&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002151Z" creationid="shibukawa.yoshiki" creationdate="20150415T002151Z">
        <seg>このオプションは、&lt;c0&gt;"GET"&lt;/c0&gt;、&lt;c1&gt;"POST"&lt;/c1&gt;、&lt;c2&gt;"PUT"&lt;/c2&gt;、&lt;c3&gt;"DELETE"&lt;/c3&gt;、&lt;c4&gt;"HEAD"&lt;/c4&gt;、&lt;c5&gt;"OPTIONS"&lt;/c5&gt;のどれかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be the string "jsonp"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014512Z" creationid="shibukawa.yoshiki" creationdate="20150415T014512Z">
        <seg>"jsonp"でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NPM is the default package manager for &lt;a0&gt;NodeJS&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165756Z" creationid="shibukawa.yoshiki" creationdate="20150407T165756Z">
        <seg>NPMは&lt;a0&gt;NodeJS&lt;/a0&gt;標準のパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NPM stands for Node.js Package Manager.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071232Z" creationid="shibukawa.yoshiki" creationdate="20170207T071232Z">
        <seg>npmはNode.jsはNode.js Package Managerの省略形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Navigate between "pages" within an application</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080034Z" creationid="shibukawa.yoshiki" creationdate="20170207T080034Z">
        <seg>アプリケーション内の「ページ」間のナビゲーションを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Navigating to different routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T101226Z" creationid="shibukawa.yoshiki" creationdate="20170207T101226Z">
        <seg>異なるラウトへのナビゲーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither of these trade-offs are acceptable, given Mithril's focus on nimbleness and performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140945Z" creationid="shibukawa.yoshiki" creationdate="20150415T140945Z">
        <seg>Mithrilは敏捷性とパフォーマンスにフォーカスしているため、これらのトレードオフを受け入れることはできませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested arrays in views</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034611Z" creationid="shibukawa.yoshiki" creationdate="20170131T034611Z">
        <seg>ビューのネストされた配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested asynchronous components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050651Z" creationid="shibukawa.yoshiki" creationdate="20150502T050651Z">
        <seg>非同期のネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested component views must return either a virtual element or another component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095635Z" creationid="shibukawa.yoshiki" creationdate="20150502T095635Z">
        <seg>ネストされたコンポーネントのビューは、仮想エレメントか他のコンポーネントを返さなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested components cannot change &lt;c0&gt;m.redraw.strategy&lt;/c0&gt; from the controller constructor (but they can from event handlers).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095755Z" creationid="shibukawa.yoshiki" creationdate="20150502T095755Z">
        <seg>ネストされたコンポーネントはコントローラのコンストラクタから&lt;c0&gt;m.redraw.strategy&lt;/c0&gt;を変更することはできません。ただしイベントハンドラからなら行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nesting components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050545Z" creationid="shibukawa.yoshiki" creationdate="20150502T050545Z">
        <seg>コンポーネントのネスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New bundles are generated using updated version</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054252Z" creationid="shibukawa.yoshiki" creationdate="20170220T054252Z">
        <seg>更新されたバージョンを使ったバンドルが作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>News:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135659Z" creationid="shibukawa.yoshiki" creationdate="20160412T135659Z">
        <seg>ニュース:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next we create a function that will trigger an XHR call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055525Z" creationid="shibukawa.yoshiki" creationdate="20170220T055525Z">
        <seg>次に、XHR呼び出しを行う関数を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, let's create a Mithril component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121436Z" creationid="shibukawa.yoshiki" creationdate="20170220T121436Z">
        <seg>次にMithrilコンポーネントを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, let's modify &lt;c0&gt;FancyComponent&lt;/c0&gt; so that it fades out when removed:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110228Z" creationid="shibukawa.yoshiki" creationdate="20170206T110220Z">
        <seg>次に、&lt;c0&gt;FancyComponent&lt;/c0&gt;を修正し、削除時にフェードアウトさせるようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you need to call &lt;c0&gt;m.request&lt;/c0&gt; and set &lt;c1&gt;options.method&lt;/c1&gt; to an HTTP method that uses body (e.g. &lt;c2&gt;POST&lt;/c2&gt;, &lt;c3&gt;PUT&lt;/c3&gt;, &lt;c4&gt;PATCH&lt;/c4&gt;) and use the &lt;c5&gt;FormData&lt;/c5&gt; object as &lt;c6&gt;options.data&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155856Z" creationid="shibukawa.yoshiki" creationdate="20170219T155819Z">
        <seg>次に&lt;c0&gt;m.request&lt;/c0&gt;を呼びます。&lt;c1&gt;options.method&lt;/c1&gt;にはボディが指定できるHTTPメソッド（&lt;c2&gt;POST&lt;/c2&gt;, &lt;c3&gt;PUT&lt;/c3&gt;, &lt;c4&gt;PATCH&lt;/c4&gt;）を設定し、&lt;c5&gt;FormData&lt;/c5&gt;オブジェクトを&lt;c6&gt;options.data&lt;/c6&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you need to create a &lt;a0&gt;&lt;c1&gt;FormData&lt;/c1&gt;&lt;/a0&gt; object to create a &lt;a2&gt;multipart request&lt;/a2&gt;, which is a specially formatted HTTP request that is able to send file data in the request body.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155701Z" creationid="shibukawa.yoshiki" creationdate="20170219T155701Z">
        <seg>次に、&lt;a2&gt;マルチパートリクエスト&lt;/a2&gt;を作成するための&lt;a0&gt;&lt;c1&gt;FormData&lt;/c1&gt;&lt;/a0&gt;オブジェクトを作ります。これを使うと、ファイルデータを含められるように特別にフォーマットされたHTTPリクエストが行えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No flash-of-unbehaviored-content (FOUC).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114250Z" creationid="shibukawa.yoshiki" creationdate="20150409T013414Z">
        <seg>コンテンツが設定されていない内容が一瞬表示されてしまう(flash-of-unbehaviored-content :FOUC)のを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No more redraw locks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034043Z" creationid="shibukawa.yoshiki" creationdate="20170131T033814Z">
        <seg>再描画のロックはなくなった</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-JSON responses</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T160950Z" creationid="shibukawa.yoshiki" creationdate="20170219T160950Z">
        <seg>JSON以外のレスポンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, calling &lt;c0&gt;m.mount&lt;/c0&gt; will return the controller instance for that component, but there's one corner case: if &lt;c1&gt;e.preventDefault()&lt;/c1&gt; is called from a controller's &lt;c2&gt;onunload&lt;/c2&gt; method, then the &lt;c3&gt;m.mount&lt;/c3&gt; call will not instantiate the new controller, and will return &lt;c4&gt;undefined&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092155Z" creationid="shibukawa.yoshiki" creationdate="20150502T092155Z">
        <seg>通常、&lt;c0&gt;m.mount&lt;/c0&gt;呼び出しはコントローラのインスタンスを返します。しかし、コントローラの&lt;c2&gt;onunload&lt;/c2&gt;内で、&lt;c1&gt;e.preventDefault()&lt;/c1&gt;が呼ばれると、&lt;c3&gt;m.mount&lt;/c3&gt;は新しいコントローラのインスタンスの生成をやめ、&lt;c4&gt;undefined&lt;/c4&gt;が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, you need to create a few &lt;a0&gt;components&lt;/a0&gt; to map routes to:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100643Z" creationid="shibukawa.yoshiki" creationdate="20170207T100639Z">
        <seg>通常は、ラウトにマッピングする&lt;a0&gt;コンポーネント&lt;/a0&gt;をいくつか作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, you should only do this if you need to synchronously read a value from the DOM that requires a browser repaint (e.g. &lt;c0&gt;offsetTop&lt;/c0&gt; or a CSS rule).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151551Z" creationid="shibukawa.yoshiki" creationdate="20150416T151551Z">
        <seg>通常は、&lt;c0&gt;offsetTop&lt;/c0&gt;やCSSルールなど、ブラウザの再描画を必要とする、DOMの同期的な値読み込みが必要になった時だけにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not using keys still works in some cases, but might trigger more expensive code paths within the redrawing algorithm.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021156Z" creationid="shibukawa.yoshiki" creationdate="20150421T021156Z">
        <seg>キーを使用しなくても期待通りの動作をすることがありますが、再描画のアルゴリズムの効率が下がってコストが高くなる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that, despite having a bigger scope, Mithril has a smaller file size than React.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105402Z" creationid="shibukawa.yoshiki" creationdate="20150420T105402Z">
        <seg>また、そのように広い範囲をスコープに入れているにもかかわらず、MithrilのファイルサイズはReactよりも小さくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;m.render&lt;/c0&gt; is a very low level method in Mithril that draws only once and doesn't attempt to run the auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014121Z" creationid="shibukawa.yoshiki" creationdate="20150408T014121Z">
        <seg>&lt;c0&gt;m.render&lt;/c0&gt;はMithrilの提供する中で、とても低レベルなメソッドで、1回だけ描画するために使います。自動再描画システムを利用する場合は使用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril always considers the model layer data to be canonical.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015108Z" creationid="shibukawa.yoshiki" creationdate="20150413T015108Z">
        <seg>Mithrilは、常にモデルレイヤのデータが正当なものであると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril checks for route matches in the order the routes are defined, so you should put variadic routes at the bottom of the list to prevent them from matching other more specific routes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154059Z" creationid="shibukawa.yoshiki" creationdate="20150414T154059Z">
        <seg>Mithrilはラウトのマッチを定義された順番に行っていきます。そのため、可変個の引数を持つラウトは末尾に書かないと、より範囲の狭いラウトのマッチが行われなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril does not prescribe how the binding updates: you can bind it to &lt;c0&gt;onchange&lt;/c0&gt;, &lt;c1&gt;onkeypress&lt;/c1&gt;, &lt;c2&gt;oninput&lt;/c2&gt;, &lt;c3&gt;onblur&lt;/c3&gt; or any other event that you prefer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021740Z" creationid="shibukawa.yoshiki" creationdate="20150408T021740Z">
        <seg>Mithrilはどのイベントを監視して更新を受け取るかはユーザに任せています。&lt;c0&gt;onchange&lt;/c0&gt;、&lt;c1&gt;onkeypress&lt;/c1&gt;、&lt;c2&gt;oninput&lt;/c2&gt;、&lt;c3&gt;onblur&lt;/c3&gt;など、好きなイベントを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril only uses the mock object for browser APIs such as the DOM API and &lt;c1&gt;requestAnimationFrame&lt;/c1&gt;, but relies on the environment for ECMAScript features like &lt;c2&gt;Object.keys&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161305Z" creationid="shibukawa.yoshiki" creationdate="20150416T161305Z">
        <seg>MithrilはDOM APIや&lt;c1&gt;requestAnimationFrame&lt;/c1&gt;などのブラウザAPIのためにのみモックオブジェクトを使いますが、&lt;c2&gt;Object.keys&lt;/c2&gt;などのECMAScript環境にも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril promises are not automatically integrated to its automatic redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134929Z" creationid="shibukawa.yoshiki" creationdate="20150415T134929Z">
        <seg>Mithrilのプロミスは自動的に自動再描画システムと統合されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that browsers ignore &lt;c0&gt;&lt;script&gt;&lt;/c0&gt; tags that have been inserted into the DOM via innerHTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014130Z" creationid="shibukawa.yoshiki" creationdate="20150416T014130Z">
        <seg>ブラウザは、innerHTML経由でDOMに挿入された&lt;c0&gt;&lt;script&gt;&lt;/c0&gt;タグは無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that changing the redraw strategy only affects the next scheduled redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155643Z" creationid="shibukawa.yoshiki" creationdate="20150416T155643Z">
        <seg>再描画戦略の変更は次に計画されている再描画にのみ影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that compiled templates are meant to be generated by an automated build process and are not meant to be human editable.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145920Z" creationid="shibukawa.yoshiki" creationdate="20150412T145845Z">
        <seg>このコンパイル済みのテンプレートは自動ビルドプロセスの結果作られたものであって、人間がこのように書くべきという意味ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that even if you set &lt;c0&gt;context.retain = true&lt;/c0&gt;, the element will still be destroyed and recreated if it is different enough from the existing element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135305Z" creationid="shibukawa.yoshiki" creationdate="20150413T135305Z">
        <seg>&lt;c0&gt;context.retain = true&lt;/c0&gt;を設定しても、既存のエレメントと大きく異る場合はエレメントは破壊されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that failing to call &lt;c0&gt;endComputation&lt;/c0&gt; after a respective &lt;c1&gt;startComputation&lt;/c1&gt; call will halt the redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153317Z" creationid="shibukawa.yoshiki" creationdate="20150416T153317Z">
        <seg>&lt;c1&gt;startComputation&lt;/c1&gt;を呼んだ後に、対になる&lt;c0&gt;endComputation&lt;/c0&gt;呼び出しをすると、再描画システム全体が動作しなくなるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if the same attribute is defined in the both &lt;c0&gt;selector&lt;/c0&gt; and &lt;c1&gt;attributes&lt;/c1&gt; parameters, the value in &lt;c2&gt;attributes&lt;/c2&gt; is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150803Z" creationid="shibukawa.yoshiki" creationdate="20150413T150803Z">
        <seg>もし&lt;c0&gt;selector&lt;/c0&gt;と&lt;c1&gt;attributes&lt;/c1&gt;パラメータで同じ属性が定義されると、&lt;c2&gt;attributes&lt;/c2&gt;が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you're changing this configuration value, you should change it &lt;s1&gt;before&lt;/s1&gt; calling &lt;c2&gt;m.route&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165746Z" creationid="shibukawa.yoshiki" creationdate="20150414T165746Z">
        <seg>この設定を変更する場合には、&lt;c2&gt;m.route&lt;/c2&gt;を呼び出す&lt;s1&gt;前に&lt;/s1&gt;行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in addition to the presence of the &lt;c0&gt;key&lt;/c0&gt; attribute, diffing rules also apply in determining whether an element is recreated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144045Z" creationid="shibukawa.yoshiki" creationdate="20150413T144045Z">
        <seg>&lt;c0&gt;key&lt;/c0&gt;属性があるかどうかに加えて、差分検知のルールもエレメントの再生成を行うかどうかの判定に使用される点は注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to keep the framework lean, Mithril does not auto-append units like &lt;c0&gt;px&lt;/c0&gt; or &lt;c1&gt;%&lt;/c1&gt; to any values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013231Z" creationid="shibukawa.yoshiki" creationdate="20150413T013231Z">
        <seg>フレームワークは必要最低限の動作をするように設計されているため、どの属性名にも、&lt;c0&gt;px&lt;/c0&gt;、&lt;c1&gt;%&lt;/c1&gt;といった単位を付けることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to support older versions of IE, you need to include &lt;a0&gt;some shims&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165104Z" creationid="shibukawa.yoshiki" creationdate="20150407T165019Z">
        <seg>古いバージョンのIEをサポートする場合は、&lt;a0&gt;互換性を向上させるライブラリ&lt;/a0&gt;をいくつか読み込む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to use the &lt;c0&gt;pathname&lt;/c0&gt; mode, the application must be run from the root URL.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170245Z" creationid="shibukawa.yoshiki" creationdate="20150414T170245Z">
        <seg>&lt;c0&gt;pathname&lt;/c0&gt;モードを使う場合は、アプリケーションがルートのURLで実行するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in this case, if the Layout component the &lt;c0&gt;oninit&lt;/c0&gt; and &lt;c1&gt;oncreate&lt;/c1&gt; lifecycle methods would only fire on the Layout component on the first route change (assuming all routes use the same layout).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073321Z" creationid="shibukawa.yoshiki" creationdate="20170208T073321Z">
        <seg>この場合、すべてのラウトで同じレイアウトが使われていると判断されるため、レイアウトコンポーネントの&lt;c0&gt;oninit&lt;/c0&gt;、&lt;c1&gt;oncreate&lt;/c1&gt;のライフサイクルメソッドは最初のラウトの遷移では呼ばれなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that modifying the values of &lt;c0&gt;m.prop&lt;/c0&gt; getter-setters does not trigger redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133945Z" creationid="shibukawa.yoshiki" creationdate="20150414T133945Z">
        <seg>&lt;c0&gt;m.prop&lt;/c0&gt;getter-setterの値を変更しても、再描画が起動されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;Todo&lt;/c0&gt; and &lt;c1&gt;TodoList&lt;/c1&gt; classes we defined above are plain vanilla Javascript constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150749Z" creationid="shibukawa.yoshiki" creationdate="20150407T150749Z">
        <seg>上記のサンプルで定義した&lt;c0&gt;Todo&lt;/c0&gt;クラスと&lt;c1&gt;TodoList&lt;/c1&gt;クラスは、混じりけのない、プレーンなJavaScriptのコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;onbeforeremove&lt;/c0&gt; hook only fires on the element that loses its &lt;c1&gt;parentNode&lt;/c1&gt; when an element gets detached from the DOM. This behavior is by design and exists to prevent a potential jarring user experience where every conceivable exit animation on the page would run on a route change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111109Z" creationid="shibukawa.yoshiki" creationdate="20170206T111109Z">
        <seg>注意点としては、&lt;c0&gt;onbeforeremove&lt;/c0&gt;フックは、DOMから要素が切り離されて&lt;c1&gt;parentNode&lt;/c1&gt;がいなくなる要素に対してのみトリガーされます。この動作は設計上意図されたものです。ラウトの変更などで、ページ上のすべての要素の終了アニメーションが実行されてしまってユーザ経験が悪化するのを防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the URL component used to resolve routes is dependent on &lt;c0&gt;m.route.mode&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165413Z" creationid="shibukawa.yoshiki" creationdate="20150414T165413Z">
        <seg>ラウトの解決に使うURLの部位は、&lt;c0&gt;m.route.mode&lt;/c0&gt;によって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the default promise exception handling semantics can be modified.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173452Z" creationid="shibukawa.yoshiki" creationdate="20150415T173452Z">
        <seg>このように、デフォルトの例外処理のセマンティクスが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the example above only &lt;e0&gt;sets&lt;/e0&gt; the value of the input element in the DOM, but it never &lt;e1&gt;reads&lt;/e1&gt; it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015822Z" creationid="shibukawa.yoshiki" creationdate="20150408T015822Z">
        <seg>このコードでは、DOMのテキスト入力エレメントの値に&lt;e0&gt;設定するだけ&lt;/e0&gt;で、&lt;e1&gt;読み込み&lt;/e1&gt;は行わないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the output value from &lt;c0&gt;m()&lt;/c0&gt; is not an actual DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000134Z" creationid="shibukawa.yoshiki" creationdate="20150413T000134Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;関数が返す値は、実際のDOM要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the redraw strategy is a global setting that affects the entire template trees of all components on the page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130853Z" creationid="shibukawa.yoshiki" creationdate="20150502T130853Z">
        <seg>再描画の戦略は、ページ内の全コンポーネントのテンプレートツリーに影響を与えるグローバルな設定であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the sample component above is illustrative.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082005Z" creationid="shibukawa.yoshiki" creationdate="20150502T081714Z">
        <seg>上記のサンプルは実際には役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no requirement to tightly couple a controller and view while organizing code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071455Z" creationid="shibukawa.yoshiki" creationdate="20150502T071455Z">
        <seg>このコードを組み立てるときに、コントローラとビューを密結合させる必要がない点がポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this getter-setter holds an &lt;e0&gt;undefined&lt;/e0&gt; value until the AJAX request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015221Z" creationid="shibukawa.yoshiki" creationdate="20150410T015221Z">
        <seg>getter-setterは、AJAXリクエストが完了するまでは&lt;e0&gt;undefined&lt;/e0&gt;値を返すことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this option only works when using the pushState API, but is ignored if the router falls back to hashchange mode (i.e. if the pushState API is not available)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082306Z" creationid="shibukawa.yoshiki" creationdate="20170207T082306Z">
        <seg>このオプションはpushState APIを使っているときにのみ利用できます。pushState APIが利用できないときは、ラウターはハッシュ変更モードにフォールバックしますがこの時は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to redirect to a different page outside of the scope of Mithril's routing, you should use &lt;c0&gt;window.location&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171505Z" creationid="shibukawa.yoshiki" creationdate="20150414T171505Z">
        <seg>もし、Mithrilのラウティングで取り扱っている範囲外のページにリダイレクトする場合は、&lt;c0&gt;window.location&lt;/c0&gt;を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using this feature is discouraged if you don't have visible performance problems.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123949Z" creationid="shibukawa.yoshiki" creationdate="20150416T123949Z">
        <seg>もし、ビューに関するパフォーマンス上の問題が何もなければ、この機能は使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when we construct the parameterized binding, we are passing the &lt;c0&gt;description&lt;/c0&gt; getter-setter &lt;e1&gt;by reference&lt;/e1&gt;, and not its value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151707Z" creationid="shibukawa.yoshiki" creationdate="20150408T151707Z">
        <seg>パラメータを束縛するときに、上記の例では&lt;c0&gt;description&lt;/c0&gt; getter-setterを&lt;e1&gt;参照で渡して&lt;/e1&gt;いて、直接値を渡しているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that while a small gzipped size can look appealing, that number is often used to "hide the weight" of the uncompressed code: remember that the decompressed Javascript still needs to be parsed and evaluated on every page load, and this cost (which can be in the dozens of milliseconds range for some frameworks in some browsers) cannot be cached.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113412Z" creationid="shibukawa.yoshiki" creationdate="20150417T021951Z">
        <seg>gzipされたコードが小さいのがアピールポイントというのは、非圧縮時にとても大きくなることを隠しているように見えるかもしれません。非圧縮のJavaScriptはページロードのたびにパースと評価が行われます。いくつかのフレームワークでは環境によっては数10msにもなりますが、このコストはキャッシュできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can use JSON syntax if the attribute name you are setting has non-alphanumeric characters:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013102Z" creationid="shibukawa.yoshiki" creationdate="20150413T013102Z">
        <seg>アルファベットと数値以外の文字列を持つ属性名を設定したいときは、JSON文法を使うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can use both Javascript property names and HTML attribute names to set values in the &lt;c0&gt;attributes&lt;/c0&gt; argument, but you should pass a value of appropriate type.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T003008Z" creationid="shibukawa.yoshiki" creationdate="20150413T003008Z">
        <seg>&lt;c0&gt;attributes&lt;/c0&gt;引数の中では、JavaScriptのプロパティ名とHTML属性名の両方を使って設定できますが、適切な型を使って渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike many templating engines, this "smart diff" feature does not affect things like cursor placement in inputs and focus, and is therefore safe to call during user interactions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020220Z" creationid="shibukawa.yoshiki" creationdate="20150416T020220Z">
        <seg>他のテンプレートエンジンとは異なり、この「賢い差分」機能は、入力フォームのカーソルやフォーカスに対して影響を与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that since the code above is not valid Javascript, this syntax can only be used with a preprocessor build tool such as the provided &lt;a0&gt;Gulp.js&lt;/a0&gt; script.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014025Z" creationid="shibukawa.yoshiki" creationdate="20150417T014025Z">
        <seg>上記のコードはJavaScriptとして正しい文法ではありませんが、このコードは&lt;a0&gt;Gulp.js&lt;/a0&gt;などで提供されているプリプロセッサのビルドツールから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: If you prefer &lt;c0&gt;&lt;html&gt;&lt;/c0&gt; syntax, &lt;a1&gt;it's possible to use it via a Babel plugin&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030427Z" creationid="shibukawa.yoshiki" creationdate="20170131T030427Z">
        <seg>Note: もし&lt;c0&gt;&lt;html&gt;&lt;/c0&gt;という文法を使いたい時は、&lt;a1&gt;Babelプラグイン&lt;/a1&gt;を使うと利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes on Architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T045602Z" creationid="shibukawa.yoshiki" creationdate="20150408T163521Z">
        <seg>アーキテクチャに関するノート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes on the view function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045959Z" creationid="shibukawa.yoshiki" creationdate="20150502T045959Z">
        <seg>view関数に関するメモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how &lt;c0&gt;doBoth&lt;/c0&gt; repeatedly calls &lt;c1&gt;m.startComputation&lt;/c1&gt; since that method calls both &lt;c2&gt;doSomething&lt;/c2&gt; and &lt;c3&gt;doAnother&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005325Z" creationid="shibukawa.yoshiki" creationdate="20150412T005325Z">
        <seg>&lt;c0&gt;doBoth&lt;/c0&gt;は&lt;c2&gt;doSomething&lt;/c2&gt;と&lt;c3&gt;doAnother&lt;/c3&gt;から呼び出されるため、&lt;c1&gt;m.startComputation&lt;/c1&gt;を何度も呼んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that now each component is self-contained: each has a separate route, and each component does exactly one thing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014332Z" creationid="shibukawa.yoshiki" creationdate="20150502T014332Z">
        <seg>これらのコンポーネントは機能別にまとまっています。それぞれ異なったラウターを持ち、それぞれのコンポーネントは1つのタスクだけを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that now your URL will point to &lt;c0&gt;http://localhost/#!/hello&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170203T091501Z" creationid="shibukawa.yoshiki" creationdate="20170203T091501Z">
        <seg>新しいページに移動するとURLは&lt;c0&gt;http://localhost/#!/hello&lt;/c0&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the &lt;c0&gt;ContactList&lt;/c0&gt; does not care about whether &lt;c1&gt;args.contacts&lt;/c1&gt; refers to all the contacts in the database, or just contacts that match some criteria.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005556Z" creationid="shibukawa.yoshiki" creationdate="20150502T005556Z">
        <seg>&lt;c0&gt;ContactList&lt;/c0&gt;リストは&lt;c1&gt;args.contacts&lt;/c1&gt;がデータベース内のすべての連絡先を参照しているか、フィルタリング条件でヒットしたものだけが渡されているのかどうかは知りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the &lt;c4&gt;count&lt;/c4&gt; variable is only updated after the request completes, and it's updated with the response value from the server now.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T151334Z" creationid="shibukawa.yoshiki" creationdate="20170204T151334Z">
        <seg>&lt;c4&gt;count&lt;/c4&gt;変数はリクエストの完了後にのみアップデートされます。そして、この値はサーバーからのレスポンス値で更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the new route has a &lt;c0&gt;:id&lt;/c0&gt; in it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120332Z" creationid="shibukawa.yoshiki" creationdate="20170221T120332Z">
        <seg>新しいラウトの中に&lt;c0&gt;:id&lt;/c0&gt;という文字列があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that we added an &lt;c0&gt;oninit&lt;/c0&gt; method to the component, which references &lt;c1&gt;User.loadList&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T145031Z" creationid="shibukawa.yoshiki" creationdate="20170220T145031Z">
        <seg>コンポーネントに&lt;c0&gt;oninit&lt;/c0&gt;を追加しました。これには&lt;c1&gt;User.loadList&lt;/c1&gt;の参照を持たせています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that we pass a root DOM element to attach our template to, as well as the template itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013700Z" creationid="shibukawa.yoshiki" creationdate="20150408T013700Z">
        <seg>renderメソッドを呼び出す時は、テンプレートそのものに加えて、ルートのDOM要素を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice we added a &lt;c0&gt;User.current&lt;/c0&gt; property, and a &lt;c1&gt;User.load(id)&lt;/c1&gt; method which populates that property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T121117Z" creationid="shibukawa.yoshiki" creationdate="20170221T121117Z">
        <seg>&lt;c0&gt;User.current&lt;/c0&gt;プロパティが追加され、&lt;c1&gt;User.load(id)&lt;/c1&gt;メソッドを呼び出すとこのプロパティに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice we also have a &lt;c0&gt;return&lt;/c0&gt; statement in &lt;c1&gt;loadList&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T120931Z" creationid="shibukawa.yoshiki" creationdate="20170220T120931Z">
        <seg>&lt;c1&gt;loadList&lt;/c1&gt;の中に、&lt;c0&gt;return&lt;/c0&gt;構文があることに気づかれたでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now let's add code to load some data from a server.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055347Z" creationid="shibukawa.yoshiki" creationdate="20170220T055347Z">
        <seg>サーバーから何らかのデータをロードしてくるコードを追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now let's create a contrived component that shows and hides the &lt;c0&gt;FancyComponent&lt;/c0&gt; we created in the previous section:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110152Z" creationid="shibukawa.yoshiki" creationdate="20170206T110152Z">
        <seg>それでは前のセクションで作成した&lt;c0&gt;FancyComponent&lt;/c0&gt;コンポーネントを表示したり隠したりするコンポーネントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now namespace parsing is fully supported, and namespaced attributes should explicitly declare their namespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050446Z" creationid="shibukawa.yoshiki" creationdate="20170201T050446Z">
        <seg>現在は名前空間のパースは完全にサポートされました。名前空間の属性は、その名前空間の中で明示的に定義されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we going to have more than one screen, we use &lt;c0&gt;m.route&lt;/c0&gt; instead of &lt;c1&gt;m.mount&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032240Z" creationid="shibukawa.yoshiki" creationdate="20170131T032240Z">
        <seg>アプリケーションが複数のスクリーンを扱う時は&lt;c1&gt;m.mount()&lt;/c1&gt;の代わりに&lt;c0&gt;m.route()&lt;/c0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you are comfortable with the basics of the Mithril API, &lt;a0&gt;be sure to check out the simple application tutorial&lt;/a0&gt;, which walks you through building a realistic application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T235701Z" creationid="shibukawa.yoshiki" creationdate="20170204T235701Z">
        <seg>Mithril APIの基本についてはここまでの説明で触れたところで十分に快適に使えます。&lt;a0&gt;シンプルなアプリケーションを作成するチュートリアル&lt;/a0&gt;は、より実践的なアプリケーションの構築方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can define routes and map our components to them:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T101021Z" creationid="shibukawa.yoshiki" creationdate="20170207T101021Z">
        <seg>コンポーネントがそろったら、コンポーネントとラウトを対応付けます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can style the &lt;c0&gt;UserList&lt;/c0&gt; component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T045638Z" creationid="shibukawa.yoshiki" creationdate="20170221T045638Z">
        <seg>これで&lt;c0&gt;UserList&lt;/c0&gt;コンポーネントにスタイルを追加することができるようになりました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, let's change the text to something else.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025758Z" creationid="shibukawa.yoshiki" creationdate="20170131T025758Z">
        <seg>別のテキストに変えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, let's create a view module so that we can display data from our User model module.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121220Z" creationid="shibukawa.yoshiki" creationdate="20170220T121220Z">
        <seg>それでは今作成したユーザーモデルモジュールのデータを表示できるように、ビューモジュールを作成しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, let's reference the list of users from the model we created earlier (&lt;c0&gt;User.list&lt;/c0&gt;) to dynamically loop through data:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T133740Z" creationid="shibukawa.yoshiki" creationdate="20170220T133740Z">
        <seg>それでは、以前作成したモデル (&lt;c0&gt;User.list&lt;/c0&gt;) のユーザーのリストを参照し、各要素に対してループを回してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nowadays, browsers have good support for CSS animations, and there are &lt;a0&gt;various&lt;/a0&gt; &lt;a1&gt;libraries&lt;/a1&gt; that provide fast Javascript-based animations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T104919Z" creationid="shibukawa.yoshiki" creationdate="20170206T104919Z">
        <seg>今日のブラウザはCSSアニメーションをサポートしていますし、JavaScriptベースの高速なアニメーションをサポートする&lt;a0&gt;さまざまな&lt;/a0&gt;&lt;a1&gt;ライブラリ&lt;/a1&gt;もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Number (e.g. 1,234.5)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143506Z" creationid="shibukawa.yoshiki" creationdate="20160412T143506Z">
        <seg>数値 (例 1,234.5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously you can use whatever spacing/indentation convention you prefer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T050217Z" creationid="shibukawa.yoshiki" creationdate="20170221T050217Z">
        <seg>もちろん、スペースとインデントを使うルールが好みであればそれを使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, a &lt;c0&gt;deserialize&lt;/c0&gt; function may be more elaborate:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004903Z" creationid="shibukawa.yoshiki" creationdate="20170220T004903Z">
        <seg>もちろん、&lt;c0&gt;deserialize&lt;/c0&gt;関数により複雑な処理をさせることも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, web services return the relevant data wrapped in objects that contain metadata.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174025Z" creationid="shibukawa.yoshiki" creationdate="20150410T174025Z">
        <seg>少なくない数のウェブサービスが、それぞれのデータをメタデータ入りのオブジェクトでラップして返してきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, you will want to do some work before the component is unloaded (i.e. clear timers or unsubscribe event handlers):</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091614Z" creationid="shibukawa.yoshiki" creationdate="20150502T091614Z">
        <seg>コンポーネントをアンロードする前にタイマーをクリアしたり、イベントハンドラを削除したり、何か仕事をしたくなることがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older docs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T033512Z" creationid="shibukawa.yoshiki" creationdate="20170131T033512Z">
        <seg>古いドキュメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the one hand, it's extremely easy to reason about the behavior of the components since they only serve a single purpose, but on the other hand they don't have the flexibility that the previous example did (e.g. in this iteration, &lt;c0&gt;ContactList&lt;/c0&gt; can only list all of the contacts in the database, not an arbitrary subset.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015307Z" creationid="shibukawa.yoshiki" creationdate="20150502T015307Z">
        <seg>それぞれのコンポーネントは個別の目的のために提供されているため、動作を理解するのは簡単ですが、前述のサンプルのような柔軟性はありません。&lt;c0&gt;ContactList&lt;/c0&gt;は全連絡先のリストを表示するのにしか使えず、サブセットの表示はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if you were to call a web service using jQuery, then you would be responsible for adding a &lt;c0&gt;m.startComputation&lt;/c0&gt; call before the jQuery ajax call, and for adding a &lt;c1&gt;m.endComputation&lt;/c1&gt; call at the end of the completion callback, in addition to the calls within the &lt;c2&gt;change&lt;/c2&gt; event handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134953Z" creationid="shibukawa.yoshiki" creationdate="20150412T134826Z">
        <seg>そうではなくjQueryを使ってウェブサービス呼び出しをしているのであれば、&lt;c2&gt;change&lt;/c2&gt;イベントハンドラ内にこの関数のペアを置く以外に、jQueryのajax呼び出しの前に&lt;c0&gt;m.startComputation&lt;/c0&gt;を追加し、コールバックが完了した後に&lt;c1&gt;m.endComputation&lt;/c1&gt;呼び出しを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, javascript developers rarely ever throw errors that are subclasses of Error, and for the purposes of application error handling, the underlying prototypal chain of the error class is typically not relevant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174723Z" creationid="shibukawa.yoshiki" creationdate="20150415T174723Z">
        <seg>言い換えると、JavaScript開発者は例外に関して、アプリケーションのエラーハンドリングを目的としてErrorのサブクラスを作って投げることはほとんどありません。Errorのプロトタイプチェーンを気にすることはほとんどありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once each request completes, the counter is decremented.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154500Z" creationid="shibukawa.yoshiki" creationdate="20150416T154500Z">
        <seg>リクエストが完了するたびにカウンタが減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once resolved, the placeholder is replaced with component B's view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094557Z" creationid="shibukawa.yoshiki" creationdate="20150502T094557Z">
        <seg>非同期処理が完了すると、プレースホルダは実際のコンポーネントBのビューに置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once that counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190035Z" creationid="shibukawa.yoshiki" creationdate="20150411T190035Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the controller code finishes executing (and this may include waiting for AJAX requests to complete), the view class is instantiated, and the instance of the controller is passed as an argument to the view's constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T021045Z" creationid="shibukawa.yoshiki" creationdate="20150414T021045Z">
        <seg>コントローラコードの実行が完了すると(AJAXのリクエストの完了待ちも含む)ビュークラスのインスタンスが作られ、ビューのコンストラクタにコントローラのインスタンスが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154159Z" creationid="shibukawa.yoshiki" creationdate="20150416T154159Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the request to the server completes, the array of objects &lt;c6&gt;items&lt;/c6&gt; is assigned to &lt;c7&gt;Data.todos.list&lt;/c7&gt; and the component is rendered again, yielding a list of &lt;c8&gt;&lt;div&gt;&lt;/c8&gt;s containing the titles of each todo.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T144235Z" creationid="shibukawa.yoshiki" creationdate="20170219T144235Z">
        <seg>サーバーからレスポンスが返ってくると、オブジェクトの配列の&lt;c6&gt;items&lt;/c6&gt;が&lt;c7&gt;Data.todos.list&lt;/c7&gt;に割り当てられ、再描画が行われ、ToDoのタイトルが格納されている&lt;c8&gt;&lt;div&gt;&lt;/c8&gt;タグが挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the user pressed the login button, &lt;c3&gt;isLoggedIn&lt;/c3&gt; would be set to true, and the application would redirect to &lt;c4&gt;/secret&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075323Z" creationid="shibukawa.yoshiki" creationdate="20170208T075323Z">
        <seg>ユーザーがログインすると、&lt;c3&gt;isLoggedIn&lt;/c3&gt;がtrueに設定され、アプリケーションは&lt;c4&gt;/secret&lt;/c4&gt;にリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have Node.js and NPM installed, open the command line and run this command:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071400Z" creationid="shibukawa.yoshiki" creationdate="20170207T071400Z">
        <seg>Node.jsとnpmがインストールされたら、コマンドラインを開き、次のコマンドを入力します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have a &lt;a0&gt;copy of Mithril&lt;/a0&gt;, getting started is surprisingly boilerplate-free:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142648Z" creationid="shibukawa.yoshiki" creationdate="20150407T142648Z">
        <seg>&lt;a0&gt;Mithrilのインストール&lt;/a0&gt;をしたらコーディングを開始しましょう。Mithrilは、決まり文句がとても少ない、小さなHTMLから開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have a project skeleton with Mithril installed, we are ready to create the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055303Z" creationid="shibukawa.yoshiki" creationdate="20170220T055303Z">
        <seg>Mithrilがインストールされたプロジェクトのスケルトンができると、アプリケーションを作成する準備が整いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One caveat of using the CSS syntax is that it clobbers the &lt;c0&gt;style&lt;/c0&gt; attribute in the DOM element on redraws, so this syntax is not appropriate if you need to use it in conjunction with 3rd party tools that modify the element's style outside of Mithril's templates (e.g. via &lt;c1&gt;config&lt;/c1&gt;, which is explained below)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014630Z" creationid="shibukawa.yoshiki" creationdate="20150413T014630Z">
        <seg>注意点としては、CSS文法を使うとDOM要素の再描画の時に&lt;c0&gt;style&lt;/c0&gt;属性が強制的にテンプレートで設定されたスタイルに上書きされます。そのため、Mithrilのテンプレートの外からスタイルを変更するようなサードパーティ製ツールを使用する必要があるときは、CSS文法を避けてください。この後の&lt;c1&gt;config&lt;/c1&gt;の項目で詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One common way of using &lt;c0&gt;config&lt;/c0&gt; is in conjunction with &lt;a1&gt;&lt;c2&gt;m.route&lt;/c2&gt;&lt;/a1&gt;, which is an unobtrusive extension to links that allow Mithril's routing system to work transparently regardless of which routing mode is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124149Z" creationid="shibukawa.yoshiki" creationdate="20150413T123936Z">
        <seg>設定&lt;c0&gt;config&lt;/c0&gt;の一般的な使用法の１つに、&lt;a1&gt;&lt;c2&gt;m.route&lt;/c2&gt;&lt;/a1&gt;と一緒に使用して、設定されているラウティングモードにかかわらず、透過的に動作するようにリンクを拡張するというものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One extremely important aspect of this architecture is that since components encapsulate their internal state, then by definition it's harder to reason about AJAX request redundancy (i.e. how to prevent two identical AJAX requests originating from two different components).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021953Z" creationid="shibukawa.yoshiki" creationdate="20150502T021953Z">
        <seg>このアーキテクチャの注意点としては、コンポーネントが内部状態をカプセル化しているため、AJAXアクセスが冗長になってしまうのを防ぐのが難しいということがあります。異なるコンポーネントがまったく同じAJAXアクセスを行うのを防ぐ方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important limitation to be aware of when using components is that you cannot call Mithril's redrawing methods (&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; and &lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt;) from templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094813Z" creationid="shibukawa.yoshiki" creationdate="20150502T094813Z">
        <seg>一番重要な制限は、テンプレートの中からMithrilの再描画メソッド(&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;&lt;/a0&gt; / &lt;a3&gt;&lt;c4&gt;m.redraw&lt;/c4&gt;&lt;/a3&gt;)を呼び出すことができないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important note about the &lt;c0&gt;config&lt;/c0&gt; method is that you should avoid calling &lt;c1&gt;m.redraw&lt;/c1&gt;, &lt;c2&gt;m.startComputation&lt;/c2&gt; and &lt;c3&gt;m.endComputation&lt;/c3&gt; in the &lt;c4&gt;config&lt;/c4&gt; function's execution thread.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135443Z" creationid="shibukawa.yoshiki" creationdate="20150412T135443Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;メソッドについて注意すべきことは、&lt;c4&gt;config&lt;/c4&gt;関数の実行スレッド内では、&lt;c1&gt;m.redraw&lt;/c1&gt;、&lt;c2&gt;m.startComputation&lt;/c2&gt;、&lt;c3&gt;m.endComputation&lt;/c3&gt;を呼び出さないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of its selling points is that it allows developers to leverage their existing jQuery knowledge, while providing some "walls" to organize the code in a more structured manner.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020006Z" creationid="shibukawa.yoshiki" creationdate="20150420T020006Z">
        <seg>開発者に対するBackboneのセールスポイントの1つは、既存のjQueryの知識を活かした上で、コードをきちんと構造化するための「ついたて」を提供するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most obvious differences between Mithril and most frameworks is in file size: Mithril is around 7.8 kB gzipped and has no dependencies on other libraries.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141537Z" creationid="shibukawa.yoshiki" creationdate="20160412T141537Z">
        <seg>Mithrilと他のフレームワークの違いの中で、もっとも分かりやすいものはファイルサイズです。Mithrilはgzip圧縮された状態で7.8kb前後で、他のライブラリへの依存もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One other difference that is extremely clear is the treatment of data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015651Z" creationid="shibukawa.yoshiki" creationdate="20150420T015651Z">
        <seg>他に大きく異る点は、データの取り扱いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One related difference is that other frameworks often have hard-coded base classes where every conceivable convenience method gets inherited by the developer's classes (remember, in Javascript, this can mean copying all of the utility methods over to the child class, regardless of whether they're going to be used or not).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145321Z" creationid="shibukawa.yoshiki" creationdate="20150417T145321Z">
        <seg>これに関連する他のフレームワークとの違いとして、これらのフレームワークはよく、考えつく限りの便利なメソッドが満載になったフレームワーク固有のベースクラスを提供していて、開発者のクラスにこれを継承させます。実際に使うかどうかにかかわらず、JavaScriptではこれらのユーティリティメソッドもすべて子クラスにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One technical aspect that is also different is that Backbone is heavily event-oriented.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020723Z" creationid="shibukawa.yoshiki" creationdate="20150420T020719Z">
        <seg>技術的な側面での大きな違いは、Backboneがイベント駆動に重きをおいている点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One thing you may have noticed on the &lt;a0&gt;Mithril homepage&lt;/a0&gt; is that, out of the box, Angular is not as performant as other frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094331Z" creationid="shibukawa.yoshiki" creationdate="20150420T094331Z">
        <seg>もう1点、&lt;a0&gt;Mithrilホームページ&lt;/a0&gt;を見て分かるように、Angularは他のフレームワークよりもパフォーマンスで引けを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One typical way to override this is to receive as-is responses.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175213Z" creationid="shibukawa.yoshiki" creationdate="20150410T175213Z">
        <seg>よくある変更方法としては、変換せずに帰ってきた入力をそのままアプリケーションに渡す方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way of organizing components is to use component parameter lists to send data downstream, and to define events to bubble data back upstream to a centralized module who is responsible for interfacing with the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000307Z" creationid="shibukawa.yoshiki" creationdate="20150502T000307Z">
        <seg>コンポーネントの組み立て方の１つの例としては、コンポーネントのパラメータリストを使ってデータを下流に流すと共に、モデルレイヤとのインタフェースとなっている中心のモジュールまでバブリングしてデータを上流に戻すイベントを定義するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to wrap the layout is to define an anonymous component in the routes map:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T070944Z" creationid="shibukawa.yoshiki" creationdate="20170208T070944Z">
        <seg>レイアウトでラップする方法の１つは、ラウトの定義のマップの中で無名コンポーネントを定義する方法です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only 7.8 kB gzipped, no dependencies</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T144538Z" creationid="shibukawa.yoshiki" creationdate="20160412T144538Z">
        <seg>gzip圧縮時でたったの7.8KBで、他への依存がない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only tag, id, class and attribute selectors are supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150610Z" creationid="shibukawa.yoshiki" creationdate="20150413T150610Z">
        <seg>タグ、ID、クラス、属性セレクタのみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening the HTML file in a browser should now display a list of person names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T152601Z" creationid="shibukawa.yoshiki" creationdate="20170220T152601Z">
        <seg>HTMLファイルをブラウザで開くと、人名のリストが表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing Performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141712Z" creationid="shibukawa.yoshiki" creationdate="20150412T141712Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing Performance - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141653Z" creationid="shibukawa.yoshiki" creationdate="20150412T141653Z">
        <seg>パフォーマンスの最適化 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015824Z" creationid="shibukawa.yoshiki" creationdate="20150409T015824Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opting out of the auto redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050758Z" creationid="shibukawa.yoshiki" creationdate="20150502T050758Z">
        <seg>自動再描画システムの対象から外す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111857Z" creationid="shibukawa.yoshiki" creationdate="20170206T111857Z">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional controller</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045932Z" creationid="shibukawa.yoshiki" creationdate="20150502T045932Z">
        <seg>オプショナルなコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or even use the &lt;a0&gt;&lt;c1&gt;history state&lt;/c1&gt;&lt;/a0&gt; feature to achieve reloadable components without polluting the URL:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T061254Z" creationid="shibukawa.yoshiki" creationdate="20170208T061254Z">
        <seg>あるいは、&lt;a0&gt;&lt;c1&gt;ヒストリー状態&lt;/c1&gt;&lt;/a0&gt;の機能を使うと、URLを変更せずにリロード可能なコンポーネントを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other arguments to be bound as arguments to both the &lt;c0&gt;controller&lt;/c0&gt; and &lt;c1&gt;view&lt;/c1&gt; functions</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100647Z" creationid="shibukawa.yoshiki" creationdate="20150502T100647Z">
        <seg>&lt;c0&gt;controller&lt;/c0&gt;と&lt;c1&gt;view&lt;/c1&gt;関数に束縛されるそれ以外の引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other things that can be expensive include large or dynamically scaled images and overlapping elements with different &lt;c2&gt;position&lt;/c2&gt; values (e.g. an absolute postioned element over a fixed element).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111757Z" creationid="shibukawa.yoshiki" creationdate="20170206T111757Z">
        <seg>それ以外では巨大な画像を使ったり、ダイナミックに画像をスケールさせたり、&lt;c2&gt;position&lt;/c2&gt;の値が異なる要素同士のオーバーラップ（fixedに対してabsoluteが重なる）も高コストになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others, like &lt;a1&gt;Tachyons&lt;/a1&gt; provide a large number of self-describing, atomic class names at the cost of making the class names themselves non-semantic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T153703Z" creationid="shibukawa.yoshiki" creationdate="20170220T153703Z">
        <seg>一方で、&lt;a1&gt;Tachyons&lt;/a1&gt;のように、たくさんの自己記述型のアトミックではあるものの、意味を持たないクラス名にするというコストを支払っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it follows the Promises/A+ specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174356Z" creationid="shibukawa.yoshiki" creationdate="20150415T174356Z">
        <seg>そうでない場合は、Promises/A+の仕様に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, &lt;c3&gt;vnode.tag&lt;/c3&gt; is set to &lt;c4&gt;"div"&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090428Z" creationid="shibukawa.yoshiki" creationdate="20170207T090428Z">
        <seg>返さない時は&lt;c3&gt;vnode.tag&lt;/c3&gt;には&lt;c4&gt;"div"&lt;/c4&gt;が設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our next step is to write a view-model that will use our model classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152255Z" creationid="shibukawa.yoshiki" creationdate="20150407T152255Z">
        <seg>次のステップとして、モデルクラスを使用する、ビュー・モデルを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134431Z" creationid="shibukawa.yoshiki" creationdate="20150407T134431Z">
        <seg>出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterized components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050010Z" creationid="shibukawa.yoshiki" creationdate="20150502T050010Z">
        <seg>パラメータ化されたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterized initial state</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050614Z" creationid="shibukawa.yoshiki" creationdate="20150502T050614Z">
        <seg>パラメータの初期状態</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterizes a component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045801Z" creationid="shibukawa.yoshiki" creationdate="20150502T045801Z">
        <seg>コンポーネントのパラメータ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters to pass as a querystring</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171527Z" creationid="shibukawa.yoshiki" creationdate="20150414T171527Z">
        <seg>クエリー文字列として渡されるパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parts of the UI may be redrawn after an &lt;c0&gt;oninit&lt;/c0&gt; handler, but other parts of the UI may already have been redrawn when a given &lt;c1&gt;oninit&lt;/c1&gt; handler fires.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121603Z" creationid="shibukawa.yoshiki" creationdate="20170206T121603Z">
        <seg>UIの一部は&lt;c0&gt;oninit&lt;/c0&gt;ハンドラの後に再描画されますが、UIの他の部分は指定の&lt;c1&gt;oninit&lt;/c1&gt;ハンドラが起動した時にすでに再描画されているでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing components to &lt;c0&gt;m()&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034143Z" creationid="shibukawa.yoshiki" creationdate="20170131T034143Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;にコンポーネントを渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing vnodes to &lt;c0&gt;m.mount()&lt;/c0&gt; and &lt;c1&gt;m.route()&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034235Z" creationid="shibukawa.yoshiki" creationdate="20170131T034235Z">
        <seg>&lt;c0&gt;m.mount()&lt;/c0&gt;と&lt;c1&gt;m.route()&lt;/c1&gt;にVノードを渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134435Z" creationid="shibukawa.yoshiki" creationdate="20150407T134435Z">
        <seg>パフォーマンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persisting DOM elements across route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121529Z" creationid="shibukawa.yoshiki" creationdate="20150502T121529Z">
        <seg>ラウト変更前後でのDOMエレメントの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persisting config data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234205Z" creationid="shibukawa.yoshiki" creationdate="20150412T234205Z">
        <seg>設定データの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Plain CSS can be sufficient for low-complexity projects (e.g. 3 to 6 man-months of initial implementation time and few project phases).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T045542Z" creationid="shibukawa.yoshiki" creationdate="20170221T045542Z">
        <seg>プレーンなCSSでも複雑さの低いプロジェクト（例えば最初の実装工数が3-6人月でフェーズが少ない）では十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please use either 0.2.0 or latest instead</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135651Z" creationid="shibukawa.yoshiki" creationdate="20160412T135651Z">
        <seg>0.2.1、もしくは最新版を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Post questions and discuss Mithril related topics.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135754Z" creationid="shibukawa.yoshiki" creationdate="20150407T135754Z">
        <seg>質問を投稿したり、Mithril関連の話題について議論をするメーリングリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preloading data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075927Z" creationid="shibukawa.yoshiki" creationdate="20170208T075927Z">
        <seg>データのプリロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing redraws on events</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125106Z" creationid="shibukawa.yoshiki" creationdate="20150416T125106Z">
        <seg>イベントによる再描画の阻止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing unmounting</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034508Z" creationid="shibukawa.yoshiki" creationdate="20170131T034508Z">
        <seg>アンマウントを停止させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing web service data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123850Z" creationid="shibukawa.yoshiki" creationdate="20150410T123850Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-web-service-data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174506Z" creationid="shibukawa.yoshiki" creationdate="20150414T174506Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Promises also have a method called &lt;c0&gt;catch&lt;/c0&gt;, which is equivalent to calling &lt;c1&gt;then(null, errorCallback)&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T050924Z" creationid="shibukawa.yoshiki" creationdate="20160423T050924Z">
        <seg>Promiseの&lt;c0&gt;catch&lt;/c0&gt;メソッド呼び出しは、&lt;c1&gt;then(null, errorCallback)&lt;/c1&gt;と等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Promises are not the response data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034426Z" creationid="shibukawa.yoshiki" creationdate="20170220T034426Z">
        <seg>Promiseはレスポンスデータそのものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Promises returned by &lt;a0&gt;m.request&lt;/a0&gt; are no longer &lt;c1&gt;m.prop&lt;/c1&gt; getter-setters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045217Z" creationid="shibukawa.yoshiki" creationdate="20170201T045159Z">
        <seg>&lt;a0&gt;m.request&lt;/a0&gt;が返すPromiseは&lt;c1&gt;m.prop()&lt;/c1&gt;ゲッター・セッターではなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Publishing a GitHub release</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054807Z" creationid="shibukawa.yoshiki" creationdate="20170220T054807Z">
        <seg>GitHubにリリースを公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Publishing to NPM</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054108Z" creationid="shibukawa.yoshiki" creationdate="20170220T054108Z">
        <seg>NPMへの公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querystring parameters in a route are also available in this collection automatically.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170737Z" creationid="shibukawa.yoshiki" creationdate="20150414T170737Z">
        <seg>ラウト中のクエリー文字列のパラメータもこのコレクションに自動的に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queuing Operations</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125333Z" creationid="shibukawa.yoshiki" creationdate="20150410T125333Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queuing operations</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174524Z" creationid="shibukawa.yoshiki" creationdate="20150414T174524Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rationale: Mithril modules and components are the same thing, therefore from now on, they will be referred to as components, since that name is more descriptive of their purpose, and causes less confusion in the face of ES6 modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141319Z" creationid="shibukawa.yoshiki" creationdate="20160412T141319Z">
        <seg>理由: Mithrilのモジュールとコンポーネントは結果として同じものとなったため、今後はコンポーネントと呼称することになった。コンポーネントのという名前の方が目的を明確に伝えることが出来、ES6のモジュールと混乱することが減るためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>React is a component engine developed by Facebook.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095613Z" creationid="shibukawa.yoshiki" creationdate="20150420T095613Z">
        <seg>ReactはFacebookによって開発されたコンポーネントエンジンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read Guide</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135559Z" creationid="shibukawa.yoshiki" creationdate="20150407T135559Z">
        <seg>ガイドを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an argument from a parameterized route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153708Z" creationid="shibukawa.yoshiki" creationdate="20150412T153708Z">
        <seg>パラメータ化されたラウトから引数の読み込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read articles</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135714Z" creationid="shibukawa.yoshiki" creationdate="20150407T135714Z">
        <seg>記事を読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read docs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135625Z" creationid="shibukawa.yoshiki" creationdate="20150407T135625Z">
        <seg>ドキュメントを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the current route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153306Z" creationid="shibukawa.yoshiki" creationdate="20150412T153306Z">
        <seg>現在のラウトを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152451Z" creationid="shibukawa.yoshiki" creationdate="20150414T152451Z">
        <seg>現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading/writing the current route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034257Z" creationid="shibukawa.yoshiki" creationdate="20170131T034257Z">
        <seg>現在のラウトの読み込み/書き込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012905Z" creationid="shibukawa.yoshiki" creationdate="20150410T012905Z">
        <seg>リダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirects to a matching route, or to the default route if no matching routes can be found.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080449Z" creationid="shibukawa.yoshiki" creationdate="20170207T080449Z">
        <seg>マッチするラウト、もしくはマッチするラウトがなければデフォルトのラウトにリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirects to a route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153249Z" creationid="shibukawa.yoshiki" creationdate="20150412T153249Z">
        <seg>ラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redraw locking can lead to buggy UIs: the concerns of one part of the application should not be allowed to prevent other parts of the view from updating to reflect change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120652Z" creationid="shibukawa.yoshiki" creationdate="20170131T120652Z">
        <seg>再描画のロックはUIのバグを引き起こすことがありました。アプリケーションの一部がビューの一部の更新を停止することで、他の部分で変更が反映されないことがありました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redrawing semantics of routing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140401Z" creationid="shibukawa.yoshiki" creationdate="20160101T140401Z">
        <seg>ラウティングのおける再描画のセマンティクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to the &lt;a3&gt;&lt;c4&gt;auto-redrawing&lt;/c4&gt;&lt;/a3&gt; guide for an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135018Z" creationid="shibukawa.yoshiki" creationdate="20150412T135018Z">
        <seg>サンプルについては&lt;a3&gt;&lt;c4&gt;自動描画システム&lt;/c4&gt;&lt;/a3&gt;のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refreshing the page in the browser should now append &lt;c0&gt;#!/list&lt;/c0&gt; to the URL to indicate that routing is working.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115621Z" creationid="shibukawa.yoshiki" creationdate="20170221T115621Z">
        <seg>ブラウザのページをリフレッシュするとURLに&lt;c0&gt;#!/list&lt;/c0&gt;が付与されて、ラウティング機構が稼働していることが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of what CSS convention/library you choose, a good rule of thumb is to avoid the cascading aspect of CSS.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T035707Z" creationid="shibukawa.yoshiki" creationdate="20170221T035707Z">
        <seg>どのようなCSSの表記法やライブラリを使ったとしても、CSSのカスケーディング機能を避けることが大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless, you could also force multiple redraws to happen by using the &lt;a1&gt;&lt;c2&gt;background&lt;/c2&gt;&lt;/a1&gt; and &lt;c3&gt;initialValue&lt;/c3&gt; options in &lt;c4&gt;m.request&lt;/c4&gt;, or by manually calling &lt;a5&gt;&lt;c6&gt;m.redraw()&lt;/c6&gt;&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094358Z" creationid="shibukawa.yoshiki" creationdate="20150502T094149Z">
        <seg>特に気にしなければ、&lt;a1&gt;&lt;c2&gt;background&lt;/c2&gt;&lt;/a1&gt;オプションと&lt;c3&gt;initialValue&lt;/c3&gt;オプションを付けて&lt;c4&gt;m.request&lt;/c4&gt;を呼び出すか、手動で&lt;a5&gt;&lt;c6&gt;m.redraw()&lt;/c6&gt;&lt;/a5&gt;を呼び出せば、何度か強制的に再描画させることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Relative (e.g. 10 days ago)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143456Z" creationid="shibukawa.yoshiki" creationdate="20160412T143456Z">
        <seg>相対 (例 10 days ago)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Released under the &lt;a0&gt;MIT license&lt;/a0&gt; &lt;br1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000937Z" creationid="shibukawa.yoshiki" creationdate="20150408T000937Z">
        <seg>&lt;a0&gt;MITライセンス&lt;/a0&gt;でリリースされています&lt;br1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Released under the &lt;a0&gt;MIT license&lt;/a0&gt;&lt;br1/&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135930Z" creationid="shibukawa.yoshiki" creationdate="20150407T135930Z">
        <seg>&lt;a0&gt;MITライセンス&lt;/a0&gt;でリリースされています&lt;br1/&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Releasing - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054024Z" creationid="shibukawa.yoshiki" creationdate="20170220T054024Z">
        <seg>リリース - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Releasing new builds of mithril is mostly automated via &lt;c0&gt;npm version&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054059Z" creationid="shibukawa.yoshiki" creationdate="20170220T054059Z">
        <seg>Mithrilの新バージョンのリリースは&lt;c0&gt;npm version&lt;/c0&gt;を使ってほぼ自動化されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reloading the browser window now should display some styled elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T052210Z" creationid="shibukawa.yoshiki" creationdate="20170221T052210Z">
        <seg>ブラウザウィンドウをリロードすると、スタイルが設定された要素が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that &lt;c0&gt;m.render&lt;/c0&gt; expects a vnode tree, and &lt;c1&gt;m.mount&lt;/c1&gt; expects a component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T132657Z" creationid="shibukawa.yoshiki" creationdate="20170206T132657Z">
        <seg>&lt;c0&gt;m.render&lt;/c0&gt;はvnodeツリーを受け取り、&lt;c1&gt;m.mount&lt;/c1&gt;はコンポーネントを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that the rules for keys apply to components the same way they do to regular elements: it is not allowed to have duplicate keys on children of the same parent, and they must be either strings or numbers (or something with a &lt;c0&gt;.toString()&lt;/c0&gt; implementation that makes the entity uniquely identifiable in the local scope when serialized).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090821Z" creationid="shibukawa.yoshiki" creationdate="20150502T090821Z">
        <seg>キーの適用のルールは通常のエレメントと同じです。同じ親の子供が同じキーを持つことはできません。またキーは文字列か数字、もしくは&lt;c0&gt;.toString()&lt;/c0&gt;メソッドを持っていてローカルスコープ内でユニークなキーを生成できる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135029Z" creationid="shibukawa.yoshiki" creationdate="20150407T135029Z">
        <seg>レンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering Components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125012Z" creationid="shibukawa.yoshiki" creationdate="20150502T125012Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering before web service requests finish</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174714Z" creationid="shibukawa.yoshiki" creationdate="20150414T174714Z">
        <seg>ウェブサービスのリクエスト完了前のレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045857Z" creationid="shibukawa.yoshiki" creationdate="20150502T045857Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Renders a component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045812Z" creationid="shibukawa.yoshiki" creationdate="20150502T045812Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request URLs may contain interpolations:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152357Z" creationid="shibukawa.yoshiki" creationdate="20170219T151654Z">
        <seg>リクエストするURLには変数（interpolation）を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133126Z" creationid="shibukawa.yoshiki" creationdate="20170206T133126Z">
        <seg>必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024710Z" creationid="shibukawa.yoshiki" creationdate="20170131T024710Z">
        <seg>リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieving a value via the getter-setter API</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014904Z" creationid="shibukawa.yoshiki" creationdate="20150415T014904Z">
        <seg>getter-setter APIを使ったデータの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieving response details</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T161026Z" creationid="shibukawa.yoshiki" creationdate="20170219T161026Z">
        <seg>レスポンスの詳細を取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning an array, a string, a number, boolean, falsy value, etc will result in an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095709Z" creationid="shibukawa.yoshiki" creationdate="20150502T095709Z">
        <seg>配列、文字列、数値、ブーリアン、負になる値などを返すとエラーになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;c0&gt;undefined&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080410Z" creationid="shibukawa.yoshiki" creationdate="20170207T080410Z">
        <seg>&lt;c0&gt;undefined&lt;/c0&gt;を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a component or a promise that resolves to a component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090102Z" creationid="shibukawa.yoshiki" creationdate="20170207T090102Z">
        <seg>コンポーネントまたは、解決時にコンポーネントが格納されるPromiseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a vnode</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T091709Z" creationid="shibukawa.yoshiki" creationdate="20170207T091709Z">
        <seg>Vノードを返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an event handler that calls &lt;c0&gt;m.route.set&lt;/c0&gt; with the link's &lt;c1&gt;href&lt;/c1&gt; as the &lt;c2&gt;path&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084431Z" creationid="shibukawa.yoshiki" creationdate="20170207T084357Z">
        <seg>&lt;c1&gt;href&lt;/c1&gt;のURLをMithrilのラウターの &lt;c2&gt;パス&lt;/c2&gt;として&lt;c0&gt;m.route.set&lt;/c0&gt;に渡すイベントハンドラの関数を作成して返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the last fully resolved path</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082602Z" creationid="shibukawa.yoshiki" creationdate="20170207T082602Z">
        <seg>最後に解決されたラウトのパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the last fully resolved routing path, without the prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082448Z" creationid="shibukawa.yoshiki" creationdate="20170207T082448Z">
        <seg>最後に解決されたラウトのパスをプリフィックスなしで返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Right now, the list looks rather plain because we have not defined any styles.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T152700Z" creationid="shibukawa.yoshiki" creationdate="20170220T152700Z">
        <seg>この状態だと何もスタイルを設定されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Right now, this component does nothing to respond to user events.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120815Z" creationid="shibukawa.yoshiki" creationdate="20170221T120815Z">
        <seg>この状態では表示はできますが、ユーザーイベントには反応するようになっていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roadmap</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154253Z" creationid="shibukawa.yoshiki" creationdate="20150412T154253Z">
        <seg>ロードマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Robust</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133440Z" creationid="shibukawa.yoshiki" creationdate="20150407T133440Z">
        <seg>信頼性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Route parameters are dynamic values that can be extracted from the URL based on the signature of the currently active route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170523Z" creationid="shibukawa.yoshiki" creationdate="20150414T170523Z">
        <seg>ラウトのパラメータは、現在アクティブなラウトのシグニチャを元にして、現在のURLから取り出された動的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Route parameters become &lt;c2&gt;attrs&lt;/c2&gt; in the vnode.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055340Z" creationid="shibukawa.yoshiki" creationdate="20170208T055340Z">
        <seg>ラウとパラメータはvnodeの&lt;c2&gt;attrs&lt;/c2&gt;プロパティとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RouteResolver</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084439Z" creationid="shibukawa.yoshiki" creationdate="20170207T084439Z">
        <seg>ラウトリゾルバ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RouteResolvers are useful for implementing a variety of advanced routing use cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064920Z" creationid="shibukawa.yoshiki" creationdate="20170208T064920Z">
        <seg>ラウトリゾルバーは、さまざまな高度なルーティングのユースケースを実装するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RouteResolvers can be used as a mechanism to preload data before rendering a component in order to avoid UI flickering and thus bypassing the need for a loading indicator:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T081646Z" creationid="shibukawa.yoshiki" creationdate="20170208T081646Z">
        <seg>ラウトリゾルバーを使って、UIのフリッカーを回避するためにコンポーネントのレンダリング前にデータのプリロードを行い、代わりにロード中のインジケーターを表示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon &lt;c0&gt;:&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153420Z" creationid="shibukawa.yoshiki" creationdate="20150414T153420Z">
        <seg>&lt;c0&gt;:&lt;/c0&gt;を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon &lt;c0&gt;:&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003039Z" creationid="shibukawa.yoshiki" creationdate="20150410T003039Z">
        <seg>&lt;c0&gt;:&lt;/c0&gt;を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes with querystrings</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152326Z" creationid="shibukawa.yoshiki" creationdate="20150414T152326Z">
        <seg>ラウトとクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015810Z" creationid="shibukawa.yoshiki" creationdate="20150407T140735Z">
        <seg>ラウティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015956Z" creationid="shibukawa.yoshiki" creationdate="20150409T015956Z">
        <seg>ラウティング - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from a "page" to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T091807Z" creationid="shibukawa.yoshiki" creationdate="20170207T091807Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from a page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152527Z" creationid="shibukawa.yoshiki" creationdate="20150414T152527Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from one page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020138Z" creationid="shibukawa.yoshiki" creationdate="20150409T020138Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is single-page-application (SPA) friendly, and can be implemented using either &lt;c0&gt;location.hash&lt;/c0&gt;, HTML5 URL rewriting or &lt;c1&gt;location.querystring&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153216Z" creationid="shibukawa.yoshiki" creationdate="20150414T153216Z">
        <seg>ラウトはシングルページアプリケーション(SPA)を実現しやすくする仕組みで、 &lt;c0&gt;location.hash&lt;/c0&gt;、HTML5のURL書き換え、&lt;c1&gt;location.querystring&lt;/c1&gt;のどれかの方法を使って実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing just means going from one screen to another in an application with several screens.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031847Z" creationid="shibukawa.yoshiki" creationdate="20170131T031847Z">
        <seg>ラウティングは、アプリケーション内のいくつかのスクリーン間で移動することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing means binding a screen to a unique URL, to create the ability to go from one "page" to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T052324Z" creationid="shibukawa.yoshiki" creationdate="20170221T052324Z">
        <seg>ラウティングはユニークなURLと画面の組を設定します。これにより、複数の「ページ」の間の移動ができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing mode abstraction</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153317Z" creationid="shibukawa.yoshiki" creationdate="20150412T153317Z">
        <seg>ラウティングモードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053510Z" creationid="shibukawa.yoshiki" creationdate="20170208T053510Z">
        <seg>ラウトのパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080604Z" creationid="shibukawa.yoshiki" creationdate="20170207T080604Z">
        <seg>ラウトのパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing strategies</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092229Z" creationid="shibukawa.yoshiki" creationdate="20170207T092229Z">
        <seg>ラウト戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing without page refreshes is made partially possible by the &lt;a0&gt;&lt;c1&gt;history.pushState&lt;/c1&gt;&lt;/a0&gt;_method) API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T091914Z" creationid="shibukawa.yoshiki" creationdate="20170207T091914Z">
        <seg>ページリフレッシュをしないラウティングは、&lt;a0&gt;&lt;c1&gt;history.pushState&lt;/c1&gt;&lt;/a0&gt;メソッド) APIによって実現されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run code on component removal</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034520Z" creationid="shibukawa.yoshiki" creationdate="20170131T034520Z">
        <seg>コンポーネント削除時にコードを実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running clean up code on route change</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152414Z" creationid="shibukawa.yoshiki" creationdate="20150414T152414Z">
        <seg>ラウト変更時に後処理コードを実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safe-by-default templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133820Z" creationid="shibukawa.yoshiki" creationdate="20150407T133820Z">
        <seg>デフォルト設定が安全側に振られたテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135046Z" creationid="shibukawa.yoshiki" creationdate="20150407T135046Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sample code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134223Z" creationid="shibukawa.yoshiki" creationdate="20150407T134223Z">
        <seg>サンプルコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See "Signature" section for details.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235315Z" creationid="shibukawa.yoshiki" creationdate="20150412T235315Z">
        <seg>詳細についてはシグニチャのセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;&lt;c1&gt;m()&lt;/c1&gt;&lt;/a0&gt; for more information on virtual elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013558Z" creationid="shibukawa.yoshiki" creationdate="20150410T013558Z">
        <seg>仮想エレメントについての詳細は、&lt;a0&gt;&lt;c1&gt;m()&lt;/c1&gt;&lt;/a0&gt;のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;&lt;c1&gt;m.component&lt;/c1&gt;&lt;/a0&gt; for information on components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135834Z" creationid="shibukawa.yoshiki" creationdate="20150502T135834Z">
        <seg>コンポーネントに関しては&lt;a0&gt;&lt;c1&gt;m.component&lt;/c1&gt;&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;&lt;c1&gt;m.deferred&lt;/c1&gt;&lt;/a0&gt; for more information on promises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180629Z" creationid="shibukawa.yoshiki" creationdate="20150415T180629Z">
        <seg>promiseについては&lt;a0&gt;&lt;c1&gt;m.deferred&lt;/c1&gt;&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;components&lt;/a0&gt; for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T144952Z" creationid="shibukawa.yoshiki" creationdate="20160101T144952Z">
        <seg>より詳細な情報は&lt;a0&gt;コンポーネント&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;subtree directives.html&lt;/a0&gt; for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160449Z" creationid="shibukawa.yoshiki" creationdate="20150413T160449Z">
        <seg>要塞については、&lt;a0&gt;subtree directives.html&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a2&gt;&lt;c3&gt;m.route.mode&lt;/c3&gt;&lt;/a2&gt; for the caveats of each implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153242Z" creationid="shibukawa.yoshiki" creationdate="20150414T153242Z">
        <seg>それぞれの実装方法の詳細については、&lt;a2&gt;&lt;c3&gt;m.route.mode&lt;/c3&gt;&lt;/a2&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the &lt;a0&gt;integration guide&lt;/a0&gt; for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125508Z" creationid="shibukawa.yoshiki" creationdate="20150413T125500Z">
        <seg>これについては&lt;a0&gt;他のライブラリとの統合&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the next section.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174214Z" creationid="shibukawa.yoshiki" creationdate="20150415T173510Z">
        <seg>次のセクションもご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select2 config factory.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132152Z" creationid="shibukawa.yoshiki" creationdate="20160101T132152Z">
        <seg>Select2 configファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separating templates from data also allow template code to be cached more effectively and enables better code reusability across different types of clients (e.g. desktop, mobile).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022459Z" creationid="shibukawa.yoshiki" creationdate="20170220T022459Z">
        <seg>また、テンプレートとデータを分離すると、テンプレートコードをより効率的にキャッシュしたり、デスクトップやモバイルなどの異なる種類のクライアント間でコードの再利用性が上がります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serialize data into querystring format</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153729Z" creationid="shibukawa.yoshiki" creationdate="20150412T153729Z">
        <seg>データをクエリー文字列フォーマットでシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serializes an object into its URI encoded querystring representation, following the same serialization conventions as &lt;a0&gt;URI.js&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170947Z" creationid="shibukawa.yoshiki" creationdate="20150414T170947Z">
        <seg>&lt;a0&gt;URI.js&lt;/a0&gt;と同じシリアライズ規約を使い、オブジェクトをURIでエンコードされたクエリー文字列にシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serializing getter-setters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133748Z" creationid="shibukawa.yoshiki" creationdate="20150414T133748Z">
        <seg>getter-setterのシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;c1&gt;context.retain = true&lt;/c1&gt; in the element's config function allows the span to stay intact after a route change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134935Z" creationid="shibukawa.yoshiki" creationdate="20150413T134828Z">
        <seg>エレメントのconfig関数の中で&lt;c1&gt;context.retain = true&lt;/c1&gt;と設定すると、ラウトが変更されてもコストが高い(つもりの)spanタグを保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting strategy to none in any one of those handlers will not affect the redrawing strategy of other handlers (and remember that &lt;c0&gt;strategy("none")&lt;/c0&gt; has no effect on asynchronous redraws).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151229Z" creationid="shibukawa.yoshiki" creationdate="20150416T151229Z">
        <seg>この場合、１つのハンドラでnoneに戦略を変更しても、&lt;c0&gt;strategy("none")&lt;/c0&gt; は非同期の再描画に効果を与えないため、他のハンドラの再描画戦略に影響を与えることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the &lt;c0&gt;background&lt;/c0&gt; option to &lt;c1&gt;true&lt;/c1&gt; prevents a request from affecting redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000224Z" creationid="shibukawa.yoshiki" creationdate="20150415T000224Z">
        <seg>&lt;c0&gt;background&lt;/c0&gt;オプションを&lt;c1&gt;true&lt;/c1&gt;に設定すると、リクエストが再描画のプロセスに干渉することはなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand syntax</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T133751Z" creationid="shibukawa.yoshiki" creationdate="20160101T133751Z">
        <seg>短縮文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235059Z" creationid="shibukawa.yoshiki" creationdate="20150412T235059Z">
        <seg>シグニチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar, setting the value of attribute &lt;c0&gt;readonly&lt;/c0&gt; to &lt;c1&gt;false&lt;/c1&gt; is equivalent to removing the attribute in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153955Z" creationid="shibukawa.yoshiki" creationdate="20150413T153955Z">
        <seg>同様に&lt;c0&gt;readonly&lt;/c0&gt;属性に&lt;c1&gt;false&lt;/c1&gt;を設定すると、その属性をHTMLから取り除くのと同じ結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c2&gt;ContactForm&lt;/c2&gt; can be used to both create new contacts as well as edit existing ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010148Z" creationid="shibukawa.yoshiki" creationdate="20150502T010148Z">
        <seg>同様に&lt;c2&gt;ContactForm&lt;/c2&gt;も、新規の連絡先の作成と、既存の連絡先の編集の両方に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if the &lt;c5&gt;onmatch&lt;/c5&gt; method is omitted, &lt;c6&gt;vnode.tag&lt;/c6&gt; is also &lt;c7&gt;"div"&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090502Z" creationid="shibukawa.yoshiki" creationdate="20170207T090502Z">
        <seg>同様に、&lt;c5&gt;onmatch&lt;/c5&gt;メソッドが省略されると、&lt;c6&gt;vnode.tag&lt;/c6&gt;が&lt;c7&gt;"div"&lt;/c7&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple application</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T235807Z" creationid="shibukawa.yoshiki" creationdate="20170204T235807Z">
        <seg>シンプルなアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple application - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T235749Z" creationid="shibukawa.yoshiki" creationdate="20170204T235749Z">
        <seg>シンプルなアプリケーション - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;Anon1&lt;/c0&gt; and &lt;c1&gt;Anon2&lt;/c1&gt; are different components, their subtrees (including &lt;c2&gt;Layout&lt;/c2&gt;) are recreated from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073533Z" creationid="shibukawa.yoshiki" creationdate="20170208T073533Z">
        <seg>&lt;c0&gt;Anon1&lt;/c0&gt;と&lt;c1&gt;Anon2&lt;/c1&gt;は異なるコンポーネントなので、&lt;c2&gt;Layout&lt;/c2&gt;を含むこれらのサブツリーはすべて、移行時に全部破棄されてから再作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;User.list&lt;/c0&gt; is a Javascript array, and since hyperscript views are just Javascript, we can loop through the array using the &lt;c1&gt;.map&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T144545Z" creationid="shibukawa.yoshiki" creationdate="20170220T144545Z">
        <seg>&lt;c0&gt;User.list&lt;/c0&gt;はJavaScriptの配列ですし、hyperscriptのビューも単なるJavaScriptです。そのため、&lt;c1&gt;.map&lt;/c1&gt;メソッドを使って配列をループすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;v1.x&lt;/c0&gt; uses standards-compliant Promises, &lt;c1&gt;m.sync&lt;/c1&gt; is redundant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050207Z" creationid="shibukawa.yoshiki" creationdate="20170201T050207Z">
        <seg>&lt;c0&gt;v1.x&lt;/c0&gt;では標準準拠のPromiseが使われるようになったため、&lt;c1&gt;m.sync&lt;/c1&gt;は削除されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since computer screens are not able to display changes faster than a frame, this optimization saves CPU cycles and helps UIs stay responsive even in the face of spammy data changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191712Z" creationid="shibukawa.yoshiki" creationdate="20150411T191712Z">
        <seg>コンピュータのスクリーンはフレーム以上の速度で表示することはできないため、この最適化によってCPUのサイクルを節約することができますし、大量のデータ変更に対してもUIの応答性を保つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since controllers can call model methods, it's possible for nested components to encapsulate asynchronous behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093109Z" creationid="shibukawa.yoshiki" creationdate="20150502T093109Z">
        <seg>コントローラはモデルのメソッドを呼ぶことができますが、非同期の動作をカプセル化するのにネストされたコンポーネントを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since that route render UserList, we should still see the list of people on screen as before.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115701Z" creationid="shibukawa.yoshiki" creationdate="20170221T115701Z">
        <seg>ラウトは同じUserListのレンダリングを行うため、前と同じユーザーのリストが見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we used &lt;c0&gt;m.mount&lt;/c0&gt;, you don't need to manually call &lt;c1&gt;m.render&lt;/c1&gt; to apply the changes in the &lt;c2&gt;count&lt;/c2&gt; variable to the HTML; Mithril does it for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031551Z" creationid="shibukawa.yoshiki" creationdate="20170131T031551Z">
        <seg>&lt;c0&gt;m.mount()&lt;/c0&gt;を使うと、&lt;c1&gt;m.render()&lt;/c1&gt;をマニュアルで呼び出さなくても&lt;c2&gt;count&lt;/c2&gt;変数の変更をMithrilがHTMLに反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we want &lt;c2&gt;User.loadList&lt;/c2&gt; to be called when we render this component, we can take advantage of component &lt;a3&gt;lifecycle methods&lt;/a3&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T144911Z" creationid="shibukawa.yoshiki" creationdate="20170220T144911Z">
        <seg>コンポーネントを描画するために&lt;c2&gt;User.loadList&lt;/c2&gt;を呼ぶ必要がありますが、それにはコンポーネントの&lt;a3&gt;ライフサイクルメソッド&lt;/a3&gt;の力を借ります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single page applications that use the hash strategy often use the convention of having an exclamation mark after the hash to indicate that they're using the hash as a routing mechanism and not for the purposes of linking to anchors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100528Z" creationid="shibukawa.yoshiki" creationdate="20170207T100528Z">
        <seg>ハッシュ戦略を使うシングルページアプリケーションは、ハッシュの後に感嘆符（!）を付けてアンカーへのリンクではなく、ハッシュをラウティングメカニズムとして使用することを明示することがよくあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Small API, small learning curve</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134049Z" creationid="shibukawa.yoshiki" creationdate="20150407T133432Z">
        <seg>小さくシンプルなAPIと、低い学習コスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So calling &lt;c0&gt;m.request&lt;/c0&gt; multiple times from a controller context increments the internal counter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154446Z" creationid="shibukawa.yoshiki" creationdate="20150416T154446Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;をコントローラのコンテキスト内で複数回呼ぶと、内部カウンターが増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, we've been using &lt;c0&gt;m.render&lt;/c0&gt; to manually redraw after we made a change to the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161003Z" creationid="shibukawa.yoshiki" creationdate="20150408T161003Z">
        <seg>最初に紹介したときは、データを変更した後に手動で&lt;c0&gt;m.render&lt;/c0&gt;を呼び出して再描画を行わせていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you open the page in a browser and your URL is &lt;c4&gt;http://localhost&lt;/c4&gt;, then you get redirected to &lt;c5&gt;http://localhost/#!/splash&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170203T091331Z" creationid="shibukawa.yoshiki" creationdate="20170203T091331Z">
        <seg>もしブラウザを開いて、そのページのURLが&lt;c4&gt;http://localhost&lt;/c4&gt;だったら、&lt;c5&gt;http://localhost/#!/splash&lt;/c5&gt;にリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you to add a class to the &lt;c1&gt;&lt;h1&gt;&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030122Z" creationid="shibukawa.yoshiki" creationdate="20170131T030122Z">
        <seg>&lt;c1&gt;&lt;h1&gt;&lt;/c1&gt;タグにクラスを追加してみます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So in our example above, when you click the button, the text in it is the only part of the DOM Mithril actually updates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031759Z" creationid="shibukawa.yoshiki" creationdate="20170131T031759Z">
        <seg>上記のサンプルでは、ボタンをクリックしたときには、MithrilはボタンのテキストのDOM部分だけを更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So this view is equivalent to &lt;c3&gt;&lt;div class="user-list"&gt;&lt;/div&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T133556Z" creationid="shibukawa.yoshiki" creationdate="20170220T133556Z">
        <seg>このビューは&lt;c3&gt;&lt;div class="user-list"&gt;&lt;/div&gt;&lt;/c3&gt;と等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Social</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024800Z" creationid="shibukawa.yoshiki" creationdate="20170131T024800Z">
        <seg>ソーシャル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Social Media</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135808Z" creationid="shibukawa.yoshiki" creationdate="20150407T135808Z">
        <seg>ソーシャルメディア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some asynchronous operations might need to affect redrawing both before and after their completion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135833Z" creationid="shibukawa.yoshiki" creationdate="20150415T135833Z">
        <seg>再描画の操作によっては、呼び出し前と後の両方に再描画が必要になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some cases may not require a redraw upon completion of the asynchronous callbacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135749Z" creationid="shibukawa.yoshiki" creationdate="20150415T135749Z">
        <seg>非同期のコールバックを待たずに再描画を行っても問題ないケースもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some configurations require supporting server-side changes, so we'll just continue using the hashbang for the rest of this tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115942Z" creationid="shibukawa.yoshiki" creationdate="20170221T115942Z">
        <seg>設定に寄ってはサーバー側の変更が必要となるため、このチュートリアル内ではこのまま進めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the older frameworks among the popular ones (out-of-the-box jQuery and Backbone, specifically) take a more procedural paradigm when it comes to the view layer; this means every action requires the developer to write custom view-level code to handle it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014215Z" creationid="shibukawa.yoshiki" creationdate="20150420T014215Z">
        <seg>有名ないくつかの古いフレームワーク(jQueryやBackboneなどは特に)は、ビューのレイヤーに対しても、より手続き型寄りのパラダイムを採用しました。開発者が毎回、開発対象ごとにビューレベルのコードを手書きしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some services (e.g. Flickr) don't follow the convention of calling the &lt;c0&gt;callback&lt;/c0&gt; parameter &lt;c1&gt;callback&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235033Z" creationid="shibukawa.yoshiki" creationdate="20150414T234945Z">
        <seg>Flickrなどの一部のサービスは、&lt;c0&gt;callback&lt;/c0&gt;パラメータで指定された&lt;c1&gt;callback&lt;/c1&gt;を呼び出すというJSONPの規約に従っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some, like &lt;a0&gt;Bootstrap&lt;/a0&gt; dictate a specific set of HTML structures and semantically meaningful class names, which has the upside of providing low cognitive dissonance, but the downside of making customization more difficult.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T153528Z" creationid="shibukawa.yoshiki" creationdate="20170220T153528Z">
        <seg>&lt;a0&gt;Bootstrap&lt;/a0&gt;のように、HTMLの構造と、意味のあるクラス名の両方を指定する仕組みもあります。これはクラス名と意味が近いという利点がありますが、カスタマイズが難しいという欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes a server endpoint does not return a JSON response: for example, you may be requesting an HTML file, an SVG file, or a CSV file.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004600Z" creationid="shibukawa.yoshiki" creationdate="20170220T004600Z">
        <seg>JSON以外を返すサーバーのエンドポイントもあります。例えば、HTMLファイル、SVG fileファイル、CSVファイル形式でレスポンスを返すようにリクエストを送ることがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes we want to have a variable id or similar data appear in a route, but we don't want to explicitly specify a separate route for every possible id.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053630Z" creationid="shibukawa.yoshiki" creationdate="20170208T053630Z">
        <seg>ラウトの中に、ID変数などのデータ表現を追加したいことがあります。もちろん、可能性のあるIDをすべて個別のラウトとして明示したくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you only care about a particular condition in an event and want the event to not trigger a redraw if this condition is not met.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150101Z" creationid="shibukawa.yoshiki" creationdate="20150416T150101Z">
        <seg>イベント内の特定の条件について考慮した時に、その条件に合わなければ再描画を行いたくない、と思うこともよくあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, if a request is inherently slow (e.g. a large file upload), it's desirable to display a progress indicator to the user to signal that the application is still working.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T191111Z" creationid="shibukawa.yoshiki" creationdate="20170219T191111Z">
        <seg>巨大なファイルのアップロードなど、リクエストが遅い場合にはプログレスのインジケーターを表示して、ユーザーにアプリケーションが正常に稼働していることを表示したくなるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, it is desirable to abort a request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152543Z" creationid="shibukawa.yoshiki" creationdate="20170219T152543Z">
        <seg>リクエストを中断したくなるケースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Speaking from experience, it's generally difficult to reason about performance in Angular.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094802Z" creationid="shibukawa.yoshiki" creationdate="20150420T094745Z">
        <seg>経験から見ても、Angularのパフォーマンス向上させるのは難しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specific Framework Comparisons</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015024Z" creationid="shibukawa.yoshiki" creationdate="20150420T015024Z">
        <seg>特定のフレームワークとの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050605Z" creationid="shibukawa.yoshiki" creationdate="20150502T050605Z">
        <seg>ステートフルなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050557Z" creationid="shibukawa.yoshiki" creationdate="20150502T050557Z">
        <seg>ステートレスなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Static members</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080416Z" creationid="shibukawa.yoshiki" creationdate="20170207T080416Z">
        <seg>静的メンバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steep performance degradation is a notoriously common issue in non-trivial Angular applications and there are several third party libraries which attempt to get around performance problems.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094626Z" creationid="shibukawa.yoshiki" creationdate="20150420T094626Z">
        <seg>巨大なAngularのアプリケーションのパフォーマンスは厳しいものがあり、それに対応しようとするサードパーティ製のライブラリもいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111904Z" creationid="shibukawa.yoshiki" creationdate="20170206T111904Z">
        <seg>ストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent parameters have no restrictions (e.g. &lt;c1&gt;"this is a test"&lt;/c1&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080042Z" creationid="shibukawa.yoshiki" creationdate="20150502T080042Z">
        <seg>それに続く引数(&lt;c1&gt;"this is a test"&lt;/c1&gt;)には制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, the &lt;c2&gt;view&lt;/c2&gt; function is called and will be called again anytime a redraw is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071921Z" creationid="shibukawa.yoshiki" creationdate="20150502T071921Z">
        <seg>その後、&lt;c2&gt;view&lt;/c2&gt;関数が再描画が必要になるたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtree Directives</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123430Z" creationid="shibukawa.yoshiki" creationdate="20150416T123430Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtree directives</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015933Z" creationid="shibukawa.yoshiki" creationdate="20150416T015933Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161941Z" creationid="shibukawa.yoshiki" creationdate="20150408T161941Z">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose we have a component called &lt;c0&gt;ProjectList&lt;/c0&gt; and the following data:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085647Z" creationid="shibukawa.yoshiki" creationdate="20150502T085647Z">
        <seg>下記のデータを持つ、&lt;c0&gt;ProjectList&lt;/c0&gt;と呼ばれるコンポーネントがあったとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swipe-to-show panel</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143327Z" creationid="shibukawa.yoshiki" creationdate="20160412T143327Z">
        <seg>スワイプによって表示されるパネル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronous execution</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140153Z" creationid="shibukawa.yoshiki" creationdate="20150415T140153Z">
        <seg>同期実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronous redraw removed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034100Z" creationid="shibukawa.yoshiki" creationdate="20170131T033925Z">
        <seg>同期再描画の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take it with a grain of salt.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015147Z" creationid="shibukawa.yoshiki" creationdate="20150420T015147Z">
        <seg>そのまま鵜呑みにせずに、参考程度にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Technology choices</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T104725Z" creationid="shibukawa.yoshiki" creationdate="20170206T104725Z">
        <seg>技術の選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013555Z" creationid="shibukawa.yoshiki" creationdate="20150417T013555Z">
        <seg>テンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test Summary</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135442Z" creationid="shibukawa.yoshiki" creationdate="20150407T135442Z">
        <seg>テスト結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154222Z" creationid="shibukawa.yoshiki" creationdate="20150412T154222Z">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing the various parts of the component is trivial:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081601Z" creationid="shibukawa.yoshiki" creationdate="20150502T081546Z">
        <seg>コンポーネントのさまざまなパーツをテストするのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests are run</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054203Z" creationid="shibukawa.yoshiki" creationdate="20170220T054203Z">
        <seg>テストと実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means the user will be redirected to that route if they land in a route that does not exist.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115308Z" creationid="shibukawa.yoshiki" creationdate="20170221T115308Z">
        <seg>ユーザーがラウト一覧にないURLを開こうとすると、このURLにリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That organization pattern needlessly ties unrelated aspects of the application together and dilutes the clarity of modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015746Z" creationid="shibukawa.yoshiki" creationdate="20150421T015746Z">
        <seg>このようなパターンでアプリケーションを分けてしまうと、レイヤー間で不必要なコードの密結合が起きてしまいます。モジュールによる、MVC縦断の縦のつながりがわかりにくくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt; pair&lt;/a0&gt; is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130550Z" creationid="shibukawa.yoshiki" creationdate="20150502T130550Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.startComputation&lt;/c1&gt; / &lt;c2&gt;m.endComputation&lt;/c2&gt;のペア&lt;/a0&gt;は「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;routing parameters&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085715Z" creationid="shibukawa.yoshiki" creationdate="20170207T085715Z">
        <seg>&lt;a0&gt;ラウトパラメータ&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a5&gt;config's retain flag&lt;/a5&gt; can be used to change how specific elements are redrawn when routes change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000509Z" creationid="shibukawa.yoshiki" creationdate="20150506T000509Z">
        <seg>&lt;a5&gt;configのretainフラグ&lt;/a5&gt;を使うと、ラウト変更時に特定の要素を再描画するかどうかを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;".user-list"&lt;/c0&gt; string is a CSS selector, and as you would expect, &lt;c1&gt;.user-list&lt;/c1&gt; represents a class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T123605Z" creationid="shibukawa.yoshiki" creationdate="20170220T123605Z">
        <seg>&lt;c0&gt;".user-list"&lt;/c0&gt;文字列は、見た目で期待される通り、CSSセレクターです。&lt;c1&gt;.user-list&lt;/c1&gt;はクラスを表しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;"/splash"&lt;/c0&gt; right after &lt;c1&gt;root&lt;/c1&gt; means that's the default route, i.e. if the hashbang in the URL doesn't point to one of the defined routes (&lt;c2&gt;/splash&lt;/c2&gt; and &lt;c3&gt;/hello&lt;/c3&gt;, in our case), then Mithril redirects to the default route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170203T091007Z" creationid="shibukawa.yoshiki" creationdate="20170203T090955Z">
        <seg>&lt;c1&gt;root&lt;/c1&gt;のすぐ右にある&lt;c0&gt;"/splash"&lt;/c0&gt;はデフォルトのラウトです。ハッシュバングのあとのURLが、定義されているラウト（このサンプルでは&lt;c2&gt;/splash&lt;/c2&gt;、&lt;c3&gt;/hello&lt;/c3&gt;）、MithrilはこのURLにリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;#!&lt;/c0&gt; snippet is known as a hashbang, and it's a commonly used string for implementing client-side routing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115800Z" creationid="shibukawa.yoshiki" creationdate="20170221T115800Z">
        <seg>&lt;c0&gt;#!&lt;/c0&gt;スニペットはハッシュバングと呼ばれています。これはクライアントサイドのラウティング実装で一般的に使われる文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;#!&lt;/c0&gt; string is known as a &lt;e1&gt;hashbang&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100554Z" creationid="shibukawa.yoshiki" creationdate="20170207T100554Z">
        <seg>&lt;c0&gt;#!&lt;/c0&gt;文字列は&lt;e1&gt;ハッシュバング&lt;/e1&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;!doctype html&gt;&lt;/c0&gt; line indicates this is an HTML 5 document.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000325Z" creationid="shibukawa.yoshiki" creationdate="20170205T000325Z">
        <seg>&lt;c0&gt;&lt;!doctype html&gt;&lt;/c0&gt;行はHTML5のドキュメントであることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;ContactForm&lt;/c0&gt; component is, as its name suggests, a form that allows us to edit the fields of a &lt;c1&gt;Contact&lt;/c1&gt; entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001804Z" creationid="shibukawa.yoshiki" creationdate="20150502T001804Z">
        <seg>&lt;c0&gt;ContactForm&lt;/c0&gt;コンポーネントは、名前から推測できる通りで、&lt;c1&gt;Contact&lt;/c1&gt;エンティティのフィールドを編集するフォームを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;ContactList&lt;/c0&gt; component displays a table showing all the contact entities that are passed to it via the &lt;c1&gt;contacts&lt;/c1&gt; argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002420Z" creationid="shibukawa.yoshiki" creationdate="20150502T002420Z">
        <seg>&lt;c0&gt;ContactList&lt;/c0&gt;コンポーネントは、&lt;c1&gt;contacts&lt;/c1&gt;引数で渡されたすべての連絡先のエンティティを表形式で表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;ContactList&lt;/c0&gt; component's controller is marked as Observable, and the &lt;c1&gt;save&lt;/c1&gt; event handler in &lt;c2&gt;ContactForm&lt;/c2&gt; calls &lt;c3&gt;Observable.trigger&lt;/c3&gt; after saving.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021142Z" creationid="shibukawa.yoshiki" creationdate="20150502T021142Z">
        <seg>&lt;c0&gt;ContactList&lt;/c0&gt;コンポーネントのコントローラが監視対象としてマークして、その後&lt;c2&gt;ContactForm&lt;/c2&gt;の&lt;c1&gt;save&lt;/c1&gt;イベントハンドラの中で、保存後に&lt;c3&gt;Observable.trigger&lt;/c3&gt;呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Observable&lt;/c0&gt; object can be further refactored so that &lt;c1&gt;trigger&lt;/c1&gt; broadcasts to "channels", which controllers can subscribe to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025105Z" creationid="shibukawa.yoshiki" creationdate="20150502T025105Z">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt;(監視可能)オブジェクトは&lt;c1&gt;trigger&lt;/c1&gt;を使ってコントローラが購読している"channels"にブロードキャストするという方式にリファクタリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Observable&lt;/c0&gt; object exposes two methods: &lt;c1&gt;register&lt;/c1&gt; which marks a controller as a Observable entity, and &lt;c2&gt;trigger&lt;/c2&gt; which reloads controllers marked by &lt;c3&gt;register&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020914Z" creationid="shibukawa.yoshiki" creationdate="20150502T020914Z">
        <seg>&lt;c0&gt;Observable&lt;/c0&gt;オブジェクトは2つのメソッドを提供しています。&lt;c1&gt;register&lt;/c1&gt;はコントローラのエンティティを監視対象のエンティティとして登録します。&lt;c2&gt;trigger&lt;/c2&gt;は&lt;c3&gt;register&lt;/c3&gt;で登録されたコントローラをリロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;TodoList&lt;/c0&gt; class is simply an alias of the native &lt;c1&gt;Array&lt;/c1&gt; class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151056Z" creationid="shibukawa.yoshiki" creationdate="20150407T151044Z">
        <seg>&lt;c0&gt;TodoList&lt;/c0&gt;クラスは単に、標準の&lt;c1&gt;Array&lt;/c1&gt;クラスの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;attributes&lt;/c0&gt; argument (i.e. the second parameter in the &lt;c1&gt;m("div", {class: "container"}, "Hello")&lt;/c1&gt; example) is meant to be used for attributes whose values we want to dynamically populate.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002101Z" creationid="shibukawa.yoshiki" creationdate="20150413T002101Z">
        <seg>&lt;c1&gt;m("div", {class: "container"}, "Hello")&lt;/c1&gt;の2番目のパラメータの&lt;c0&gt;attributes&lt;/c0&gt;引数は、動的に変更する可能性のある属性を設定するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;config&lt;/c0&gt; attribute</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121555Z" creationid="shibukawa.yoshiki" creationdate="20150413T154833Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;config&lt;/c0&gt; function created by our factory only runs the initialization code if it hasn't already.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133749Z" creationid="shibukawa.yoshiki" creationdate="20150412T133749Z">
        <seg>このファクトリ関数で作成された&lt;c0&gt;config&lt;/c0&gt;関数は、初期化関数だけを実行します。ただし、すでに初期化済みの場合は何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;config&lt;/c0&gt; mechanism can also be used to put focus on form inputs, and call methods that would not be possible to execute via the regular attribute syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124432Z" creationid="shibukawa.yoshiki" creationdate="20150413T124432Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;の仕組みを使うと、入力フォームにフォーカスを移動したり、通常の属性文法では呼び出せないメソッドを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;config&lt;/c0&gt; option can also be used to retrieve the &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; instance for aborting the request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182308Z" creationid="shibukawa.yoshiki" creationdate="20150414T182308Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;を通じて、&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;のインスタンスに対して、リクエストの中断を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;config&lt;/c0&gt; option can be used to arbitrarily configure the native XMLHttpRequest instance and to access properties that would not be accessible otherwise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182052Z" creationid="shibukawa.yoshiki" creationdate="20150414T182052Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;オプションを使って、ネイティブのXMLHttpRequestインスタンスの設定を任意に設定したり、他の方法ではアクセスできないプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;controller&lt;/c0&gt; function is called &lt;e1&gt;once&lt;/e1&gt; when the component is rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071828Z" creationid="shibukawa.yoshiki" creationdate="20150502T071828Z">
        <seg>&lt;c0&gt;controller&lt;/c0&gt;関数は、コンポーネントがレンダリングされる時に&lt;e1&gt;一度だけ&lt;/e1&gt;呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;controller&lt;/c0&gt; function is optional and defaults to an empty function &lt;c1&gt;controller: function() {}&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072050Z" creationid="shibukawa.yoshiki" creationdate="20150502T072050Z">
        <seg>&lt;c0&gt;controller&lt;/c0&gt;関数はオプショナルです。デフォルト値は空の関数(&lt;c1&gt;controller: function() {}&lt;/c1&gt;)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;dashboard&lt;/c0&gt; component in the example shows how a developer would consume the select2 component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045343Z" creationid="shibukawa.yoshiki" creationdate="20150502T045343Z">
        <seg>サンプルの&lt;c0&gt;dashboard&lt;/c0&gt;コンポーネントを見ると、どのようにselect2コンポーネントを使用するかが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;errorCallback&lt;/c0&gt; is called if &lt;c1&gt;reject&lt;/c1&gt; is called in the root &lt;c2&gt;deferred&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175931Z" creationid="shibukawa.yoshiki" creationdate="20150415T175931Z">
        <seg>ルートの&lt;c2&gt;deferred&lt;/c2&gt;の&lt;c1&gt;reject&lt;/c1&gt;が呼ばれると&lt;c0&gt;errorCallback&lt;/c0&gt;が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;extract&lt;/c0&gt; method can be used to read metadata from HTTP response headers or the status field of an XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175735Z" creationid="shibukawa.yoshiki" creationdate="20150414T175735Z">
        <seg>&lt;c0&gt;extract&lt;/c0&gt;メソッドはHTTPレスポンスヘッダのメタデータや、XMLHttpRequestのステータスフィールドを読み込むのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;fetch()&lt;/c0&gt; API does have a few technical advantages over &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; in a few uncommon cases:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T033851Z" creationid="shibukawa.yoshiki" creationdate="20170220T033851Z">
        <seg>&lt;c0&gt;fetch()&lt;/c0&gt;APIは&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;と較べていくつかの技術的な利点がありますが、用途は限定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m()&lt;/c0&gt; function can be used to describe any HTML structure you want.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030136Z" creationid="shibukawa.yoshiki" creationdate="20170131T030057Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;関数を使うと、あらゆるHTML構造が表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.buildQueryString&lt;/c0&gt; creates a querystring from an object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133255Z" creationid="shibukawa.yoshiki" creationdate="20170206T133255Z">
        <seg>&lt;c0&gt;m.buildQueryString&lt;/c0&gt;はオブジェクトからクエリー文字列を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.mount&lt;/c0&gt; call renders the specified component (&lt;c1&gt;UserList&lt;/c1&gt;) into a DOM element (&lt;c2&gt;document.body&lt;/c2&gt;), erasing any DOM that was there previously.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T152354Z" creationid="shibukawa.yoshiki" creationdate="20170220T152354Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;を呼び出すと、指定されたコンポーネント (&lt;c1&gt;UserList&lt;/c1&gt;) をDOM要素 (&lt;c2&gt;document.body&lt;/c2&gt;) 内にレンダリングされます。DOMに今まであった要素は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.mount&lt;/c0&gt; function is similar to &lt;c1&gt;m.render&lt;/c1&gt;, but instead of rendering some HTML only once, it activates Mithril's auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030820Z" creationid="shibukawa.yoshiki" creationdate="20170131T030820Z">
        <seg>&lt;c0&gt;m.mount()&lt;/c0&gt;関数は&lt;c1&gt;m.render()&lt;/c1&gt;関数と似ていますが、後者は一度しかHTMLをレンダリング（DOMの生成）を行いません。前者はMithrilの自動再描画システムを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.redraw.strategy&lt;/c0&gt; getter-setter indicates how the next component redraw will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133408Z" creationid="shibukawa.yoshiki" creationdate="20150502T133408Z">
        <seg>&lt;c0&gt;m.redraw.strategy&lt;/c0&gt; getter-setterは次のコンポーネントの再描画をどのように行うかを設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.request&lt;/c0&gt; call returns a Promise that resolves to the data from the endpoint.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T120606Z" creationid="shibukawa.yoshiki" creationdate="20170220T120606Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;を呼び出すとPromiseが返されます。このPromiseが解決すると、エンドポイントから返ってきたデータが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.request&lt;/c0&gt; method returns a &lt;a1&gt;Promise&lt;/a1&gt;, not the response data itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034447Z" creationid="shibukawa.yoshiki" creationdate="20170220T034447Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;は&lt;a1&gt;Promise&lt;/a1&gt;を返しますが、これはレスポンスそのものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.request&lt;/c0&gt; utility is a thin wrapper around &lt;a1&gt;&lt;c2&gt;XMLHttpRequest&lt;/c2&gt;&lt;/a1&gt;, and allows making HTTP requests to remote servers in order to save and/or retrieve data from a database.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T140918Z" creationid="shibukawa.yoshiki" creationdate="20170219T140918Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;ユーティリティは&lt;a1&gt;&lt;c2&gt;XMLHttpRequest&lt;/c2&gt;&lt;/a1&gt;の薄いラッパーです。これを使うとHTTPリクエストを通じて、リモートサーバーにデータを保存したり、データを取得してくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.route.mode&lt;/c0&gt; defines which part of the URL to use for routing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153703Z" creationid="shibukawa.yoshiki" creationdate="20150414T153703Z">
        <seg>&lt;c0&gt;m.route.mode&lt;/c0&gt;は、URLのどの部分をラウトとして使うかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.route.mode&lt;/c0&gt; property defines which URL portion is used to implement the routing mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004211Z" creationid="shibukawa.yoshiki" creationdate="20150410T004211Z">
        <seg>&lt;c0&gt;m.route.mode&lt;/c0&gt;プロパティを使うと、どのURLに対してラウティングの仕組みを実装するかを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.route&lt;/c0&gt; call specifies that the application will be rendered into &lt;c1&gt;document.body&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115206Z" creationid="shibukawa.yoshiki" creationdate="20170221T115206Z">
        <seg>&lt;c0&gt;m.route&lt;/c0&gt;を呼ぶとアプリケーションが&lt;c1&gt;document.body&lt;/c1&gt;の中にレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.route&lt;/c0&gt; function still has the same auto-redrawing functionality that &lt;c1&gt;m.mount&lt;/c1&gt; does, and it also enables URL awareness; in other words, it lets Mithril know what to do when it sees a &lt;c2&gt;#!&lt;/c2&gt; in the URL.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T054253Z" creationid="shibukawa.yoshiki" creationdate="20170201T054253Z">
        <seg>&lt;c0&gt;m.route&lt;/c0&gt;関数は&lt;c1&gt;m.mount&lt;/c1&gt;と同じ自動再描画機能を持っています。これに加えて、URLの変更に対応することができます。URLに&lt;c2&gt;#!&lt;/c2&gt;の文字を見つけたら、Mithrilに何をするか教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; pair is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114333Z" creationid="shibukawa.yoshiki" creationdate="20150502T114333Z">
        <seg>&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;のペアは「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.withAttr("value", todo.vm.description)&lt;/c0&gt; call above returns a function that is the rough equivalent of this code:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022246Z" creationid="shibukawa.yoshiki" creationdate="20150408T022246Z">
        <seg>&lt;c0&gt;m.withAttr("value", todo.vm.description)&lt;/c0&gt;という関数呼びしは、次のコードに相当する関数を返り値として返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;m.withAttr&lt;/c0&gt; utility is a functional programming tool provided by Mithril to minimize the need for anonymous functions in the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022141Z" creationid="shibukawa.yoshiki" creationdate="20150408T022141Z">
        <seg>&lt;c0&gt;m.withAttr&lt;/c0&gt;はMithrilが提供する関数型プログラミングのためのツールで、ビューの内部で無名関数の使用頻度を下げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;method&lt;/c0&gt; option is an &lt;a1&gt;HTTP method&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T060716Z" creationid="shibukawa.yoshiki" creationdate="20170220T060656Z">
        <seg>&lt;c0&gt;method&lt;/c0&gt;オプションには&lt;a1&gt;HTTPメソッド&lt;/a1&gt;を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;onerror&lt;/c0&gt; function can be safely replaced if the default error monitoring semantics are not desired.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174815Z" creationid="shibukawa.yoshiki" creationdate="20150415T174815Z">
        <seg>もし標準のエラーをモニタリングする仕組みが期待に合わなければ、&lt;c0&gt;onerror&lt;/c0&gt;を安全に置き換えて使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;onmatch&lt;/c0&gt; hook is called when the router needs to find a component to render.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084948Z" creationid="shibukawa.yoshiki" creationdate="20170207T084948Z">
        <seg>&lt;c0&gt;onmatch&lt;/c0&gt;フックはレンダリングするコンポーネントを探すときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;options&lt;/c0&gt; parameter that was passed into &lt;c1&gt;m.request&lt;/c1&gt; call</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014232Z" creationid="shibukawa.yoshiki" creationdate="20150415T014232Z">
        <seg>&lt;c0&gt;options&lt;/c0&gt;パラメータは、&lt;c1&gt;m.request&lt;/c1&gt;呼び出し時に渡された引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;promise&lt;/c0&gt; object is actually a function - specifically, it's an &lt;a1&gt;&lt;c2&gt;m.prop&lt;/c2&gt;&lt;/a1&gt; getter-setter, which gets populated with the value returned by &lt;c3&gt;successCallback&lt;/c3&gt; if the promise is resolved successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134828Z" creationid="shibukawa.yoshiki" creationdate="20150415T134828Z">
        <seg>&lt;c0&gt;promise&lt;/c0&gt;は普通の関数です。具体的には&lt;a1&gt;&lt;c2&gt;m.prop&lt;/c2&gt;&lt;/a1&gt; getter-setterで、promiseが成功すると、&lt;c3&gt;successCallback&lt;/c3&gt;が返す値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;render&lt;/c0&gt; method is called on every redraw for a matching route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090708Z" creationid="shibukawa.yoshiki" creationdate="20170207T090708Z">
        <seg>&lt;c0&gt;render&lt;/c0&gt;はラウトがマッチしたときの再描画時に毎回呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;state&lt;/c0&gt; object to pass to the underlying &lt;c1&gt;history.pushState&lt;/c1&gt; / &lt;c2&gt;history.replaceState&lt;/c2&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082341Z" creationid="shibukawa.yoshiki" creationdate="20170207T080842Z">
        <seg>&lt;c0&gt;state&lt;/c0&gt;オブジェクトは、内部で呼び出される&lt;c1&gt;history.pushState&lt;/c1&gt; / &lt;c2&gt;history.replaceState&lt;/c2&gt;に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;successCallback&lt;/c0&gt; is called if &lt;c1&gt;resolve&lt;/c1&gt; is called in the root &lt;c2&gt;deferred&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175736Z" creationid="shibukawa.yoshiki" creationdate="20150415T175736Z">
        <seg>ルートの&lt;c2&gt;deferred&lt;/c2&gt;の&lt;c1&gt;resolve&lt;/c1&gt;が呼ばれると&lt;c0&gt;successCallback&lt;/c0&gt;が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;then&lt;/c0&gt; method returns another promise whose computations (if any) receive their inputs from the parent promise's computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175036Z" creationid="shibukawa.yoshiki" creationdate="20150415T175036Z">
        <seg>&lt;c0&gt;then&lt;/c0&gt;メソッドは親のpromiseの計算結果を受け取る、別のpromiseを作って返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;title&lt;/c0&gt; string to pass to the underlying &lt;c1&gt;history.pushState&lt;/c1&gt; / &lt;c2&gt;history.replaceState&lt;/c2&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082403Z" creationid="shibukawa.yoshiki" creationdate="20170207T082337Z">
        <seg>&lt;c0&gt;title&lt;/c0&gt;文字列は、内部で呼び出される&lt;c1&gt;history.pushState&lt;/c1&gt; / &lt;c2&gt;history.replaceState&lt;/c2&gt;に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;view&lt;/c0&gt; function does not create a DOM tree when called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072341Z" creationid="shibukawa.yoshiki" creationdate="20150502T072341Z">
        <seg>&lt;c0&gt;view&lt;/c0&gt;関数は使用されたタイミングではDOMツリーを作成することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;view&lt;/c0&gt; has access to methods and properties that the controller chooses to expose in the returned object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061901Z" creationid="shibukawa.yoshiki" creationdate="20150502T061901Z">
        <seg>&lt;c0&gt;view&lt;/c0&gt;は、コントローラが公開すると決めたメソッドやプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;vm.add.bind(vm, vm.description)&lt;/c0&gt; expression above returns a function that is equivalent to this code:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151435Z" creationid="shibukawa.yoshiki" creationdate="20150408T151435Z">
        <seg>&lt;c0&gt;vm.add.bind(vm, vm.description)&lt;/c0&gt;という式は、次の式と等価です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c13&gt;then&lt;/c13&gt; method returns a child promise, which, itself, can have more child promises, recursively.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134713Z" creationid="shibukawa.yoshiki" creationdate="20150415T134645Z">
        <seg>&lt;c13&gt;then&lt;/c13&gt;メソッドは子供のpromiseを返します。この子のpromiseにもさらに子のpromiseを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;#!&lt;/c1&gt; part is known as a hashbang, and it's a common convention used in Single Page Applications to indicate that the stuff after it (the &lt;c2&gt;/hello&lt;/c2&gt; part) is a route path.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032146Z" creationid="shibukawa.yoshiki" creationdate="20170131T032146Z">
        <seg>&lt;c1&gt;#!&lt;/c1&gt;部分はハッシュバング（hashbang）と言われています。これはシングルページアプリケーションで一般的にみられる慣習です。このハッシュバングの後の部分（&lt;c2&gt;/hello&lt;/c2&gt;パート）がラウトのパスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;.then&lt;/c1&gt; callback runs when the XHR request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T120714Z" creationid="shibukawa.yoshiki" creationdate="20170220T120714Z">
        <seg>&lt;c1&gt;.then&lt;/c1&gt;コールバックは、XHRリクエストが完了すると呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;url&lt;/c1&gt; specifies an endpoint that represents a resource, the &lt;c2&gt;method&lt;/c2&gt; specifies the type of action we're taking (typically the &lt;c3&gt;PUT&lt;/c3&gt; method &lt;a4&gt;upserts&lt;/a4&gt;), &lt;c5&gt;data&lt;/c5&gt; is the payload that we're sending to the endpoint and &lt;c6&gt;useCredentials&lt;/c6&gt; means to enable cookies (a requirement for the REM API to work)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T145733Z" creationid="shibukawa.yoshiki" creationdate="20170204T145733Z">
        <seg>&lt;c1&gt;url&lt;/c1&gt;はリソースを表すエンドポイントを指定します。&lt;c2&gt;method&lt;/c2&gt;は話をするアクションの種類を指定します（&lt;a4&gt;upserts&lt;/a4&gt;には通常&lt;c3&gt;PUT&lt;/c3&gt;メソッドを使います）。&lt;c5&gt;data&lt;/c5&gt;はエンドポイントに送付するペイロードです。&lt;c6&gt;useCredentials&lt;/c6&gt;はクッキーを有効化する（REM APを動作させるのに必要）ために指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;"/list"&lt;/c2&gt; argument is the default route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115219Z" creationid="shibukawa.yoshiki" creationdate="20170221T115219Z">
        <seg>&lt;c2&gt;"/list"&lt;/c2&gt;引数はデフォルトのラウトになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;fetch&lt;/c2&gt; polyfill does not support any of those, and requires extra libraries and boilerplates to achieve the same level of functionality.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T033459Z" creationid="shibukawa.yoshiki" creationdate="20170220T033459Z">
        <seg>&lt;c2&gt;fetch&lt;/c2&gt;のpolyfillはこれらの昨日の一部をサポートしていなかったり、同じレベルの機能を提供しようとすると追加のライブラリやコードが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;onunload&lt;/c2&gt; event is called if an instantiated component is removed from a virtual element tree via a redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092640Z" creationid="shibukawa.yoshiki" creationdate="20150502T092640Z">
        <seg>インスタンス化されたコンポーネントが仮想エレメントツリーから削除されるときに&lt;c2&gt;onunload&lt;/c2&gt;イベントが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;title&lt;/c3&gt; tag contains the text to be displayed on the browser tab for this application, and the &lt;c4&gt;script&lt;/c4&gt; tag indicates what is the path to the Javascript file that controls the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T004028Z" creationid="shibukawa.yoshiki" creationdate="20170205T004028Z">
        <seg>&lt;c3&gt;title&lt;/c3&gt;タグはブラウザのタブに表示されるアプリケーション名のテキストを含みます。&lt;c4&gt;script&lt;/c4&gt;タグはアプリケーションを動かすJavaScriptファイルのパスを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;url&lt;/c3&gt; is the address for the API endpoint.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T061022Z" creationid="shibukawa.yoshiki" creationdate="20170220T061022Z">
        <seg>&lt;c3&gt;url&lt;/c3&gt;はAPIのエンドポイントのアドレスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;{"/list": UserList}&lt;/c3&gt; object declares a map of existing routes, and what components each route resolves to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T115434Z" creationid="shibukawa.yoshiki" creationdate="20170221T115434Z">
        <seg>&lt;c3&gt;{"/list": UserList}&lt;/c3&gt;オブジェクトは存在するラウトと、それぞれのラウトに対してどのコンポーネントが利用されるのかのマップを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;id&lt;/c4&gt; value is then mapped as an attribute of the component's &lt;a5&gt;vnode&lt;/a5&gt; (&lt;c6&gt;vnode.attrs.id&lt;/c6&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054024Z" creationid="shibukawa.yoshiki" creationdate="20170208T054024Z">
        <seg>&lt;c4&gt;id&lt;/c4&gt;値は、&lt;c6&gt;vnode.attrs.id&lt;/c6&gt;のように、コンポーネントの&lt;a5&gt;vnode&lt;/a5&gt;コンポーネントの属性にマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;promise&lt;/c4&gt; property is the root of the promise tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134134Z" creationid="shibukawa.yoshiki" creationdate="20150415T134134Z">
        <seg>&lt;c4&gt;promise&lt;/c4&gt;プロパティは、promise木のルートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;withCredentials: true&lt;/c4&gt; line indicates that we're using cookies (which is a requirement for the REM API).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T061051Z" creationid="shibukawa.yoshiki" creationdate="20170220T061051Z">
        <seg>&lt;c4&gt;withCredentials: true&lt;/c4&gt;はREM APIで必要となる、クッキーの送受信を有効化する設定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c5&gt;onmatch&lt;/c5&gt; hook would run once again, and since &lt;c6&gt;isLoggedIn&lt;/c6&gt; is true this time, the application would render the &lt;c7&gt;Home&lt;/c7&gt; component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075413Z" creationid="shibukawa.yoshiki" creationdate="20170208T075413Z">
        <seg>&lt;c5&gt;onmatch&lt;/c5&gt;が再度実行されたときに&lt;c6&gt;isLoggedIn&lt;/c6&gt;がtrueであれば、&lt;c7&gt;Home&lt;/c7&gt;コンポーネントがレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140901Z" creationid="shibukawa.yoshiki" creationdate="20150407T140901Z">
        <seg>自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Auto-Redrawing System - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183333Z" creationid="shibukawa.yoshiki" creationdate="20150411T183333Z">
        <seg>自動再描画システム - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CSS above is written using a convention of keeping all styles for a rule in a single line, in alphabetical order.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T045711Z" creationid="shibukawa.yoshiki" creationdate="20170221T045711Z">
        <seg>上記のCSSは、ルールのすべてのスタイルをアルファベット順に1行にまとめるという規約を使って書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CSS selector syntax (e.g. &lt;c0&gt;a#google.external[href='http://google.com']&lt;/c0&gt;) is meant to be used for declaring static attributes in the element, i.e. attribute values that don't change dynamically when the user interacts with the app.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T001946Z" creationid="shibukawa.yoshiki" creationdate="20150413T001946Z">
        <seg>&lt;c0&gt;a#google.external[href='http://google.com']&lt;/c0&gt;)のようなCSSセレクタ文法は、エレメントの静的なアトリビュートの定義で使用します。静的というのはアプリケーションの中で動的に変更されることがない要素になるという意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DOM element that corresponds to virtual element defined by the &lt;c0&gt;m()&lt;/c0&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155036Z" creationid="shibukawa.yoshiki" creationdate="20150413T155036Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;呼び出しで定義された仮想エレメントに対応するDOMエレメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP method to use.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T063234Z" creationid="shibukawa.yoshiki" creationdate="20170219T063234Z">
        <seg>使用するHTTPメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002047Z" creationid="shibukawa.yoshiki" creationdate="20150415T002047Z">
        <seg>HTTPのメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RouterResolver's &lt;c0&gt;onmatch&lt;/c0&gt; hook can be used to run logic before the top level component in a route is initializated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T074931Z" creationid="shibukawa.yoshiki" creationdate="20170208T074931Z">
        <seg>ラウトリゾルバーの&lt;c0&gt;onmatch&lt;/c0&gt;フックはラウトのトップレベルコンポーネントが初期化される前になんらかのロジックを実行するときに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TemperatureConverter controller never stores the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081502Z" creationid="shibukawa.yoshiki" creationdate="20150502T081502Z">
        <seg>TemperatureConverterコントローラは値を保持することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Todo class API is reusable and unit-test friendly, and in addition, it's a plain-vanilla Javascript class, and so has almost no framework-specific learning curve.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234500Z" creationid="shibukawa.yoshiki" creationdate="20150408T234500Z">
        <seg>TodoクラスのAPIは再利用可能で、ユニットテストが容易です。また、プレーンなJavaScriptのクラスであるため、フレームワーク特有の学習は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URL may be either absolute or relative, and it may contain &lt;a0&gt;interpolations&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152406Z" creationid="shibukawa.yoshiki" creationdate="20170219T065246Z">
        <seg>URLは絶対パスでも相対パスでも使用できますし、 &lt;a0&gt;変数（interpolation）&lt;/a0&gt;を含むことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URL to request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002200Z" creationid="shibukawa.yoshiki" creationdate="20150415T002200Z">
        <seg>リクエストを送るURL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URL to send the request to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T064956Z" creationid="shibukawa.yoshiki" creationdate="20170219T064506Z">
        <seg>リクエストを送る先のURLです。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The XMLHttpRequest instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014203Z" creationid="shibukawa.yoshiki" creationdate="20150415T014203Z">
        <seg>XMLHttpRequestのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to "cast" the response to a class of your choice</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014452Z" creationid="shibukawa.yoshiki" creationdate="20150410T014452Z">
        <seg>レスポンスを好きなクラスにキャストする機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to get an early reference to a container that will hold the asynchronous response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014404Z" creationid="shibukawa.yoshiki" creationdate="20150410T014347Z">
        <seg>非同期のレスポンスが後で格納されるコンテンナを事前に参照しておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to handle arguments in the controller is useful for setting up the initial state for a component whose state depends on input data:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084456Z" creationid="shibukawa.yoshiki" creationdate="20150502T084456Z">
        <seg>コントローラ内で引数を持てる機能は、コンポーネントの初期値のセットアップに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to queue operations to be performed after the asynchronous request completes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014429Z" creationid="shibukawa.yoshiki" creationdate="20150410T014429Z">
        <seg>非同期のリクエストが完了した後に実行される操作をキューに貯めておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to unwrap data in a response that includes metadata properties</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014517Z" creationid="shibukawa.yoshiki" creationdate="20150410T014517Z">
        <seg>メタデータのプロパティを含むレスポンスを展開する機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-redraw system - Mithril.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032318Z" creationid="shibukawa.yoshiki" creationdate="20170131T032318Z">
        <seg>自動再描画システム - Mithril.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-redraw system becomes enabled when you call &lt;c0&gt;m.mount&lt;/c0&gt; or &lt;c1&gt;m.route&lt;/c1&gt; (but it stays disabled if your app is bootstrapped solely via &lt;c2&gt;m.render&lt;/c2&gt; calls).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032934Z" creationid="shibukawa.yoshiki" creationdate="20170131T032934Z">
        <seg>自動再描画システムは&lt;c0&gt;m.mount()&lt;/c0&gt;、もしくは&lt;c1&gt;m.route()&lt;/c1&gt;関数を使うと有効化されます。&lt;c2&gt;m.render()&lt;/c2&gt;呼び出しを使って画面更新を行うとこの機能は無効なままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-redraw system simply consists of triggering a re-render function behind the scenes after certain functions complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120710Z" creationid="shibukawa.yoshiki" creationdate="20170206T120710Z">
        <seg>自動再描画システムは単純に、特定の関数の実行が完了したら再描画関数が実行されるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-redrawing system in Mithril is not affected by changes in values of &lt;c0&gt;m.prop&lt;/c0&gt; getter-setters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153954Z" creationid="shibukawa.yoshiki" creationdate="20150416T153954Z">
        <seg>Mithrilの自動再描画システムは、&lt;c0&gt;m.prop&lt;/c0&gt; getter-setterの値の変更では何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic usage pattern for &lt;c0&gt;m.request&lt;/c0&gt; returns an &lt;a1&gt;&lt;c2&gt;m.prop&lt;/c2&gt;&lt;/a1&gt; getter-setter, which is populated when the AJAX request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014645Z" creationid="shibukawa.yoshiki" creationdate="20150410T014645Z">
        <seg>&lt;c0&gt;m.request&lt;/c0&gt;を通常の使用法で使うと、AJAXのリクエストが完了した後に結果が格納される&lt;a1&gt;&lt;c2&gt;m.prop&lt;/c2&gt;&lt;/a1&gt; getter-setterを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The biggest difference between Ember and Mithril is summarized in the Architecture section above: Ember's comprehensiveness comes at the cost of a steep learning curve and a high degree of vendor lock-in.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095436Z" creationid="shibukawa.yoshiki" creationdate="20150420T095436Z">
        <seg>EmberとMithrilの一番大きな違いは、このアーキテクチャの違いに収束します。広範囲に渡るため、急峻なラーニングカーブを持ち、幅広くベンダーにロックインされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The button calls the &lt;c0&gt;todo.vm.add&lt;/c0&gt; method when clicked.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153858Z" creationid="shibukawa.yoshiki" creationdate="20150408T153858Z">
        <seg>ボタンが押されると、&lt;c0&gt;todo.vm.add&lt;/c0&gt;メソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The callbacks for this promise receive as a parameter an Array containing the values of all the input promises</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T181118Z" creationid="shibukawa.yoshiki" creationdate="20150415T181118Z">
        <seg>このpromiseのレシーバーは、入力のメソッドのすべての値を持つ配列を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkboxes save their value to the &lt;c0&gt;task.done&lt;/c0&gt; getter setter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160629Z" creationid="shibukawa.yoshiki" creationdate="20150408T160629Z">
        <seg>チェックボックスは値を&lt;c0&gt;task.done&lt;/c0&gt; getter setterに保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above defines a view-model object called &lt;c0&gt;vm&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162019Z" creationid="shibukawa.yoshiki" creationdate="20150407T162019Z">
        <seg>上記のコードは、&lt;c0&gt;vm&lt;/c0&gt;という名前のビュー・モデルオブジェクトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code bound to the &lt;c0&gt;onchange&lt;/c0&gt; can be read like this: "with the attribute value, set todo.vm.description".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021305Z" creationid="shibukawa.yoshiki" creationdate="20150408T021305Z">
        <seg>このコードは&lt;c0&gt;onchange&lt;/c0&gt;に結び付けれており、「valueの属性の値を, todo.vm.descriptionに設定」するという意味になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete view looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153552Z" creationid="shibukawa.yoshiki" creationdate="20150408T153552Z">
        <seg>完成したviewは次のようなコードになっています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The component documentation contains &lt;a0&gt;more detail on this issue&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T051240Z" creationid="shibukawa.yoshiki" creationdate="20170201T051240Z">
        <seg>コンポーネントのドキュメントに&lt;a0&gt;この問題に関する詳細情報&lt;/a0&gt;が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data to be interpolated into the URL and serialized into the querystring (for GET requests) or body (for other types of requests).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152420Z" creationid="shibukawa.yoshiki" creationdate="20170219T065714Z">
        <seg>URLの変数に挿入されたり、クエリー文字列（GETリクエスト）やボディー（他のメソッドのリクエスト）として文字列化されるデータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data to unwrap</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013000Z" creationid="shibukawa.yoshiki" creationdate="20150415T013000Z">
        <seg>unwrapするデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default strategy uses the hashbang.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100604Z" creationid="shibukawa.yoshiki" creationdate="20170207T100604Z">
        <seg>デフォルトの戦略はハッシュバングです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is &lt;c0&gt;JSON.parse&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013238Z" creationid="shibukawa.yoshiki" creationdate="20150415T013203Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、&lt;c0&gt;JSON.parse&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is &lt;c0&gt;JSON.stringify&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013129Z" creationid="shibukawa.yoshiki" creationdate="20150415T013129Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、&lt;c0&gt;JSON.stringify&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is the identity function &lt;c0&gt;function(value) {return value}&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012744Z" creationid="shibukawa.yoshiki" creationdate="20150415T012744Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、&lt;c0&gt;function(value) {return value}&lt;/c0&gt;という関数と等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value is "search".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004843Z" creationid="shibukawa.yoshiki" creationdate="20150410T004843Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred object can then &lt;e0&gt;apply&lt;/e0&gt; a value by calling either &lt;c1&gt;resolve&lt;/c1&gt; or &lt;c2&gt;reject&lt;/c2&gt;, which then dispatches the value to be processed to the computation tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133747Z" creationid="shibukawa.yoshiki" creationdate="20150415T133718Z">
        <seg>deferredは、&lt;c1&gt;resolve&lt;/c1&gt;もしくは&lt;c2&gt;reject&lt;/c2&gt;を呼び出すことで、値を&lt;e0&gt;適用&lt;/e0&gt;することができます。その値は計算木に渡って処理されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred object returned by &lt;c0&gt;m.deferred&lt;/c0&gt; has two methods: &lt;c1&gt;resolve&lt;/c1&gt; and &lt;c2&gt;reject&lt;/c2&gt;, and one property called &lt;c3&gt;promise&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134006Z" creationid="shibukawa.yoshiki" creationdate="20150415T134006Z">
        <seg>&lt;c0&gt;m.deferred&lt;/c0&gt;関数が返すdeferredオブジェクトは、&lt;c1&gt;resolve&lt;/c1&gt;と&lt;c2&gt;reject&lt;/c2&gt;の2つのメソッドと、&lt;c3&gt;promise&lt;/c3&gt;と呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dependency injector</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045846Z" creationid="shibukawa.yoshiki" creationdate="20150412T154242Z">
        <seg>依存性注入(Dependency Injection)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The description gets crossed out via CSS if the task is marked as done.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160832Z" creationid="shibukawa.yoshiki" creationdate="20150408T160832Z">
        <seg>タスクが完了したとマークされると、CSSを通じて説明が消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deserialized object</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140000Z" creationid="shibukawa.yoshiki" creationdate="20150502T140000Z">
        <seg>デシリアライズしたオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference is that &lt;c2&gt;oninit: User.loadList()&lt;/c2&gt; calls the function once and immediately, but &lt;c3&gt;oninit: User.loadList&lt;/c3&gt; only calls that function when the component renders.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T150136Z" creationid="shibukawa.yoshiki" creationdate="20170220T150136Z">
        <seg>これらの違いは、&lt;c2&gt;oninit: User.loadList()&lt;/c2&gt;の場合はその場で実行されますが、&lt;c3&gt;oninit: User.loadList&lt;/c3&gt;コンポーネントのレンダリング時にのみ呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference with the modified version is that &lt;c0&gt;add&lt;/c0&gt; no longer takes an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152436Z" creationid="shibukawa.yoshiki" creationdate="20150408T152436Z">
        <seg>変更前のコードと異なっているのは&lt;c0&gt;add&lt;/c0&gt;メソッドの引数がなくなった点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference, aside from avoiding an anonymous function, is that the &lt;c0&gt;m.withAttr&lt;/c0&gt; idiom also takes care of catching the correct event target and selecting the appropriate source of the data - i.e. whether it should come from a Javascript property or from &lt;c1&gt;DOMElement::getAttribute()&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151145Z" creationid="shibukawa.yoshiki" creationdate="20150408T151145Z">
        <seg>無名関数の使用を避ける以外の違いとしては、&lt;c0&gt;m.withAttr&lt;/c0&gt;を使うと、正しいイベントターゲットや、適切なデータソースを選んでくれます。例えば、その入力ソースがJavaScriptのプロパティか、&lt;c1&gt;DOMElement::getAttribute()&lt;/c1&gt;かといった違いを識別して、適切な動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The different between &lt;c0&gt;m.mount&lt;/c0&gt; and &lt;a1&gt;&lt;c2&gt;m.render&lt;/c2&gt;&lt;/a1&gt; is that a component rendered via &lt;c3&gt;m.mount&lt;/c3&gt; auto-redraws automatically when event handlers are triggered, whereas components rendered via &lt;c4&gt;m.render&lt;/c4&gt; do not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125206Z" creationid="shibukawa.yoshiki" creationdate="20150502T125206Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;と&lt;a1&gt;&lt;c2&gt;m.render&lt;/c2&gt;&lt;/a1&gt;の違いは、&lt;c3&gt;m.mount&lt;/c3&gt;の場合は自動再描画システムがイベントハンドラから起動されるが、&lt;c4&gt;m.render&lt;/c4&gt;は起動しない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to do that is from a &lt;c2&gt;&lt;input type="file"&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155348Z" creationid="shibukawa.yoshiki" creationdate="20170219T155348Z">
        <seg>もっとも簡単な方法は&lt;c2&gt;&lt;input type="file"&gt;&lt;/c2&gt;を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to polyfill these features is to include this script:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014737Z" creationid="shibukawa.yoshiki" creationdate="20150417T014614Z">
        <seg>次のスクリプト(polyfillと呼ばれる互換性向上コード)を読み込ませるのがもっとも簡単な補完方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to try out Mithril is to include it from a CDN, and follow this tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T025358Z" creationid="shibukawa.yoshiki" creationdate="20170131T025358Z">
        <seg>CDNを使ってMithrilを読み込んで、これから説明するチュートリアルをなぞるのが、Mithrilを試すもっとも簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effort to make the table paginated, searchable or filterable can improve the user experience in addition to solving the performance problem both on redraws and on initial page load.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143606Z" creationid="shibukawa.yoshiki" creationdate="20150412T143606Z">
        <seg>テーブルをページ分割したり、ソートやフィルタ可能にすると、ユーザエクスペリエンスが向上するだけでなく、再描画と初期のページロードの両方のパフォマンスの問題が解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is that Mithril waits for all requests to complete before attempting to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154538Z" creationid="shibukawa.yoshiki" creationdate="20150416T154538Z">
        <seg>すべてのリクエストが完了するのを待って、Mithrilは再描画を行おうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is that you can call &lt;c6&gt;m.request&lt;/c6&gt; and other integrated data services seamlessly, and Mithril will wait for all of the asynchronous operations to complete before attempting to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190821Z" creationid="shibukawa.yoshiki" creationdate="20150411T190821Z">
        <seg>これによって、&lt;c6&gt;m.request&lt;/c6&gt;や他のデータサービスとの統合をシームレスに行えるようになっています。Mithrilはすべての非同期操作が完了するのをまってから再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above is just an illustration of a not-so-widespread convention that has strong rationales behind it, but deviate from the more widespread cosmetic-oriented spacing conventions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T050710Z" creationid="shibukawa.yoshiki" creationdate="20170221T050710Z">
        <seg>このサンプルが紹介しているルールはあまり広まっていはいませんが、強い理由付けがあるルールになっています。より広く使うルールもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines three routes, to be rendered in &lt;c0&gt;&lt;body&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002804Z" creationid="shibukawa.yoshiki" creationdate="20150410T002804Z">
        <seg>次のサンプルは、&lt;body&gt;のレンダリングをする、3つのラウトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a contrived redraw counter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125842Z" creationid="shibukawa.yoshiki" creationdate="20150413T125842Z">
        <seg>次のサンプルは、再描画のカウントを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a convoluted series of AJAX requests implemented with a third party library.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010751Z" creationid="shibukawa.yoshiki" creationdate="20150412T010751Z">
        <seg>次のサンプルには、サードパーティライブラリを使った複雑に入り組んだAJAXリクエストのかたまりがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a route that takes a &lt;c0&gt;userID&lt;/c0&gt; parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003111Z" creationid="shibukawa.yoshiki" creationdate="20150410T003111Z">
        <seg>次のサンプルは&lt;c0&gt;userID&lt;/c0&gt;パラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a route that takes an &lt;c0&gt;userID&lt;/c0&gt; parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153431Z" creationid="shibukawa.yoshiki" creationdate="20150414T153431Z">
        <seg>次のサンプルは&lt;c0&gt;userID&lt;/c0&gt;パラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a simple component that integrates with the &lt;a0&gt;select2 library&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021607Z" creationid="shibukawa.yoshiki" creationdate="20150412T014035Z">
        <seg>次のサンプルは、&lt;a0&gt;select2ライブラリ&lt;/a0&gt;(jQuery用の拡張版&lt;select&gt;タグを提供するライブラリ)を統合した、シンプルなコンポーネントの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a variation of the contacts app where &lt;c0&gt;ContactForm&lt;/c0&gt; is responsible for saving.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113524Z" creationid="shibukawa.yoshiki" creationdate="20150502T030623Z">
        <seg>次のサンプルは、連絡先アプリの別バージョンで、&lt;c0&gt;ContactForm&lt;/c0&gt;が保存の責務を担っているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to configure a request where the server expects requests to have a &lt;c0&gt;Content-Type: application/json&lt;/c0&gt; header</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182219Z" creationid="shibukawa.yoshiki" creationdate="20150414T182219Z">
        <seg>下記の例は、サーバがリクエストとして&lt;c0&gt;Content-Type: application/json&lt;/c0&gt;ヘッダを期待しているときに、それを行うための方法を示したサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to implement a login wall that prevents users from seeing the &lt;c1&gt;/secret&lt;/c1&gt; page unless they login.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075024Z" creationid="shibukawa.yoshiki" creationdate="20170208T075024Z">
        <seg>次のサンプルは、ログインスクリーンを作成し、ログインしていないユーザーに&lt;c1&gt;/secret&lt;/c1&gt;ページを見せないようにするサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to receive a plain string from a txt file.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175346Z" creationid="shibukawa.yoshiki" creationdate="20150410T175346Z">
        <seg>次のサンプルはテキストファイルをそのままプレーンな文字列として受ける取る方法を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to use a SubtreeDirective object to create a static header that doesn't incur diff costs once it has been rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124343Z" creationid="shibukawa.yoshiki" creationdate="20150416T124343Z">
        <seg>下記の例は静的なヘッダーに対してサブツリーディレクティブをどのように使用するかのサンプルです。このようにすることで、一度レンダリングされた後は差分検出のコストが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples in this site usually conflate different MVC layers together for the sake of readability, but normally it's recommended that each layer on a module be in different files.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015128Z" creationid="shibukawa.yoshiki" creationdate="20150421T015128Z">
        <seg>このサイトのサンプルは、読みやすさのために異なるMVCレイヤーを1つのファイルにまとめていますが、レイヤーごとにファイルを分割するのが推奨されるスタイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception monitor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015810Z" creationid="shibukawa.yoshiki" creationdate="20150415T015810Z">
        <seg>例外モニタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The existence of the component only becomes known to the diff engine at the time when the template is rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093533Z" creationid="shibukawa.yoshiki" creationdate="20150502T093533Z">
        <seg>差分検知エンジンは、テンプレートをレンダリングする時にのみ、コンポーネントの存在を検知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first &lt;c1&gt;charset&lt;/c1&gt; meta tag indicates the encoding of the document and the &lt;c2&gt;viewport&lt;/c2&gt; meta tag dictates how mobile browsers should scale the page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170205T000514Z" creationid="shibukawa.yoshiki" creationdate="20170205T000514Z">
        <seg>最初の&lt;c1&gt;charset&lt;/c1&gt;メタタグはドキュメントのエンコーディングを指定します。&lt;c2&gt;viewport&lt;/c2&gt;メタタグはモバイルブラウザがどのようにページを拡大して表示するかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first and most obvious thing you may have noticed in the view layer is that the view is not written in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013054Z" creationid="shibukawa.yoshiki" creationdate="20150409T013054Z">
        <seg>これがもっともはっきりと気づいてもらいやすい点が、ビューがHTMLに書かれていないという点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter after the component object is meant to be used as an attribute map and should be an object (e.g. &lt;c0&gt;{name: "world"}&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080026Z" creationid="shibukawa.yoshiki" creationdate="20150502T080026Z">
        <seg>コンポーネントオブジェクトの後の最初のパラメータは属性のマップで、&lt;c0&gt;{name: "world"}&lt;/c0&gt;などのオブジェクトを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates this pattern:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081054Z" creationid="shibukawa.yoshiki" creationdate="20150502T081054Z">
        <seg>次のサンプルはこのパターンを説明しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following topics are good places to start a deeper dive.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015805Z" creationid="shibukawa.yoshiki" creationdate="20150409T015805Z">
        <seg>Mithrilについてより深く知りたい場合には次のトピックが良い出発点になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of the framework is to make application code discoverable, readable and maintainable, and hopefully help you become an even better developer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141806Z" creationid="shibukawa.yoshiki" creationdate="20150407T141806Z">
        <seg>このフレームワークのゴールは、アプリケーションコードの探索しやすさ、読みやすさ、メンテナンス性を向上させ、あなたがすばらしい開発者になる手助けをすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implications of saving are left to the parent component to handle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010840Z" creationid="shibukawa.yoshiki" creationdate="20150502T010840Z">
        <seg>保存の操作については、親のコンポーネントに残してあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization code defines a &lt;c0&gt;change&lt;/c0&gt; event handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134001Z" creationid="shibukawa.yoshiki" creationdate="20150412T134001Z">
        <seg>初期化コードは&lt;c0&gt;change&lt;/c0&gt;イベントハンドラを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key for each child must be unique among a list of sibling DOM elements, but it does not need to be globally unique.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142205Z" creationid="shibukawa.yoshiki" creationdate="20150413T142205Z">
        <seg>リストの子の兄弟のDOMエレメントのキーはユニークでなければなりませんが、アプリケーション全体でグローバルにユニークである必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key is defined in the &lt;c1&gt;li&lt;/c1&gt;, which is the closest element to the &lt;c2&gt;items&lt;/c2&gt; array, not directly on the &lt;c3&gt;input&lt;/c3&gt;, even though we want to track focus on the input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T143904Z" creationid="shibukawa.yoshiki" creationdate="20150413T143904Z">
        <seg>キーは、&lt;c2&gt;items&lt;/c2&gt;配列に一番近いエレメントの&lt;c1&gt;li&lt;/c1&gt;エレメントに設定します。フォーカスを維持したいのは&lt;c3&gt;input&lt;/c3&gt;エレメントですが、このエレメントに直接キーを設定することはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter APIs and the associated behaviour has been removed in v1.x.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T120444Z" creationid="shibukawa.yoshiki" creationdate="20170131T120444Z">
        <seg>これらのAPIと、関連する動作はv1.xで削除されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list can have todo items added to it via the &lt;c1&gt;push&lt;/c1&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151931Z" creationid="shibukawa.yoshiki" creationdate="20150407T151931Z">
        <seg>配列の方は&lt;c1&gt;push&lt;/c1&gt;メソッドを使ってTodoの項目を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lowest level rendering method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153918Z" creationid="shibukawa.yoshiki" creationdate="20150412T153918Z">
        <seg>低レベルのレンダリングの方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference between Angular templates and Mithril templates is that Angular templates follow the tradition of being defined in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025135Z" creationid="shibukawa.yoshiki" creationdate="20150420T025135Z">
        <seg>一番大きな違いは、AngularとMithrilのテンプレートです。AngularのテンプレートはHTMLの中に定義するという、伝統的な方法を取っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The menu is itself being defined as a component to avoid repetition:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100918Z" creationid="shibukawa.yoshiki" creationdate="20170207T100918Z">
        <seg>コードの重複を避けるためにメニューそのものもコンポーネントとなっています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method signature is the same.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141400Z" creationid="shibukawa.yoshiki" creationdate="20160412T141400Z">
        <seg>メソッドのシグニチャには変化はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods can be called to dispatch a value to the promise tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134114Z" creationid="shibukawa.yoshiki" creationdate="20150415T134114Z">
        <seg>これらのメソッドを呼ぶと、promise木に値を送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mock object used by Mithril for its own test suite &lt;a2&gt;can be found in the development repo&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160830Z" creationid="shibukawa.yoshiki" creationdate="20150416T160830Z">
        <seg>Mithril自身がテストで使っているモックは&lt;a2&gt;開発リポジトリ&lt;/a2&gt;の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most interesting component is &lt;c0&gt;ContactsWidget&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002616Z" creationid="shibukawa.yoshiki" creationdate="20150502T002616Z">
        <seg>もっとも興味深いコンポーネントは&lt;c0&gt;ContactsWidget&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most relevant difference is that Vue uses &lt;a0&gt;browser features that don't work (and cannot be made to work) in Internet Explorer 8 and lower&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110137Z" creationid="shibukawa.yoshiki" creationdate="20150420T110137Z">
        <seg>Mithrilともっとも異なる点は、&lt;a0&gt;ViewがInernet Explorer 8以下では動作せず、代替のない機能を利用している点です&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most visible difference between React and Mithril is that React's &lt;e0&gt;JSX&lt;/e0&gt; syntax does not run natively in the browser, whereas Mithril's uncompiled templates do.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100217Z" creationid="shibukawa.yoshiki" creationdate="20150420T100045Z">
        <seg>見た目で一番大きくことなるのは、ブラウザ上でそのままは動作しない&lt;e0&gt;JSX&lt;/e0&gt;という文法です。Mithrilのコンパイルしていないテンプレートはそのまま動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a route parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T135425Z" creationid="shibukawa.yoshiki" creationdate="20160101T135425Z">
        <seg>ラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the querystring key that defines the name of the callback function to be called by the response.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014619Z" creationid="shibukawa.yoshiki" creationdate="20150415T014619Z">
        <seg>レスポンス受け取るコールバック関数を定義する、クエリー文字列の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new API also supports hashbang (&lt;c10&gt;#!&lt;/c10&gt;), which is the default, and it supports non-root pathnames and arbitrary mode variations such as querybang (&lt;c11&gt;?!&lt;/c11&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T141226Z" creationid="shibukawa.yoshiki" creationdate="20170131T141226Z">
        <seg>新APIはハッシュバング（&lt;c10&gt;#!&lt;/c10&gt;）もサポートしており、これがデフォルトモードとなっています。このAPIはルート以外のパス名や、クエリーバング（&lt;c11&gt;?!&lt;/c11&gt;）などの任意の文字列が設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new strategy will apply to the next scheduled redraw, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130855Z" creationid="shibukawa.yoshiki" creationdate="20150416T130855Z">
        <seg>これを設定すると、次にスケジュールされている再描画の時点から、新しい方法が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next step is to write a view so users can interact with the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040836Z" creationid="shibukawa.yoshiki" creationdate="20150502T040836Z">
        <seg>次に、ユーザとアプリケーションがインタラクションするためのビューを書きましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The object which the &lt;c0&gt;this&lt;/c0&gt; keyword points to for the callback</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T135147Z" creationid="shibukawa.yoshiki" creationdate="20160101T135147Z">
        <seg>コールバック内で&lt;c0&gt;this&lt;/c0&gt;キーワードが指すオブジェクトを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observer pattern</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180155Z" creationid="shibukawa.yoshiki" creationdate="20150501T180155Z">
        <seg>オブザーバパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only reason I talked about partial application here was to make you aware of that technique, since it becomes useful when dealing with parameterized event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152718Z" creationid="shibukawa.yoshiki" creationdate="20150408T152718Z">
        <seg>部分適用を使って説明したのは、単にこのようなテクニックが使えるということを紹介する目的でした。これを使うと、パラメータを持つイベントハンドラの可能性が広がります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only reasonable course of action to prevent the potential null reference exceptions in this case is to add the existence check in the source code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172853Z" creationid="shibukawa.yoshiki" creationdate="20150415T172853Z">
        <seg>このような問題を防ぐ唯一の方法は、null参照例外が発生する可能性のあるすべての箇所に存在チェックを追加する方法しかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;c0&gt;controller&lt;/c0&gt; function creates an object that may be used in the following recommended ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061513Z" creationid="shibukawa.yoshiki" creationdate="20150502T061513Z">
        <seg>オプションの&lt;c0&gt;controller&lt;/c0&gt;関数は、次のように使われるオブジェクトを作成することが期待されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other side of the coin is still supported: if a developer needs to signal an exceptional condition within a promise callback, they can manually throw a &lt;c0&gt;new Error&lt;/c0&gt; (for example, if a validation rule failed, and there should be an error message displayed to the user).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173349Z" creationid="shibukawa.yoshiki" creationdate="20150415T173349Z">
        <seg>もちろん、コインの反対側の標準のPromise/A+の仕様もサポートされています。バリデーションの失敗があってエラーメッセージを表示しなければならない場合など、開発者がpromiseのコールバックの中で例外の発生を知らせなければならない場合は、&lt;c0&gt;new Error&lt;/c0&gt;で作成した例外を投げて、それを受け取ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter to &lt;c0&gt;options.extract&lt;/c0&gt; is the XMLHttpRequest object once its operation is completed, but before it has been passed to the returned promise chain, so the promise may still end up in an rejected state if processing throws an exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T010108Z" creationid="shibukawa.yoshiki" creationdate="20170220T010108Z">
        <seg>&lt;c0&gt;options.extract&lt;/c0&gt;関数のパラメータは、送受信が完了した後のXMLHttpRequestオブジェクトです。この段階はまだPromiseチェーンに渡される前の状態なので、例外を投げるとPromiseは「リジェクト状態」で終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The params in this doc refer to properties of the `ctrl` argument</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132303Z" creationid="shibukawa.yoshiki" creationdate="20160101T132303Z">
        <seg>このドキュメントのパラメータは、`ctrl`引数のプロパティについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path may include slots for routing parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080550Z" creationid="shibukawa.yoshiki" creationdate="20170207T080550Z">
        <seg>パスにはラウとのパラメータを含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path to route to, without a prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080519Z" creationid="shibukawa.yoshiki" creationdate="20170207T080519Z">
        <seg>移行先のラウト。ただしプリフィックスは含まない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pathname strategy produces the cleanest looking URLs, but does not work in IE9 &lt;e0&gt;and&lt;/e0&gt; requires setting up the server to serve the single page application code from every URL that the application can route to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T095005Z" creationid="shibukawa.yoshiki" creationdate="20170207T095005Z">
        <seg>パス名戦略はもっともクリーンなURLを生成しますが、IE9をサポートしません。&lt;e0&gt;なおかつ&lt;/e0&gt;アプリケーションのラウターで取りうるすべてのURLでシングルページアプリケーションのコードを返すようにサーバーを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The performance tests in the homepage show execution times for parsing and evaluation of Mithril's code, compared to some popular frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113646Z" creationid="shibukawa.yoshiki" creationdate="20150417T113646Z">
        <seg>ホームページのパフォーマンステストでは、Mithrilと他の有名なフレームワークで、コードのパースと評価にかかる時間の比較をしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prefix that controls the underlying &lt;a0&gt;routing strategy&lt;/a0&gt; used by Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T083122Z" creationid="shibukawa.yoshiki" creationdate="20170207T083016Z">
        <seg>プリフィックスはMithrilが内部で使用する&lt;a0&gt;ラウト戦略&lt;/a0&gt;を制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem with animating before removing an element is that we must wait until the animation is complete before we can actually remove the element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105655Z" creationid="shibukawa.yoshiki" creationdate="20170206T105655Z">
        <seg>以前のバージョンでは、要素の削除時にアニメーションさせるのは、本当の削除が行われるまで実際の削除を遅延させるというややこしい実装が必要でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem, of course, is that we never called the &lt;c0&gt;User.loadList&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T144740Z" creationid="shibukawa.yoshiki" creationdate="20170220T144740Z">
        <seg>このコードには問題があります。それは&lt;c0&gt;User.loadList&lt;/c0&gt;関数を呼んでいないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise object is actually a getter-setter function that gets populated when the promise is fulfilled.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135159Z" creationid="shibukawa.yoshiki" creationdate="20150415T135159Z">
        <seg>promiseオブジェクトは実際のgetter-setter関数であるため、promiseが果たされると、値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise of the deferred object that is resolved when all input promises have been resolved</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180934Z" creationid="shibukawa.yoshiki" creationdate="20150415T180934Z">
        <seg>入力に渡されたすべてのpromiseが解決したときに解決されるpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The querystring strategy also technically works in IE9, but it falls back to reloading the page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T094631Z" creationid="shibukawa.yoshiki" creationdate="20170207T094631Z">
        <seg>クエリー文字列戦略も技術的にはIE9で動作しますが、ページのリロードが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason Mithril waits for all asynchronous services to complete before redrawing is to avoid wasteful browser repaints, and to minimize the need for null reference checks in templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154844Z" creationid="shibukawa.yoshiki" creationdate="20150416T154844Z">
        <seg>Mithrilがすべての非同期サービスの待ち合わせをするのは、何度もムダなブラウザ再描画を行わないようにしたり、テンプレート内でnull参照チェックを行う回数を減らす、という理由によるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response object (or the child items if this object is an Array) will be passed as a parameter to the class constructor defined by &lt;c0&gt;type&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013750Z" creationid="shibukawa.yoshiki" creationdate="20150415T013750Z">
        <seg>レスポンスオブジェクト、もしくはレスポンスが配列の場合はその子供は、&lt;c0&gt;type&lt;/c0&gt;で定義されているクラスコンストラクタに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the code can be implemented using idioms we already covered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153535Z" creationid="shibukawa.yoshiki" creationdate="20150408T153535Z">
        <seg>残りのコードは、これまで説明してきたテクニックで書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the &lt;c3&gt;controller&lt;/c3&gt; function is passed to the &lt;c4&gt;view&lt;/c4&gt; as its first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072010Z" creationid="shibukawa.yoshiki" creationdate="20150502T072010Z">
        <seg>&lt;c3&gt;controller&lt;/c3&gt;関数の返り値は、&lt;c4&gt;view&lt;/c4&gt;関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the controller function is passed to the view function as its first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125510Z" creationid="shibukawa.yoshiki" creationdate="20150502T125510Z">
        <seg>controller関数の返り値は、view関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the view function is merely a plain Javascript data structure that represents a DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072424Z" creationid="shibukawa.yoshiki" creationdate="20150502T072424Z">
        <seg>ビュー関数の返り値はDOMを表現したJavaScriptのデータ構造です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned VirtualElement is a Javascript data structure that represents the DOM element to be rendered by &lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160555Z" creationid="shibukawa.yoshiki" creationdate="20150413T160555Z">
        <seg>返されるVirtualElementは、DOMエレメントを表すデータ構造です。このデータ構造は&lt;a0&gt;&lt;c1&gt;m.render&lt;/c1&gt;&lt;/a0&gt;を通じてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned getter-setter also implements the &lt;a0&gt;promise&lt;/a0&gt; interface (also known as a &lt;e1&gt;thenable&lt;/e1&gt;): this is the mechanism you should always use to queue operations to be performed on the data from the web service.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140904Z" creationid="shibukawa.yoshiki" creationdate="20160101T140904Z">
        <seg>返されるgetter-setterは&lt;a0&gt;promise&lt;/a0&gt;のインタフェース(&lt;e1&gt;thenable&lt;/e1&gt;とも呼ばれる)を持っています。この機能は、ウェブサービスからデータが帰ってきた後の操作をキューイングするのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned getter-setter also implements the &lt;a0&gt;promise&lt;/a0&gt; interface (also known as a &lt;e1&gt;thennable&lt;/e1&gt;): this is the mechanism you should always use to queue operations to be performed on the data from the web service.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015523Z" creationid="shibukawa.yoshiki" creationdate="20150410T015523Z">
        <seg>返されるgetter-setterは&lt;a0&gt;promise&lt;/a0&gt;のインタフェース(&lt;e1&gt;thennable&lt;/e1&gt;とも呼ばれる)を持っています。この機能は、ウェブサービスからデータが帰ってきた後の操作をキューイングするのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned getter-setter can be thought of as a box: you can pass this reference around cheaply, and you can "unwrap" its value when needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014906Z" creationid="shibukawa.yoshiki" creationdate="20150410T014906Z">
        <seg>getter-setterを返すことは参照を安いコストでコード内に渡すことができて、値が必要になったときにデータの実体を取り出すことができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned string is a String object instance (as opposed to a string primitive) containing the same HTML content, and exposing a flag property for internal use within Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015545Z" creationid="shibukawa.yoshiki" creationdate="20150416T015545Z">
        <seg>返される文字列は文字列オブジェクトのインスタンス(文字列プリミティブではない)で、同じHTMLコンテンツと、Mithril内部で使用するフラグ属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned window is the same as what is passed in.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162202Z" creationid="shibukawa.yoshiki" creationdate="20150416T162154Z">
        <seg>引数に渡されたのと同じwindowを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The root DOM element in a component's view must not be changed during the lifecycle of the component, otherwise undefined behavior will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095939Z" creationid="shibukawa.yoshiki" creationdate="20150502T095939Z">
        <seg>コンポーネントのビューのルートのDOMエレメントはコンポーネントのライフサイクル内で変更してはいけません。未定義の動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The route to redirect to if the current URL does not match a route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080248Z" creationid="shibukawa.yoshiki" creationdate="20170207T080248Z">
        <seg>現在のURLが、定義されたどのラウトにもマッチしなかった時にリダイレクトされる先のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The route to redirect to if the current URL does not match any of the defined routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155753Z" creationid="shibukawa.yoshiki" creationdate="20150414T155753Z">
        <seg>現在のURLが、どの定義されたラウトにもマッチしなかった時にリダイレクトされラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The route to redirect to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171417Z" creationid="shibukawa.yoshiki" creationdate="20150414T171417Z">
        <seg>リダイレクト先のラウト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The router path requested by the last routing action, including interpolated routing parameter values, but without the prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085915Z" creationid="shibukawa.yoshiki" creationdate="20170207T085915Z">
        <seg>最後にラウト操作を行った時のラウターパスです。ラウターパラメータ値は入りますが、プリフィックスは含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The router prefix is a fragment of the URL that dictates the underlying &lt;a0&gt;strategy&lt;/a0&gt; used by the router.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T083044Z" creationid="shibukawa.yoshiki" creationdate="20170207T082935Z">
        <seg>ラウタープリフィックはラウターが使用する&lt;a0&gt;戦略&lt;/a0&gt;を決定する文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The routing strategy dictates how a library might actually implement routing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092258Z" creationid="shibukawa.yoshiki" creationdate="20170207T092258Z">
        <seg>ラウと戦略は、ライブラリがどのようにラウトを取り扱うのかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second one has a data binding to the &lt;c1&gt;description&lt;/c1&gt; getter-setter of the Todo class instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153318Z" creationid="shibukawa.yoshiki" creationdate="20150408T153318Z">
        <seg>2つ目のタグは、Todoクラスのインスタンス&lt;c1&gt;description&lt;/c1&gt; getter-setterへのバインディングが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second one is called if it completes with an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114500Z" creationid="shibukawa.yoshiki" creationdate="20150414T175019Z">
        <seg>2つ目のパラメータはエラーで完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second parameter is called if it completes with an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114512Z" creationid="shibukawa.yoshiki" creationdate="20150410T124846Z">
        <seg>2つ目のパラメータはエラーで完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serialized representation of the input data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171011Z" creationid="shibukawa.yoshiki" creationdate="20150414T171011Z">
        <seg>入力データのシリアライズ化表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest server-side setup possible to support pathname mode is to serve the same content regardless of what URL is requested.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012822Z" creationid="shibukawa.yoshiki" creationdate="20150410T012822Z">
        <seg>pathnameモードを使用するためのサーバ設定の中で、一番簡単な方法は、どのURLが要求されても同じコンテンツを返すようにする方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest use case of this feature is to implement functional value assignment via &lt;c0&gt;m.prop&lt;/c0&gt; (i.e. the same thing as above).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015909Z" creationid="shibukawa.yoshiki" creationdate="20150410T015842Z">
        <seg>この機能のもっとも簡単な使い方は、&lt;c0&gt;m.prop&lt;/c0&gt;を使って関数型的な値の割り当てを行うことです(上記のコードと等価です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snippet above renders a file input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155414Z" creationid="shibukawa.yoshiki" creationdate="20170219T155414Z">
        <seg>上記のスニペットはファイルのinputタグをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string &lt;c0&gt;johndoe&lt;/c0&gt; is bound to the &lt;c1&gt;:userID&lt;/c1&gt; parameter, which can be retrieved programmatically in the controller via &lt;c2&gt;m.route.param("userID")&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004107Z" creationid="shibukawa.yoshiki" creationdate="20150410T003958Z">
        <seg>&lt;c0&gt;johndoe&lt;/c0&gt;という文字列が&lt;c1&gt;:userID&lt;/c1&gt;パラメータに結び付けられます。このパラメータは、コントローラ内で&lt;c2&gt;m.route.param("userID")&lt;/c2&gt;というAPI呼び出しをするとプログラムから参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The table lists all the existing to-dos, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153940Z" creationid="shibukawa.yoshiki" creationdate="20150408T153940Z">
        <seg>もし既存のToDoがある場合は、既存のすべてのToDoが表形式で出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text input saves its value to the &lt;c0&gt;todo.vm.description&lt;/c0&gt; getter-setter we defined earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153841Z" creationid="shibukawa.yoshiki" creationdate="20150408T153841Z">
        <seg>テキスト入力は、値を、以前定義した&lt;c0&gt;todo.vm.description&lt;/c0&gt; getter-setter に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thenable mechanism is intended to be used in three ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140929Z" creationid="shibukawa.yoshiki" creationdate="20160101T140929Z">
        <seg>thenableの仕組みは主に以下の3ヶ所で使われることを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thennable mechanism is intended to be used in three ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123530Z" creationid="shibukawa.yoshiki" creationdate="20150410T123530Z">
        <seg>thennableの仕組みは主に以下の3ヶ所で使われることを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third argument for &lt;c0&gt;config&lt;/c0&gt; allows you to map data to a virtual DOM element in a way that persists across redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125558Z" creationid="shibukawa.yoshiki" creationdate="20150413T125558Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;の3番目の引数を使うと、再描画時に仮想のDOM要素を保持しておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tool allows you to write code like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013900Z" creationid="shibukawa.yoshiki" creationdate="20150417T013900Z">
        <seg>このツールを使うと、次のようなコードが書けます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tool takes regular Mithril templates like the one below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T141506Z" creationid="shibukawa.yoshiki" creationdate="20160101T141506Z">
        <seg>このツールは下記のような通常のMithrilのテンプレートを受け取ります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013018Z" creationid="shibukawa.yoshiki" creationdate="20150415T013018Z">
        <seg>unwrapされたデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The utility method &lt;c0&gt;m()&lt;/c0&gt; creates virtual DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004251Z" creationid="shibukawa.yoshiki" creationdate="20150408T004251Z">
        <seg>&lt;c0&gt;m()&lt;/c0&gt;というユーティリティ関数はvirtual DOMの要素を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that maps to the parameter specified by &lt;c0&gt;key&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170834Z" creationid="shibukawa.yoshiki" creationdate="20150414T170834Z">
        <seg>&lt;c0&gt;key&lt;/c0&gt;にマップされたパラメータの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that populates the returned getter-setter before the request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012356Z" creationid="shibukawa.yoshiki" creationdate="20150415T012356Z">
        <seg>リクエスト完了前に、この関数が返すgetter-setterが内部で保持する初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that replace the dynamic parameters in a URL are available via &lt;c0&gt;m.route.param()&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165328Z" creationid="shibukawa.yoshiki" creationdate="20150414T165328Z">
        <seg>URLの中で動的パラメータを置き換えた値は、&lt;c0&gt;m.route.param()&lt;/c0&gt;を通じて取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The vast majority of times, it's advisable to use &lt;c2&gt;m.mount&lt;/c2&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100346Z" creationid="shibukawa.yoshiki" creationdate="20150502T100220Z">
        <seg>ほとんどの場合は、代わりに&lt;c2&gt;m.mount&lt;/c2&gt;を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The view function is run again whenever a redraw is required (i.e. whenever event handlers are triggered by user input).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072719Z" creationid="shibukawa.yoshiki" creationdate="20150502T072719Z">
        <seg>ユーザ入力イベントのハンドラが起動された時など、再描画が必要な時にview関数は何度も呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The virtual DOM data structure to which the config is applied to</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140052Z" creationid="shibukawa.yoshiki" creationdate="20150502T140052Z">
        <seg>configを適用する仮想DOMデータ構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The virtual DOM diffing algorithm has a weakness: a naive diff is not aware of the identity of DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141044Z" creationid="shibukawa.yoshiki" creationdate="20150413T141006Z">
        <seg>仮想DOMの差分検知アルゴリズムには、DOM要素の厳密な同一性について判断できないという欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The virtual DOM element to which the &lt;c0&gt;config&lt;/c0&gt; function is attached</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T050321Z" creationid="shibukawa.yoshiki" creationdate="20160423T050321Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;関数が設定された仮想DOMエレメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way the redrawing engine defers redrawing is by keeping an internal counter that is incremented by &lt;c4&gt;m.startComputation&lt;/c4&gt; and decremented by &lt;c5&gt;m.endComputation&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190021Z" creationid="shibukawa.yoshiki" creationdate="20150411T190021Z">
        <seg>再描画エンジンは、内部のカウンタを使って再描画のタイミングを遅らせます。カウンタは&lt;c4&gt;m.startComputation&lt;/c4&gt;を呼び出すとインクリメントされ、&lt;c5&gt;m.endComputation&lt;/c5&gt;を呼び出すとデクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we can &lt;c0&gt;require&lt;/c0&gt; this new module from &lt;c1&gt;src/index.js&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120121Z" creationid="shibukawa.yoshiki" creationdate="20170221T120121Z">
        <seg>モジュールがでｋちあら&lt;c0&gt;require&lt;/c0&gt;を使って&lt;c1&gt;src/index.js&lt;/c1&gt;にこの新しいモジュールを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we can add an &lt;c0&gt;m.request&lt;/c0&gt; call to make an XHR request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055638Z" creationid="shibukawa.yoshiki" creationdate="20170220T055638Z">
        <seg>それではXHRリクエストを行う&lt;c0&gt;m.request&lt;/c0&gt;呼び出しを行いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we return a &lt;a0&gt;Promise&lt;/a0&gt; that resolves after half a second.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110412Z" creationid="shibukawa.yoshiki" creationdate="20170206T110412Z">
        <seg>その後、0.5秒後に解決される&lt;a0&gt;Promise&lt;/a0&gt;を返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, once data is available, the UI redraws and a list of user ids is shown.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T081516Z" creationid="shibukawa.yoshiki" creationdate="20170208T081516Z">
        <seg>データが利用可能にあると、UIが再描画され、ユーザーIDのリストが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, to compile a file, type:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T141603Z" creationid="shibukawa.yoshiki" creationdate="20160101T141603Z">
        <seg>インストールが終わって、ファイルをコンパイルするには次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, to use Mithril, point a script tag to the downloaded file:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T170149Z" creationid="shibukawa.yoshiki" creationdate="20150407T170149Z">
        <seg>Mithrilを使う場合には、scriptタグを使って、ダウンロードしたファイルを参照します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are &lt;a0&gt;different ways to organize components&lt;/a0&gt; that can side-step the need for multiple redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094012Z" creationid="shibukawa.yoshiki" creationdate="20150502T094012Z">
        <seg>再描画が何度か走るのを避ける&lt;a0&gt;コンポーネントの組み立て方&lt;/a0&gt;もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a couple of reasons why Mithril runs callbacks synchronously.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140627Z" creationid="shibukawa.yoshiki" creationdate="20150415T140627Z">
        <seg>Mithrilがコールバックを同期で実行しているにはいくつか理由があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few differences between this example and the one before.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T144611Z" creationid="shibukawa.yoshiki" creationdate="20170219T144611Z">
        <seg>最初のサンプルに対して、いくつか違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few other technical caveats when nesting components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095608Z" creationid="shibukawa.yoshiki" creationdate="20150502T095608Z">
        <seg>コンポーネントのネスト時には、いくつか技術的な制約があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a lot of different Javascript frameworks and evaluating their merits and shortcomings can be a daunting task.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015752Z" creationid="shibukawa.yoshiki" creationdate="20150417T015752Z">
        <seg>JavaScriptのフレームワーク同士で比較しても数多くの相違点があります。それぞれのフレームワークのメリット、欠点を評価するのは骨の折れる仕事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many similar conventions and libraries that help organize application styles nowadays.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T153003Z" creationid="shibukawa.yoshiki" creationdate="20170220T153003Z">
        <seg>現在は、アプリケーションのスタイルを整えるのに利用できる規約やライブラリがたくさんあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many ways to setup a bundler tool, but most are distributed via NPM. In fact, most modern Javascript libraries and tools are distributed that way, including Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071154Z" creationid="shibukawa.yoshiki" creationdate="20170207T071134Z">
        <seg>バンドラーツールのセットアップ方法はたくさんありますが、一番使われている方法はnpmでしょう。Mithrilも含めて、現代的なJavaScriptのライブラリとツールはnpm経由で配布されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some important semantic caveats for &lt;c0&gt;m.redraw.strategy("none")&lt;/c0&gt; that you should be aware of: Setting the strategy to &lt;c1&gt;"none"&lt;/c1&gt; only affects &lt;s2&gt;synchronous&lt;/s2&gt; redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150506Z" creationid="shibukawa.yoshiki" creationdate="20150416T150411Z">
        <seg>注意すべきこととしては、&lt;c0&gt;m.redraw.strategy("none")&lt;/c0&gt; で戦略を&lt;c1&gt;"none"&lt;/c1&gt;に設定しても、そのフレームで&lt;s2&gt;同期的に行われる&lt;/s2&gt;再描画にしか効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three general strategies that can be used to implement a SPA routing system, and each has different caveats:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092432Z" creationid="shibukawa.yoshiki" creationdate="20170207T092432Z">
        <seg>SPAのラウティングシステムを実装するのに使える戦略は、一般的に3種類あります。それぞれ違った特性を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to render a component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071629Z" creationid="shibukawa.yoshiki" creationdate="20150502T071629Z">
        <seg>コンポーネントを表示する方法は3通りあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two static methods: &lt;c1&gt;list&lt;/c1&gt; for retrieving a list of contacts, and &lt;c2&gt;save&lt;/c2&gt; to save a single contact.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224217Z" creationid="shibukawa.yoshiki" creationdate="20150501T224217Z">
        <seg>これらには、データのリストを取得する&lt;c1&gt;list&lt;/c1&gt;メソッドと、単体の連絡先を取得する&lt;c2&gt;save&lt;/c2&gt;メソッドという2つの静的メソッドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are, however, some limitations to the diff algorithm that require you to add &lt;a0&gt;key attributes&lt;/a0&gt; in some edge cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020315Z" creationid="shibukawa.yoshiki" creationdate="20150416T020315Z">
        <seg>しかし、いくつかの特殊なケースをうまく処理するために、差分検知アルゴリズムに&lt;a0&gt;key属性&lt;/a0&gt;を渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also &lt;a1&gt;Extended example&lt;/a1&gt; available on jsfiddle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T045719Z" creationid="shibukawa.yoshiki" creationdate="20160423T045719Z">
        <seg>これらに関する&lt;a1&gt;拡張済みのサンプル&lt;/a1&gt;もjsFiddleで提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a number of ways to improve Mithril performance for the rare cases where pages are too complex for their own good.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142320Z" creationid="shibukawa.yoshiki" creationdate="20150412T142320Z">
        <seg>ページがその機能を実装するために複雑すぎる状況になっているという状況は稀ですが、その場合にMithrilのパフォーマンスを改善する方法はいくつｋもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a tool called &lt;a0&gt;MSX by Jonathan Buchanan&lt;/a0&gt; that allows you to write templates using HTML syntax, and then automatically compile them to Javascript when files change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013750Z" creationid="shibukawa.yoshiki" creationdate="20150417T013750Z">
        <seg>&lt;a0&gt; Jonathan Buchananが作成したMSX&lt;/a0&gt; というツールがあります。これを使うとHTMLの文法を使ったテンプレートが作成できます。ファイルを変更すると自動でJavaScriptにコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a type definition file that you can use to add Mithril support to Typescript</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014314Z" creationid="shibukawa.yoshiki" creationdate="20150417T014314Z">
        <seg>TypeScriptにMithrilサポートを追加する型定義ファイルもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also an upcoming &lt;a2&gt;Web API&lt;/a2&gt; and a &lt;a3&gt;polyfill&lt;/a3&gt; if you like living on the bleeding edge.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T105001Z" creationid="shibukawa.yoshiki" creationdate="20170206T105001Z">
        <seg>また、最先端のものが好きであれば、これから登場する&lt;a2&gt;Web API&lt;/a2&gt;とその&lt;a3&gt;polyfill&lt;/a3&gt;もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's just one caveat: while simply initializing multiple "islands" in this fashion works, their initialization calls are not aware of each other and can cause redraws too frequently.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141104Z" creationid="shibukawa.yoshiki" creationdate="20150412T140926Z">
        <seg>１つだけ注意すべきことがあるとしたら、単純にこれら複数の「島」を初期化してしまった時に、それぞれの初期化呼び出しがお互いを認識せずに、再描画処理が想定上に発生してしまう、ということを避けなければならない、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no idiomatic way to organize jQuery code in an MVC pattern and many frameworks were created specifically to overcome that shortcoming.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015357Z" creationid="shibukawa.yoshiki" creationdate="20150420T015357Z">
        <seg>MVCパターンをjQueryを使って実現するための共通の書き方といったものは存在しません。そのため、この足りないところを補うために数多くのフレームワークが作られました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no need for a parse-and-compile pre-processing step to turn strings containing HTML + templating syntax into working DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013833Z" creationid="shibukawa.yoshiki" creationdate="20150409T013833Z">
        <seg>HTMLまじりの複雑な文字列を表示前に自前にパースしてコンパイルして、実際に表示されるDOM要素にするという大掛かりな仕事が必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, &lt;c1&gt;User.list&lt;/c1&gt; is still an empty array, and thus this view would render a blank page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T144811Z" creationid="shibukawa.yoshiki" creationdate="20170220T144811Z">
        <seg>そのため、&lt;c1&gt;User.list&lt;/c1&gt;は空の配列のままです。ビューをレンダリングしても何も表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, using the computation methods is recommended in order to reduce the amount of intermediate redraws that would otherwise occur as multiple asynchronous services are resolved.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115205Z" creationid="shibukawa.yoshiki" creationdate="20150502T115205Z">
        <seg>そのため、複数の非同期アクセスが完了する前に再描画が即座に行われないようにするために、computationメソッドを使うほうが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you should ensure that templates have null checks in place to account for the possibility of variables being uninitialized when the forced redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130153Z" creationid="shibukawa.yoshiki" creationdate="20150502T130153Z">
        <seg>そのため、強制再描画時に、未初期化の変数アクセスが発生しないようにテンプレートでのnullチェックを確実に行うようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you should not use &lt;c1&gt;config&lt;/c1&gt; to modify controller and model values, if you expect these changes to render immediately.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125028Z" creationid="shibukawa.yoshiki" creationdate="20150413T125028Z">
        <seg>このため、コントローラやモデルの値など、すぐにレンダリングに反映したい変更をするのに&lt;c1&gt;config&lt;/c1&gt;を使うのは適しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components are designed to not interface with other components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014356Z" creationid="shibukawa.yoshiki" creationdate="20150502T014356Z">
        <seg>これらのコンポーネントはお互いのコンポーネントとやりとりをするようには設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions are internally called by Mithril when you initialize a component via &lt;a4&gt;&lt;c5&gt;m.mount&lt;/c5&gt;&lt;/a4&gt; or &lt;a6&gt;&lt;c7&gt;m.route&lt;/c7&gt;&lt;/a6&gt;, and when you trigger event handlers that were created within templates with &lt;a8&gt;&lt;c9&gt;m()&lt;/c9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125801Z" creationid="shibukawa.yoshiki" creationdate="20150502T125801Z">
        <seg>これらの関数は、&lt;a4&gt;&lt;c5&gt;m.mount&lt;/c5&gt;&lt;/a4&gt;や&lt;a6&gt;&lt;c7&gt;m.route&lt;/c7&gt;&lt;/a6&gt;を通じてコンポーネントを初期化したり、&lt;a8&gt;&lt;c9&gt;m()&lt;/c9&gt;&lt;/a8&gt;を使って作られたテンプレート内のイベントハンドラを起動したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These hooks allow you to unwrap different parts of the response data depending on whether it succeed or failed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174508Z" creationid="shibukawa.yoshiki" creationdate="20150410T174508Z">
        <seg>これらのフックを使うと、レスポンスが成功したかどうかによって、レスポンスデータの違う箇所をアンラップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are only intended to be used by people who are writing libraries that do things asynchronously, or when calling vanilla javascript asynchronous functions from template &lt;a2&gt;&lt;c3&gt;config&lt;/c3&gt;&lt;/a2&gt; functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153059Z" creationid="shibukawa.yoshiki" creationdate="20150416T153059Z">
        <seg>これらのメソッドは非同期のタスクを実行するライブラリを作成したり、素のJavaScriptの非同期関数をテンプレートの&lt;a2&gt;&lt;c3&gt;config&lt;/c3&gt;&lt;/a2&gt;関数から呼び出す人のみが使うことを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods assume that the AJAX responses return contacts in JSON format, containing the same fields as the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000018Z" creationid="shibukawa.yoshiki" creationdate="20150502T000018Z">
        <seg>このlistメソッドは、AJAXのレスポンスとして、クラスと同じ名前のフィールドを含むJSON形式で連絡先情報を返してくることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two functions are here to illustrate the ability to expose APIs to component consumers that complement the component's user interface.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T032643Z" creationid="shibukawa.yoshiki" creationdate="20150502T032643Z">
        <seg>これらの2つの関数は、コンポーネント利用者にAPIを公開することで、コンポーネントのインタフェースを補完できることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They allow developers to encapsulate functionality into reusable units.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061224Z" creationid="shibukawa.yoshiki" creationdate="20150502T061224Z">
        <seg>コンポーネントの仕組みに従うってコーディングすると、再利用可能な、カプセル化された部品を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are considered anti-patterns and have a number of problematic edge cases, so they no longer exist in v1.x.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121550Z" creationid="shibukawa.yoshiki" creationdate="20170131T121550Z">
        <seg>これらの関数はさまざまなエッジケースの問題を発生させてきたため、アンチパターンと判断されました。v1.xからは除外されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be initialized and used like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150835Z" creationid="shibukawa.yoshiki" creationdate="20150407T150835Z">
        <seg>これらのクラスは次のように初期化して使います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They do this because once the element is ready (and thus, has an accessible &lt;c1&gt;innerHTML&lt;/c1&gt; property), their rendering engines cannot backtrack to the parsing-stage if the script calls something like &lt;c2&gt;document.write("&lt;/body&gt;")&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014356Z" creationid="shibukawa.yoshiki" creationdate="20150416T014356Z">
        <seg>一度HTMLエレメントの読み込みが完了して、 &lt;c1&gt;innerHTML&lt;/c1&gt; プロパティにアクセス可能になった後は、スクリプトが&lt;c2&gt;document.write("&lt;/body&gt;")&lt;/c2&gt;といった関数呼び出しをしたとしても、パースの段階に戻ることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They now use the standardized lifecycle hook &lt;c1&gt;onremove&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045109Z" creationid="shibukawa.yoshiki" creationdate="20170201T045109Z">
        <seg>標準化されたライフサイクルフックの&lt;c1&gt;onremove&lt;/c1&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Things that would be useful to have (though likely not as part of Mithril core)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143426Z" creationid="shibukawa.yoshiki" creationdate="20160412T143426Z">
        <seg>Mithrilのコアとしてではないかもしれないが、あると便利だと思われるもの</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third-party promise library support</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133735Z" creationid="shibukawa.yoshiki" creationdate="20150414T133735Z">
        <seg>サードパーティのPromiseライブラリのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;c1&gt;if&lt;/c1&gt; statement is important, because this function may be called multiple times by Mithril's auto-redrawing system and we don't want to re-initialize select2 at every redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133941Z" creationid="shibukawa.yoshiki" creationdate="20150412T133941Z">
        <seg>この関数はMithrilの自動再描画システムから何度も呼び出されますし、描画のたびに何度もselect2を初期化するのはうれしくないため、この&lt;c1&gt;if&lt;/c1&gt;文は大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API also allows access to push notifications and background synchronization features.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034120Z" creationid="shibukawa.yoshiki" creationdate="20170220T034120Z">
        <seg>このAPIを使うと、Push通知にアクセスしたり、バックグラウンドのデータの同期などが行えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API is still available in &lt;c2&gt;v1.x&lt;/c2&gt;, and additionally any route params are passed as properties in the &lt;c3&gt;attrs&lt;/c3&gt; object on the vnode.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T143252Z" creationid="shibukawa.yoshiki" creationdate="20170131T143252Z">
        <seg>このAPIは&lt;c2&gt;v1.x&lt;/c2&gt;でも利用可能ですが、これに加えて、ラウトパラメータはVノードの&lt;c3&gt;attrs&lt;/c3&gt;プロパティを通じて取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API returns a list of users from the &lt;c2&gt;GET http://rem-rest-api.herokuapp.com/api/users&lt;/c2&gt; endpoint.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T060438Z" creationid="shibukawa.yoshiki" creationdate="20170220T060438Z">
        <seg>このAPIを使って&lt;c2&gt;GET http://rem-rest-api.herokuapp.com/api/users&lt;/c2&gt;エンドポイントにアクセスすると、ユーザーのリストが返ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows getter-setters to be passed directly as parameters to &lt;a0&gt;&lt;c1&gt;m.request&lt;/c1&gt;&lt;/a0&gt;, for example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135657Z" creationid="shibukawa.yoshiki" creationdate="20150414T135657Z">
        <seg>これにより、getter-setterはそのまま&lt;a0&gt;&lt;c1&gt;m.request&lt;/c1&gt;&lt;/a0&gt;などのパラメータとして渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows named anchors (i.e. &lt;c1&gt;&lt;a href="#top"&gt;Back to top&lt;/a&gt;&lt;/c1&gt;, &lt;c2&gt;&lt;a name="top"&gt;&lt;/a&gt;&lt;/c2&gt;) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for &lt;c3&gt;history.pushState&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005103Z" creationid="shibukawa.yoshiki" creationdate="20150410T005103Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、&lt;c1&gt;&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;&lt;/c1&gt;、&lt;c2&gt;&lt;a name="top"&gt;&lt;/a&gt;&lt;/c2&gt;)を使うことができますが、IE8の場合は&lt;c3&gt;history.pushState&lt;/c3&gt;のサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows named anchors (i.e. &lt;c2&gt;&lt;a href="#top"&gt;Back to top&lt;/a&gt;&lt;/c2&gt;, &lt;c3&gt;&lt;a name="top"&gt;&lt;/a&gt;&lt;/c3&gt;) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for &lt;c4&gt;history.pushState&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165955Z" creationid="shibukawa.yoshiki" creationdate="20150414T165955Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、&lt;c2&gt;&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;&lt;/c2&gt;、&lt;c3&gt;&lt;a name="top"&gt;&lt;/a&gt;&lt;/c3&gt;)を使うことができますが、IE8の場合は&lt;c4&gt;history.pushState&lt;/c4&gt;のサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows swapping the implementation of the &lt;c0&gt;saveContact&lt;/c0&gt; handler without changing the &lt;c1&gt;ContactForm&lt;/c1&gt; component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031718Z" creationid="shibukawa.yoshiki" creationdate="20150502T031718Z">
        <seg>これにより、&lt;c1&gt;ContactForm&lt;/c1&gt;コンポーネントを変更することなく、&lt;c0&gt;saveContact&lt;/c0&gt;ハンドラの実装を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the developer to abstract away any aspect of the template at will.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002827Z" creationid="shibukawa.yoshiki" creationdate="20150413T002827Z">
        <seg>これによって開発者から見てテンプレートに対してあらゆる抽象化が行えるようなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows us to maintain input focus and plugin state correctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141807Z" creationid="shibukawa.yoshiki" creationdate="20150413T141807Z">
        <seg>これを使うと、入力のフォーカスや、プラグインの状態を正しく維持することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to implement optimizations that avoid creating virtual DOM trees in favor of their cached counterparts, if you know they have not changed between redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123810Z" creationid="shibukawa.yoshiki" creationdate="20150416T123810Z">
        <seg>もし再描画間で差分が発生していないことが明示的にわかっている場合は、キャッシュと対になる仮想DOMツリーの生成の手間が省けるため、処理を最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also applies for asynchronous functions called from 3rd party libraries or from vanilla javascript, if they call this pair of functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154704Z" creationid="shibukawa.yoshiki" creationdate="20150416T154704Z">
        <seg>サードパーティのライブラリや、ネイティブJavaScriptのコードから非同期関数を使う時も、これらの関数のペアを呼ぶ場合は同じルールが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach means that developers can get discoverable codebases without necessarily getting locked into the framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144943Z" creationid="shibukawa.yoshiki" creationdate="20150417T144943Z">
        <seg>これにより、開発者はフレームワークにロックインされることなく、オープンなコードベースを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This architecture can yield highly flexible and reusable code, but flexibility can also increase the cognitive load of the system (for example, you need to look at both the top-level module and &lt;c0&gt;ContactList&lt;/c0&gt; in order to know what is the data being displayed (and how it's being filtered, etc).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142157Z" creationid="shibukawa.yoshiki" creationdate="20150502T012919Z">
        <seg>このアーキテクチャにすることで、高い柔軟性と再利用性の高いコードが得られますが、柔軟性が高いということはシステムを理解する負荷が高まるということです。どのようにデータが表示されるかを知るには、トップレベルのモジュールと、&lt;c0&gt;ContactList&lt;/c0&gt;の2つを見る必要があります。場合によってはどのようにフィルタされるかを知る必要もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can be changed either via the &lt;a0&gt;retain flag in a config's context object&lt;/a0&gt;, or the &lt;a1&gt;&lt;c2&gt;m.redraw.strategy("diff")&lt;/c2&gt; hint&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140605Z" creationid="shibukawa.yoshiki" creationdate="20160101T140605Z">
        <seg>この動作は、&lt;a0&gt;configのコンテキストオブジェクトのretainフラグ&lt;/a0&gt;、もしくは&lt;a1&gt;&lt;c2&gt;m.redraw.strategy("diff")&lt;/c2&gt;ヒント&lt;/a1&gt;を使って変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior complicated usage of &lt;c1&gt;m.redraw()&lt;/c1&gt; and caused some hard-to-reason about issues and has been removed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121343Z" creationid="shibukawa.yoshiki" creationdate="20170131T121343Z">
        <seg>この&lt;c1&gt;m.redraw()&lt;/c1&gt;メソッドを使った時の挙動は難しく、追跡が難しい問題を引き起こすことがあったので削除されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This binds the &lt;c0&gt;description&lt;/c0&gt; getter-setter to the text input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014947Z" creationid="shibukawa.yoshiki" creationdate="20150408T014947Z">
        <seg>このコードにより、&lt;c0&gt;description&lt;/c0&gt; getter-setterとテキスト入力が接続されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be done by simply calling &lt;c0&gt;m.startComputation&lt;/c0&gt; at the beginning, and &lt;c1&gt;m.endComputation&lt;/c1&gt; at the end of the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134514Z" creationid="shibukawa.yoshiki" creationdate="20150412T134514Z">
        <seg>統合するには関数の先頭で&lt;c0&gt;m.startComputation&lt;/c0&gt;を呼び、関数の最後で&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can get noticeably bulky when you look at thing like collections: you often need to implement insertion code and deletion code, in addition to a "draw everything" routine for performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014351Z" creationid="shibukawa.yoshiki" creationdate="20150420T014351Z">
        <seg>「すべてを描画する」ルーチンに加えて、パフォーマンスを向上させるために、部品を追加する、削除するといったコードの実装が必要で、コード量がとても大きくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This comes with several benefits (proper error reporting, proper lexical scoping, etc.), while still allowing &lt;a0&gt;HTML syntax to be used via a preprocessor tool&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041323Z" creationid="shibukawa.yoshiki" creationdate="20150502T041323Z">
        <seg>このことには、エラー発生時のメッセージが分かりやすいとか、適切なレキシカルスコープが使えるなどのさまざまな利点があります。また、&lt;a0&gt;HTML文法を使うことができるプリプロセッサツール&lt;/a0&gt;も利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convention is designed to take maximum advantage of screen real estate, and makes it easier to scan the CSS selectors (since they are always on the left side) and their logical grouping, and it enforces predictable and uniform placement of CSS rules for each selector.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T050153Z" creationid="shibukawa.yoshiki" creationdate="20170221T050153Z">
        <seg>この表記法は、スクリーンサイズの横幅を最大限に活かすルールになっています。CSSセレクターを探す時は、論理的なグループで整列されて並んでいますし、予測可能で均一化されているため、簡単に要素を探すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This cost might be less of a concern in single page apps, but not necessarily if the app is typically opened simultaneously in multiple tabs, or run on less powerful devices.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113548Z" creationid="shibukawa.yoshiki" creationdate="20150417T113548Z">
        <seg>このコストは、シングルページアプリケーションでは影響は小さくなりますが、複数タブで同時に開かれたり、性能の低いデバイスで実行される場合はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates a dynamic route that matches any URL that starts with &lt;c1&gt;/edit/&lt;/c1&gt; and is followed by some data (e.g. &lt;c2&gt;/edit/1&lt;/c2&gt;, &lt;c3&gt;edit/234&lt;/c3&gt;, etc).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053926Z" creationid="shibukawa.yoshiki" creationdate="20170208T053926Z">
        <seg>この記法を使うと、&lt;c1&gt;/edit/&lt;/c1&gt;から始まり、何らかのデータがその後に続く動的なラウトを定義できます。例えば、&lt;c2&gt;/edit/1&lt;/c2&gt;, &lt;c3&gt;edit/234&lt;/c3&gt;といったパスにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates a new function with the parameter already set.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151345Z" creationid="shibukawa.yoshiki" creationdate="20150408T151345Z">
        <seg>このメソッドを使うと、パラメータがあらかじめ設定された、新しい関数を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates an array of vnodes that represents a list of &lt;c2&gt;div&lt;/c2&gt;s, each containing the name of a user.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T144642Z" creationid="shibukawa.yoshiki" creationdate="20170220T144642Z">
        <seg>このコードはユーザー名を含む&lt;c2&gt;div&lt;/c2&gt;のリストを表す、vnodeの配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design decision comes from experience with &lt;a0&gt;DRY&lt;/a0&gt; and the &lt;a1&gt;"bus factor"&lt;/a1&gt; of large, highly relational model layers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032507Z" creationid="shibukawa.yoshiki" creationdate="20150421T014921Z">
        <seg>このデザインの原則は&lt;a0&gt;DRY&lt;/a0&gt;と、リレーショナルモデル層の&lt;a1&gt;トラックナンバー&lt;/a1&gt;の大きさから来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deviation from the spec is there to make it easier for developers to find common logical errors such as typos that lead to null reference exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172449Z" creationid="shibukawa.yoshiki" creationdate="20150415T172340Z">
        <seg>仕様と異なるこの動作により、タイプミスによるnull参照例外などの一般的なエラーを開発者が簡単に見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This endpoint returns an object with the same &lt;c3&gt;count&lt;/c3&gt; value that was sent to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T151120Z" creationid="shibukawa.yoshiki" creationdate="20170204T151120Z">
        <seg>このエンドポイントは、送信したときと同じ&lt;c3&gt;count&lt;/c3&gt;値のオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that data being accessed in the view isn't nullable as a result of asynchronous data not being available yet.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235932Z" creationid="shibukawa.yoshiki" creationdate="20150414T235932Z">
        <seg>この仕組により、ビューが非同期データのデータにアクセスするときも、データがまだ利用できないために表示がおかしくなる、ということがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This event handler is fired whenever there's a progress update in the XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T003714Z" creationid="shibukawa.yoshiki" creationdate="20170220T003714Z">
        <seg>このイベントハンドラは、XMLHttpRequestの進捗が更新されると呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example is also available as a &lt;a0&gt;jsFiddle&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163514Z" creationid="shibukawa.yoshiki" creationdate="20150408T163514Z">
        <seg>このサンプルは、&lt;a0&gt;jsFiddle&lt;/a0&gt;でも確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This file will contain a skeleton project meta-description file.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071514Z" creationid="shibukawa.yoshiki" creationdate="20170207T071514Z">
        <seg>このファイルは、プロジェクトのメタ説明の雛形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This flag is false the first time it runs on an element, and true on redraws that happen after the element has been created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155231Z" creationid="shibukawa.yoshiki" creationdate="20150413T155231Z">
        <seg>そのエレメントに対して初めて実行される時はこのフラグがfalseに設定され、エレメントの作成後に再描画が発生してそこから呼ばれる時はtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function initializes the &lt;c2&gt;vm&lt;/c2&gt; object with three members: &lt;c3&gt;list&lt;/c3&gt;, which is simply an array, &lt;c4&gt;description&lt;/c4&gt;, which is an &lt;c5&gt;m.prop&lt;/c5&gt; getter-setter function with an empty string as the initial value, and &lt;c6&gt;add&lt;/c6&gt;, which is a method that adds a new Todo instance to &lt;c7&gt;list&lt;/c7&gt; if an input description getter-setter is not an empty string.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113954Z" creationid="shibukawa.yoshiki" creationdate="20150407T162621Z">
        <seg>このコードは、3つのメンバーを持つ&lt;c2&gt;vm&lt;/c2&gt;オブジェクトを初期化しています。単純な配列の&lt;c3&gt;list&lt;/c3&gt;、初期値の文字列として空の文字列を渡された&lt;c5&gt;m.prop&lt;/c5&gt;のgetter-setter関数である&lt;c4&gt;description&lt;/c4&gt;、入力のdescription getter-setterが空の文字列でないときに、新しいTodoインスタンスを&lt;c7&gt;list&lt;/c7&gt;に登録する&lt;c6&gt;add&lt;/c6&gt;関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function overwrites the reference to the &lt;c0&gt;window&lt;/c0&gt; object that is used internally by Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160616Z" creationid="shibukawa.yoshiki" creationdate="20150416T160616Z">
        <seg>この関数を使うと、Mithril内部で使われる&lt;c0&gt;window&lt;/c0&gt;オブジェクトを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will be called with the value of the defined property as an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140918Z" creationid="shibukawa.yoshiki" creationdate="20150414T140918Z">
        <seg>この関数は引数として定義されたプロパティの値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This handler method can be assigned to properties like &lt;c0&gt;onclick&lt;/c0&gt;, or passed as callbacks to &lt;c1&gt;addEventListener&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T141043Z" creationid="shibukawa.yoshiki" creationdate="20150414T141043Z">
        <seg>このハンドラメソッドは、&lt;c0&gt;onclick&lt;/c0&gt;などのプロパティに設定したり、&lt;c1&gt;addEventListener&lt;/c1&gt;にコールバックとして渡すことができるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the benefit of cleaner syntax for writing static text, but it comes with the disadvantage of features getting awkwardly tied to HTML syntax, as well as providing poor debugging support.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025712Z" creationid="shibukawa.yoshiki" creationdate="20150420T025712Z">
        <seg>この方式は静的なテキストを作成するのは書きやすいというメリットがありますが、HTMLの文法を密結合してしまっている欠点がありますし、デバッグもしやすいとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the side-effect of triggering the &lt;c3&gt;onupdate&lt;/c3&gt; hook, rather than &lt;c4&gt;oninit&lt;/c4&gt;/&lt;c5&gt;oncreate&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T054815Z" creationid="shibukawa.yoshiki" creationdate="20170208T054815Z">
        <seg>これの副作用として、このケースでは&lt;c4&gt;oninit&lt;/c4&gt;/&lt;c5&gt;oncreate&lt;/c5&gt;のフックは呼ばれず、&lt;c3&gt;onupdate&lt;/c3&gt;フックだけが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This idiom can also be used to attach &lt;c2&gt;onprogress&lt;/c2&gt; event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182339Z" creationid="shibukawa.yoshiki" creationdate="20150414T182339Z">
        <seg>この方法は、&lt;c2&gt;onprogress&lt;/c2&gt;を付与するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a convenience method to compose virtual elements that can be rendered via &lt;a0&gt;&lt;c1&gt;m.render()&lt;/c1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235212Z" creationid="shibukawa.yoshiki" creationdate="20150412T235212Z">
        <seg>この関数は仮想DOM要素を組み立てるための簡単なインタフェースを提供する関数です。この仮想DOM要素は&lt;a0&gt;&lt;c1&gt;m.render()&lt;/c1&gt;&lt;/a0&gt;メソッドを使ってレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a form of &lt;e2&gt;lazy evaluation&lt;/e2&gt;: it allows us to say "use this value later, when the event handler gets called".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151857Z" creationid="shibukawa.yoshiki" creationdate="20150408T151857Z">
        <seg>このような形式を&lt;e2&gt;遅延評価(lazy evaluation)&lt;/e2&gt;と呼びます。これを使うと、「イベントハンドラが呼ばれて、本当に必要になったタイミングまで値の取得を遅らせよう」ということができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a general good practice when working with Promises, which allows us to register more callbacks to run after the completion of the XHR request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121017Z" creationid="shibukawa.yoshiki" creationdate="20170220T121017Z">
        <seg>これはPromiseを使うときによく使われる良い習慣です。これにより、XHRのリクエストが完了した後に呼ばれるコールバックを追加で登録できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a getter-setter factory utility.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133832Z" creationid="shibukawa.yoshiki" creationdate="20150414T133832Z">
        <seg>この関数は、getter-setterのファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a high-level utility for working with web services, which allows writing asynchronous code relatively procedurally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174738Z" creationid="shibukawa.yoshiki" creationdate="20150414T174738Z">
        <seg>この関数はウェブサービスと協調するための高度なユーティリティです。この機能を使うと、非同期で動作するコードを、比較的手続き的に記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a low-level method in Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015830Z" creationid="shibukawa.yoshiki" creationdate="20150415T015830Z">
        <seg>これは、Mithrilの低レベルメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a problem particularly for frameworks that had breaking changes in the past: It's common to find answers in StackOverflow that are out-of-date and no longer work with the latest version of said frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114247Z" creationid="shibukawa.yoshiki" creationdate="20150417T114247Z">
        <seg>これは特に、過去の大きな変更があると問題になります。StackOverflowで見つけた解答が最新版のフレームワークでは動作しないということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a route parameter; you can think of it as a wild card; the route &lt;c1&gt;/edit/1&lt;/c1&gt; would resolve to &lt;c2&gt;UserForm&lt;/c2&gt; with an &lt;c3&gt;id&lt;/c3&gt; of &lt;c4&gt;"1"&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120442Z" creationid="shibukawa.yoshiki" creationdate="20170221T120442Z">
        <seg>これはラウトパラメータです。これは一種のワイルドカードでと考えることができます。&lt;c1&gt;/edit/1&lt;/c1&gt;というURLがあると、&lt;c3&gt;id&lt;/c3&gt;に&lt;c4&gt;"1"&lt;/c4&gt;が代入され、&lt;c2&gt;UserForm&lt;/c2&gt;が解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also what happens when components are used directly without a RouteResolver.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T074429Z" creationid="shibukawa.yoshiki" creationdate="20170208T074429Z">
        <seg>これは、ラウトリゾルバーを使わず、コンポーネントを直接使っていても起きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an event handler factory.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140138Z" creationid="shibukawa.yoshiki" creationdate="20150414T140138Z">
        <seg>この関数はイベントハンドラを生成するファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an important difference and a common pitfall for developers new to javascript: calling the function immediately means that the XHR request will fire as soon as the source code is evaluated, even if the component never renders.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T150904Z" creationid="shibukawa.yoshiki" creationdate="20170220T150904Z">
        <seg>これは重大な違いであり、JavaScript初心者が陥りやすい落とし穴です。その場で関数を呼び出すと、コンポーネントがレンダリングされるかどうかに関わらず、ソースコードの評価後にすぐにXHRのリクエストが行われてしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is good for framework adoption, but not necessarily ideal for team scalability and codebase discoverability.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020356Z" creationid="shibukawa.yoshiki" creationdate="20150420T020356Z">
        <seg>これはフレームワーク適用の柔軟性を高める点では悪くないのですが、開発チームのスケーラビリティやコードベースの探索のしやすさの点で理想的とはいえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is how the code is right now:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120858Z" creationid="shibukawa.yoshiki" creationdate="20170221T120858Z">
        <seg>追加した後のコードは次の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is in stark contrast to the ActiveRecord pattern of other frameworks, where model entities are largely object representations of database entities and these entities are manipulated in controllers in an ad-hoc field-by-field fashion, and then "committed" via a &lt;c0&gt;save&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032841Z" creationid="shibukawa.yoshiki" creationdate="20150421T032841Z">
        <seg>これは、他のフレームワークのActiveRecordパターンと大きく異なっています。ActiveRecordパターンのモデルエンティティは、データベースのエンティティのオブジェクト表現という側面が強く、アドホックにコントローラ内でフィード操作されて、最後に&lt;c0&gt;save&lt;/c0&gt;メソッドでコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known, appropriately, as the &lt;a2&gt;observer pattern&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025130Z" creationid="shibukawa.yoshiki" creationdate="20150502T025130Z">
        <seg>これは&lt;a2&gt;オブザーバパターン&lt;/a2&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is perfectly valid: there are three asynchronous computations pending after the &lt;c4&gt;jQuery.when&lt;/c4&gt; method is called, and therefore, three pairs of &lt;c5&gt;m.startComputation&lt;/c5&gt; / &lt;c6&gt;m.endComputation&lt;/c6&gt; in play.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010103Z" creationid="shibukawa.yoshiki" creationdate="20150412T010103Z">
        <seg>このコードは完璧に正しいコードです。&lt;c4&gt;jQuery.when&lt;/c4&gt;が呼ばれた後に、そこから3組の&lt;c5&gt;m.startComputation&lt;/c5&gt; / &lt;c6&gt;m.endComputation&lt;/c6&gt;呼び出しがあるため、3つの非同期描画が遅延されて、バッチ処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default for going from one route to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143321Z" creationid="shibukawa.yoshiki" creationdate="20150416T143321Z">
        <seg>この動作はラウト間の遷移時のデフォルトの動作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the most potentially expensive method in Mithril and should not be used at a rate faster than the rate at which the native &lt;c0&gt;requestAnimationFrame&lt;/c0&gt; method fires (i.e. the rate at which browsers are comfortable calling recurring rendering-intensive code).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020309Z" creationid="shibukawa.yoshiki" creationdate="20150421T020309Z">
        <seg>m.redrawは、Mithrilの中でもっとも重い処理になりえる関数です。ネイティブの&lt;c0&gt;requestAnimationFrame&lt;/c0&gt;メソッドが起動されるよりも早いペースで呼び出すべきではありません。このメソッドは、レンダリングに関するコードを実行するのに、ブラウザにとって一番快適なインターバルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the recommended way for views and models to exchange data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062126Z" creationid="shibukawa.yoshiki" creationdate="20150502T062126Z">
        <seg>これがMithrilの推奨する、ビューとモデルのデータの交換方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the value of the defined DOM element's property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140943Z" creationid="shibukawa.yoshiki" creationdate="20150414T140943Z">
        <seg>これは定義されたDOMエレメントの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is to make the method compatible with virtual DOM elements' &lt;c0&gt;config&lt;/c0&gt; attribute (see &lt;a1&gt;&lt;c2&gt;m()&lt;/c2&gt;&lt;/a1&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172538Z" creationid="shibukawa.yoshiki" creationdate="20150414T172538Z">
        <seg>これは、仮想DOMエレメント&lt;c0&gt;config&lt;/c0&gt;属性に対して、メソッドの互換性を維持するために使用します。&lt;a1&gt;&lt;c2&gt;m()&lt;/c2&gt;&lt;/a1&gt;を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for re-running ajax calls for different model entities.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085524Z" creationid="shibukawa.yoshiki" creationdate="20150502T085524Z">
        <seg>これは違うモデルエンティティに対してAJAX呼び出しを再実行した場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful if there are cleanup tasks that need to be run when an element is destroyed (e.g. clearing &lt;c0&gt;setTimeout&lt;/c0&gt;'s, etc)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130429Z" creationid="shibukawa.yoshiki" creationdate="20150413T130429Z">
        <seg>エレメントが破棄されるときに、なんらかの後片付けのタスクを実行したい時にはこの機能は便利です。例えば、&lt;c0&gt;setTimeout&lt;/c0&gt;を辞めるといったタスクがあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when a &lt;c1&gt;config&lt;/c1&gt; instantiates 3rd party classes and accesses the instance on redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125737Z" creationid="shibukawa.yoshiki" creationdate="20150413T125737Z">
        <seg>&lt;c1&gt;config&lt;/c1&gt;のコールバックがサードパーティのクラスのインスタンスを作成したり、再描画時にそのインスタンスにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when the relevant data is either in a response header or the status field.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013414Z" creationid="shibukawa.yoshiki" creationdate="20150415T013414Z">
        <seg>このオプションはレスポンスヘッダやステータスフィールドに必要なデータがある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when using the &lt;c0&gt;background&lt;/c0&gt; option, in order to avoid the need for null checks in views that may be attempting to access the returned getter-setter before the asynchronous request resolves.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012521Z" creationid="shibukawa.yoshiki" creationdate="20150415T012521Z">
        <seg>&lt;c0&gt;background&lt;/c0&gt;オプションを使用するときにこのオプションを使用すると、リクエスト完了前にビューがgetter-setterにアクセスするときにnullチェックを行う手間が減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when we want to control access to certain properties in an object, as opposed to exposing all the fields in POJOs (plain old Javascript objects) for arbitrary processing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170524Z" creationid="shibukawa.yoshiki" creationdate="20150410T170524Z">
        <seg>POJO(plain old JavaScript objects)の場合はすべてのフィールドが公開状態になってしまうため、この機能を使うとオブジェクト内のプロパティへのアクセス方法をコントロールしやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful, for example, if you declare a &lt;c0&gt;canvas&lt;/c0&gt; element and want to use the Javascript API to draw:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123454Z" creationid="shibukawa.yoshiki" creationdate="20150413T123454Z">
        <seg>この機能は、例えば&lt;c0&gt;canvas&lt;/c0&gt;エレメントを作り、JavaScriptの描画APIを使って絵を描く場合などに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful, for example, if you received invalid JSON from the server in production and you want to display a message to the user saying that the server is offline.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181246Z" creationid="shibukawa.yoshiki" creationdate="20150414T181246Z">
        <seg>もしJSONとしては不正なレスポンスをプロダクション環境のサーバから受け取ったとして、ユーザに対してサーバがオフラインであるというメッセージを表示したいとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This key-value map should define a list of HTML attributes and their respective values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153433Z" creationid="shibukawa.yoshiki" creationdate="20150413T153433Z">
        <seg>キー・バリューのマップはHTML属性とその値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to reason about the state of the UI and to test it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183527Z" creationid="shibukawa.yoshiki" creationdate="20150411T183527Z">
        <seg>これにより、UIの状態や状態のテストが簡単に行えるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the href behave correctly regardless of which &lt;c0&gt;m.route.mode&lt;/c0&gt; is selected.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013416Z" creationid="shibukawa.yoshiki" creationdate="20150410T013416Z">
        <seg>この書き方を使用すると、どの&lt;c0&gt;m.route.mode&lt;/c0&gt;が選択されていたとしても、期待通りの実行結果が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means it's possible for a view to attempt to use data before it is available.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001641Z" creationid="shibukawa.yoshiki" creationdate="20150415T001641Z">
        <seg>このオプションを有効にすると、データが利用可能になる前にビューがデータにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means redraws do not occur after event changes and &lt;c1&gt;m.request&lt;/c1&gt; calls for templates that were rendered via &lt;c2&gt;m.render&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T132203Z" creationid="shibukawa.yoshiki" creationdate="20170206T132203Z">
        <seg>&lt;c2&gt;m.render&lt;/c2&gt;を使ってレンダリングされたテンプレートに対しては、イベントの変更や&lt;c1&gt;m.request&lt;/c1&gt;の呼び出しでは再描画は行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that compiled templates don't need to parse the string in &lt;c2&gt;m("div#foo")&lt;/c2&gt; and they don't incur the cost of the function call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144404Z" creationid="shibukawa.yoshiki" creationdate="20150412T144404Z">
        <seg>コンパイルされたテンプレートを使用する時は、&lt;c2&gt;m("div#foo")&lt;/c2&gt;といった文字列をパースする必要がなく、関数呼び出しのコストは発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that in the code below, the input on screen will overwritten by the model data any time a redraw happens:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015206Z" creationid="shibukawa.yoshiki" creationdate="20150413T015206Z">
        <seg>これはつまり、下記のサンプルのスクリーン上のテキスト入力の値は、モデルデータが変更されるたびに上書きされることを意味しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that just as you are able to bind the &lt;c0&gt;value&lt;/c0&gt; attribute in an &lt;c1&gt;&lt;select&gt;&lt;/c1&gt;, you are also able to bind the &lt;c2&gt;selectedIndex&lt;/c2&gt; property, if needed for whatever reason.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021929Z" creationid="shibukawa.yoshiki" creationdate="20150408T021929Z">
        <seg>&lt;c1&gt;&lt;select&gt;&lt;/c1&gt;タグであれば、&lt;c0&gt;value&lt;/c0&gt;属性と結びつけることもできますし、用途によっては&lt;c2&gt;selectedIndex&lt;/c2&gt;プロパティとバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the &lt;a0&gt;vnode&lt;/a0&gt; that is created for the root component of the route has a route parameter object &lt;c1&gt;key&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055315Z" creationid="shibukawa.yoshiki" creationdate="20170208T055315Z">
        <seg>このコードは、ルートのコンポーネントが、ラウトパラメータオブジェクトとして&lt;c1&gt;key&lt;/c1&gt;属性を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the virtual dom tree may take two or more redraws (depending on how many nested asynchronous components there are) to be fully rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093904Z" creationid="shibukawa.yoshiki" creationdate="20150502T093904Z">
        <seg>これによって非同期のネストされたコンポーネントの数次第で、完全なレンダリングが行われるまでに、何度か仮想DOMツリーの再描画処理が走る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that typing something on the input and then re-rendering will clobber the text on screen.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015937Z" creationid="shibukawa.yoshiki" creationdate="20150408T015937Z">
        <seg>これは、何かしらのテキストを入力して、再レンダリングが実行されると、スクリーン上のテキストが破棄されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that we are avoiding the creation of the header subtree (and therefore skipping the diff algorithm) altogether, but it also means that dynamic variables will NOT be updated within the header.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124500Z" creationid="shibukawa.yoshiki" creationdate="20150416T124500Z">
        <seg>こうすると、ヘッダーに関するサブツリーが作られなくなり、差分アルゴリズムもスキップしますが、ヘッダ内の動的な変数が更新されることもなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that when the component initializes, User.loadList will be called, triggering an XHR request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T145124Z" creationid="shibukawa.yoshiki" creationdate="20170220T145124Z">
        <seg>このコードは、コンポーネントの初期化時に、XHRのリクエストを行うUser.loadListが呼ばれることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means, for example, that when using fast-firing events like &lt;c0&gt;onresize&lt;/c0&gt; or &lt;c1&gt;onscroll&lt;/c1&gt;, Mithril will automatically throttle the number of redraws to avoid lag.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133013Z" creationid="shibukawa.yoshiki" creationdate="20170206T133013Z">
        <seg>&lt;c0&gt;onresize&lt;/c0&gt;や&lt;c1&gt;onscroll&lt;/c1&gt;などの高頻度イベントを使って再描画を指示した場合にも、Mithrilは再描画の頻度を調整し、ラグを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism allows multiple components to be reloaded in response to non-idempotent operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021537Z" creationid="shibukawa.yoshiki" creationdate="20150502T021537Z">
        <seg>この仕組みを使うと、状態を変更させるような操作に対して複数のコンポーネントをリロードさせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is only intended to be used as a last resort optimization tool.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124016Z" creationid="shibukawa.yoshiki" creationdate="20150416T124016Z">
        <seg>この機能は、パフォーマンスの最適化のための最終手段として用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is useful to clear timers and unsubscribe event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T015902Z" creationid="shibukawa.yoshiki" creationdate="20150414T015902Z">
        <seg>タイマーをクリアしたり、イベントハンドラをunsubscribeする場合に、この仕組みが便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method accepts two callbacks which process a value passed to the &lt;c0&gt;resolve&lt;/c0&gt; and &lt;c1&gt;reject&lt;/c1&gt; methods, respectively, and pass the processed value to the returned promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175631Z" creationid="shibukawa.yoshiki" creationdate="20150415T175631Z">
        <seg>このメソッドは、&lt;c0&gt;resolve&lt;/c0&gt;、&lt;c1&gt;reject&lt;/c1&gt;メソッドに渡される値を受け取り、結果のpromiseに格納される値を処理して返す2つのコールバックを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method also allows you to asynchronously define what component will be rendered, making it suitable for code splitting and asynchronous module loading.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085434Z" creationid="shibukawa.yoshiki" creationdate="20170207T085434Z">
        <seg>このメソッドを使うと、どのコンポーネントをレンダリングすべきかを非同期に決めることができます。コードを分割して非同期のモジュールのロードを行うときに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method always returns the value of the internal store, regardless of whether it was updated or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140011Z" creationid="shibukawa.yoshiki" creationdate="20150414T140011Z">
        <seg>このメソッドは、値が更新されたかどうかにかかわらず、常に内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method flags a string as trusted HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013558Z" creationid="shibukawa.yoshiki" creationdate="20150416T013558Z">
        <seg>このメソッドは文字列に対して信用できるHTMLであるとフラグを立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method generates a DOM tree inside of a given HTML element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015955Z" creationid="shibukawa.yoshiki" creationdate="20150416T015955Z">
        <seg>このメソッドは、DOMツリーを指定されたHTML属性内に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method gets called every time an exception is thrown inside a promise callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180257Z" creationid="shibukawa.yoshiki" creationdate="20150415T180257Z">
        <seg>このメソッドはpromiseコールバックの中で例外が発生するたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is meant to be used in conjunction with an &lt;c0&gt;&lt;a&gt;&lt;/c0&gt; &lt;a1&gt;vnode&lt;/a1&gt;'s &lt;a2&gt;&lt;c3&gt;oncreate&lt;/c3&gt; hook&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T084112Z" creationid="shibukawa.yoshiki" creationdate="20170207T084112Z">
        <seg>このメソッドは&lt;c0&gt;&lt;a&gt;&lt;/c0&gt;タグと&lt;a1&gt;vnode&lt;/a1&gt;の&lt;a2&gt;&lt;c3&gt;oncreate&lt;/c3&gt;フック&lt;/a2&gt;を結びつけるときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is meant to be used with a virtual element's &lt;c0&gt;config&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013226Z" creationid="shibukawa.yoshiki" creationdate="20150410T013226Z">
        <seg>このメソッドを使うには、 &lt;c0&gt;config&lt;/c0&gt;仮想エレメントのプロパティを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is provided to decouple the browser's event model from the controller/logic model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140435Z" creationid="shibukawa.yoshiki" creationdate="20150414T140435Z">
        <seg>このメソッドは、ブラウザのイベントモデルと、コントローラ/ロジックモデルを疎結合にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method overloads four different units of functionality:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152555Z" creationid="shibukawa.yoshiki" creationdate="20150414T152555Z">
        <seg>このメソッドは4つの異なる機能をオーバーロードしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method passes a value to the &lt;c0&gt;errorCallback&lt;/c0&gt; of the deferred object's child promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180158Z" creationid="shibukawa.yoshiki" creationdate="20150415T180154Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseの&lt;c0&gt;errorCallback&lt;/c0&gt;に値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method passes a value to the &lt;c0&gt;successCallback&lt;/c0&gt; of the deferred object's child promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180143Z" creationid="shibukawa.yoshiki" creationdate="20150415T180143Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseの&lt;c0&gt;successCallback&lt;/c0&gt;に値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method takes a list of promises and returns a promise that resolves when all promises in the input list have resolved.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180614Z" creationid="shibukawa.yoshiki" creationdate="20150415T180533Z">
        <seg>このメソッドはリストに入ったpromiseを受け取り、すべてのpromiseが果たされた時に解決するpromiseを解決します。￥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is provided for &lt;c1&gt;XMLHttpRequest&lt;/c1&gt; compatibility, but you should avoid using it because it sends the password in plain text over the network.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T065943Z" creationid="shibukawa.yoshiki" creationdate="20170219T065943Z">
        <seg>このオプションは&lt;c1&gt;XMLHttpRequest&lt;/c1&gt;との互換性のために用意されていますが、このメソッドはパスワードをプレーンテキスト形式で送付してしまうため、避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is useful for running operations in the background (i.e. without user intervention).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T011826Z" creationid="shibukawa.yoshiki" creationdate="20150415T011826Z">
        <seg>この操作は、ユーザの操作によらず行われるバックグラウンドの操作を実行する場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is useful for web services that use uncommon conventions for defining jsonp callbacks (e.g. foo.com/?jsonpCallback=doSomething)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014719Z" creationid="shibukawa.yoshiki" creationdate="20150415T014719Z">
        <seg>foo.com/?jsonpCallback=doSomethingなど、一般的な規約とはことなるjsonpコールバック定義をさせるウェブサービスを章するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional compilation tool is merely "icing on the cake" that speeds up the Javascript run-time of templates (which is already fast, even without compilation - see the &lt;a0&gt;performance section on the homepage&lt;/a0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144842Z" creationid="shibukawa.yoshiki" creationdate="20150412T144842Z">
        <seg>Mithirilは &lt;a0&gt;トップページのパフォーマンスのセクション&lt;/a0&gt;で既にお見せしているように、コンパイルなどしなくてもすでに高速です。このオプションのコンパイルツールは、いわば「ケーキの上のデコレーション」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page aims to provide a comparison between Mithril and some of the most widely used frameworks, as well as some of the younger, but relevant ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015911Z" creationid="shibukawa.yoshiki" creationdate="20150417T015911Z">
        <seg>このページではMithrilと他のよく使われるフレームワークの違いについて説明します。中には関連しているが、まだまだ若いものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern is useful to decouple chains of dependencies (however care should be taken to avoid "come-from hell", i.e. difficulty in following a chains of events because they are too numerous and arbitrarily inter-dependent)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025524Z" creationid="shibukawa.yoshiki" creationdate="20150502T025524Z">
        <seg>このパターンは依存関係の鎖を分離するのに役立ちます。しかし、数多くの内部依存関係を持つことによって、イベントの連鎖を追いかけるのが難しくなる「地獄からやってくる」ケースに陥らないように注意する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This redirects to the URL &lt;c0&gt;http://server/#/dashboard/johndoe&lt;/c0&gt; and yields:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003359Z" creationid="shibukawa.yoshiki" creationdate="20150410T003359Z">
        <seg>これを実行すると、&lt;c0&gt;http://server/#/dashboard/johndoe&lt;/c0&gt;にリダイレクトして、下記のタグを挿入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rendering technique is known as &lt;e1&gt;virtual DOM diffing&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072607Z" creationid="shibukawa.yoshiki" creationdate="20150502T072604Z">
        <seg>このレンダリング技術は&lt;e1&gt;仮想DOMの差分検知&lt;/e1&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This renders the following markup:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013720Z" creationid="shibukawa.yoshiki" creationdate="20150408T013720Z">
        <seg>このメソッド呼び出しをすると、次のようなマークアップが生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This retrieves an array of objects from the server asynchronously.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143556Z" creationid="shibukawa.yoshiki" creationdate="20170219T143556Z">
        <seg>この関数は非同期でサーバーからオブジェクトの配列を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This returns the portion of the URL determined by &lt;c1&gt;m.route.mode&lt;/c1&gt; (minus the &lt;c2&gt;?&lt;/c2&gt; or &lt;c3&gt;#&lt;/c3&gt; symbols for the &lt;c4&gt;search&lt;/c4&gt; and &lt;c5&gt;hash&lt;/c5&gt; modes, respectively).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172128Z" creationid="shibukawa.yoshiki" creationdate="20150414T172128Z">
        <seg>この関数は、&lt;c1&gt;m.route.mode&lt;/c1&gt;で決定されるURLのパーツ(マイナス&lt;c2&gt;?&lt;/c2&gt;もしくは&lt;c3&gt;#&lt;/c3&gt;シンボル - それぞれ&lt;c4&gt;search&lt;/c4&gt;モードと&lt;c5&gt;hash&lt;/c5&gt; モード時)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This route would be selected if the URL was &lt;c2&gt;/path/to/page/1&lt;/c2&gt;, &lt;c3&gt;/path/to/page/test&lt;/c3&gt;, etc</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160207Z" creationid="shibukawa.yoshiki" creationdate="20150414T160207Z">
        <seg>このラウとは、&lt;c2&gt;/path/to/page/1&lt;/c2&gt;、&lt;c3&gt;/path/to/page/test&lt;/c3&gt;といったURLが指定された場合に選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be either &lt;c0&gt;window&lt;/c0&gt; or a mock of the &lt;c1&gt;window&lt;/c1&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161447Z" creationid="shibukawa.yoshiki" creationdate="20150416T161447Z">
        <seg>この引数は&lt;c0&gt;window&lt;/c0&gt;もしくはモック&lt;c1&gt;window&lt;/c1&gt;オブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be enough to get you started writing the frontend for a real application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T153236Z" creationid="shibukawa.yoshiki" creationdate="20170204T153236Z">
        <seg>これらの内容は、本物のアプリケーションのフロントエンドを書き始めるには十分でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This simple model exposes two members: &lt;c0&gt;User.list&lt;/c0&gt; (an array of user objects), and &lt;c1&gt;User.loadList&lt;/c1&gt; (a method that populates &lt;c2&gt;User.list&lt;/c2&gt; with server data).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T121135Z" creationid="shibukawa.yoshiki" creationdate="20170220T121135Z">
        <seg>このシンプルなモデルは2つのメンバーを公開しています。&lt;c0&gt;User.list&lt;/c0&gt;（ユーザーオブジェクトの配列）と、&lt;c1&gt;User.loadList&lt;/c1&gt;（サーバーのデータを使って&lt;c2&gt;User.list&lt;/c2&gt;を初期化する）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This special parameter allows you to call methods on the DOM element after it gets created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123355Z" creationid="shibukawa.yoshiki" creationdate="20150413T123355Z">
        <seg>この特別なパラメータを使うと、DOMエレメントの精製後にその要素に対してメソッドが呼べるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state object becomes available in the &lt;c3&gt;history.state&lt;/c3&gt; property, and is merged into the &lt;a4&gt;routing parameters&lt;/a4&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T082131Z" creationid="shibukawa.yoshiki" creationdate="20170207T082131Z">
        <seg>このstateオブジェクトは&lt;c3&gt;history.state&lt;/c3&gt;プロパティを通じてアクセスできます。プロパティは&lt;a4&gt;ラウトパラメータ&lt;/a4&gt;オブジェクトにマージされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124319Z" creationid="shibukawa.yoshiki" creationdate="20150410T124319Z">
        <seg>このステップはコントローラレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is meant to be done in the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123925Z" creationid="shibukawa.yoshiki" creationdate="20150410T123925Z">
        <seg>このステップはモデルレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step isn't required in order to use Mithril, but it's an easy way to squeeze a little bit more performance out of an application, without the need for code changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143904Z" creationid="shibukawa.yoshiki" creationdate="20150412T143904Z">
        <seg>このステップはMithrilを使う上で必須のものではありませんが、コードを一切変更せずにアプリケーション外で簡単にパフォーマンスを少し向上させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This string should be a CSS rule that represents a DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150546Z" creationid="shibukawa.yoshiki" creationdate="20150413T150546Z">
        <seg>DOMエレメントを表現するCSSルールの文字列を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax allows you to bind intermediate results before piping them down for further processing, for example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020233Z" creationid="shibukawa.yoshiki" creationdate="20150410T020233Z">
        <seg>この文法を使うと、パイプ処理が次の処理を起動する前に中間結果を束縛することができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique can improve the user experience of large forms and other apps where non-persisted state is laborious for a user to produce.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064407Z" creationid="shibukawa.yoshiki" creationdate="20170208T064407Z">
        <seg>このテクニックはユーザー体験を大きく改善することができます。ユーザーが入力した内容を消去してしまうアプリケーションはユーザーに面倒さを与えてしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tool is also available as a &lt;a0&gt;Rails gem&lt;/a0&gt;, created by Jordan Humphreys.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014137Z" creationid="shibukawa.yoshiki" creationdate="20150417T014137Z">
        <seg>このツールは、 Jordan Humphreysが作成した&lt;a0&gt;Rails gem&lt;/a0&gt;でも提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This utility provides a number of useful features out of the box:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140832Z" creationid="shibukawa.yoshiki" creationdate="20160101T140832Z">
        <seg>提供されるこの便利な機能には次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value can be programmatically changed in controllers and event handlers to modify the next redrawing strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152459Z" creationid="shibukawa.yoshiki" creationdate="20150416T152459Z">
        <seg>この値は、コントローラとイベントハンドラの中で設定することができます。これは次に行われるの再描画の戦略にのみ作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value should be one of the following: &lt;c0&gt;GET&lt;/c0&gt;, &lt;c1&gt;POST&lt;/c1&gt;, &lt;c2&gt;PUT&lt;/c2&gt;, &lt;c3&gt;PATCH&lt;/c3&gt;, &lt;c4&gt;DELETE&lt;/c4&gt;, &lt;c5&gt;HEAD&lt;/c5&gt; or &lt;c6&gt;OPTIONS&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T063256Z" creationid="shibukawa.yoshiki" creationdate="20170219T063256Z">
        <seg>このオプションは、&lt;c0&gt;GET&lt;/c0&gt;, &lt;c1&gt;POST&lt;/c1&gt;, &lt;c2&gt;PUT&lt;/c2&gt;, &lt;c3&gt;PATCH&lt;/c3&gt;, &lt;c4&gt;DELETE&lt;/c4&gt;, &lt;c5&gt;HEAD&lt;/c5&gt;, &lt;c6&gt;OPTIONS&lt;/c6&gt;のどれかでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, if the user searches and presses the back button to return to the application, the input will still be populated with the search term.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064232Z" creationid="shibukawa.yoshiki" creationdate="20170208T064232Z">
        <seg>これにより、ユーザーが検索してから戻るボタンをおしてアプリケーションに戻ったときに、検索用語が入力フォームに入ったまま、というのが実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will allow the compiler to type-check calls to the Mithril API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014405Z" creationid="shibukawa.yoshiki" creationdate="20150417T014405Z">
        <seg>コンパイラがMithril API呼び出しに対して型チェックが行えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will provide all the polyfills required for the browser.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014706Z" creationid="shibukawa.yoshiki" creationdate="20150417T014706Z">
        <seg>このライブラリはブラウザで必要とされるすべての足りない機能を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, if your architecture requires manual control over when rendering occurs (as can sometimes be the case when using libraries like Redux), you should use &lt;c3&gt;m.render&lt;/c3&gt; instead of &lt;c4&gt;m.mount&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T132558Z" creationid="shibukawa.yoshiki" creationdate="20170206T132558Z">
        <seg>そのため、Reduxのようなライブラリを使っている場合など、アーキテクチャの都合上、描画の制御をマニュアルで行う必要があれば、&lt;c4&gt;m.mount&lt;/c4&gt;の代わりに&lt;c3&gt;m.render&lt;/c3&gt;を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, when jumping from one page to another, the &lt;c3&gt;key&lt;/c3&gt; changes and causes the component to be recreated from scratch (since the key tells the virtual dom engine that old and new components are different entities).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055608Z" creationid="shibukawa.yoshiki" creationdate="20170208T055534Z">
        <seg>この時、あるページから他のページに遷移すると、&lt;c3&gt;key&lt;/c3&gt;が変更されます。この属性の違いから、仮想DOMエンジンは、既存のコンポーネントと新しいコンポーネントの内容がまったく異なると判断し、既存のコンポーネントを破棄して新コンポーネントを再作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve that, it's possible to combine route parameterization with the virtual dom &lt;a0&gt;key reconciliation&lt;/a0&gt; feature:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055144Z" creationid="shibukawa.yoshiki" creationdate="20170208T055038Z">
        <seg>これらの両方のニーズを満たすために、ラウトのパラメータ化と仮想DOMの&lt;a0&gt;key称号&lt;/a0&gt;機能を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To activate the component, we use &lt;c0&gt;m.mount&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030629Z" creationid="shibukawa.yoshiki" creationdate="20170131T030629Z">
        <seg>コンポーネントをアクティベート化するには&lt;c0&gt;m.mount()&lt;/c0&gt;関数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To add styles, let's first create a file called &lt;c0&gt;styles.css&lt;/c0&gt; and include it in the &lt;c1&gt;index.html&lt;/c1&gt; file:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T045612Z" creationid="shibukawa.yoshiki" creationdate="20170221T045612Z">
        <seg>スタイルを追加したら、&lt;c0&gt;styles.css&lt;/c0&gt;を作成し、&lt;c1&gt;index.html&lt;/c1&gt;にリンクを追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid surprises, be sure to change only attribute values, using &lt;c1&gt;undefined&lt;/c1&gt; or &lt;c2&gt;null&lt;/c2&gt; as values if appropriate, rather than conditionally substituting attribute dictionaries altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144324Z" creationid="shibukawa.yoshiki" creationdate="20150413T144324Z">
        <seg>想定外の事態を避けるには、&lt;c1&gt;undefined&lt;/c1&gt;や&lt;c2&gt;null&lt;/c2&gt;を使って属性の値だけを変更するようにしてください。条件によって属性の辞書そのものを置き換えるコードは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To clarify the difference between the two examples, example 1 is equivalent to this code:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T073401Z" creationid="shibukawa.yoshiki" creationdate="20170208T073401Z">
        <seg>これらのサンプルの違いを明確にするために、例 1と同じコードを作成してみます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To communicate with a server, we can use Mithril's XHR utility, &lt;c0&gt;m.request&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055437Z" creationid="shibukawa.yoshiki" creationdate="20170220T055437Z">
        <seg>サーバーとコミュニケーションするには、MithrilのXHRユーティリティである &lt;c0&gt;m.request&lt;/c0&gt;が使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective &lt;a0&gt;components&lt;/a0&gt; to be rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135028Z" creationid="shibukawa.yoshiki" creationdate="20150502T135028Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするための&lt;a0&gt;コンポーネント&lt;/a0&gt;のキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective &lt;a0&gt;modules&lt;/a0&gt; to be rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002722Z" creationid="shibukawa.yoshiki" creationdate="20150409T162838Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするための&lt;a0&gt;モジュール&lt;/a0&gt;のキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To download NPM, &lt;a0&gt;install Node.js&lt;/a0&gt;; NPM is installed automatically with it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T071316Z" creationid="shibukawa.yoshiki" creationdate="20170207T071316Z">
        <seg>npmをインストールする場合は、 &lt;a0&gt;Node.jsをインストール&lt;/a0&gt;しましょう。npmはNode.jsと一緒にインストールされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help with consistency in &lt;c2&gt;v1.x&lt;/c2&gt; they must always be wrapped with a &lt;c3&gt;m()&lt;/c3&gt; invocation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T135924Z" creationid="shibukawa.yoshiki" creationdate="20170131T135924Z">
        <seg>&lt;c2&gt;v1.x&lt;/c2&gt;では一貫性のために、&lt;c3&gt;m()&lt;/c3&gt;呼び出しでラップする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate the difference between Mithril and A+ promises, consider the code below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140322Z" creationid="shibukawa.yoshiki" creationdate="20150415T140310Z">
        <seg>下記のコードを使用して、MithrilとA+ promisesの違いを紹介します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To implement flow control in Mithril views, we simply use Javascript Array methods:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152856Z" creationid="shibukawa.yoshiki" creationdate="20150408T152849Z">
        <seg>JavaScriptの配列のメソッドを使うだけで、Mithrilのビューでフローコントロールを実装することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install Mithril, follow the instructions in the &lt;a0&gt;installation&lt;/a0&gt; page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T055234Z" creationid="shibukawa.yoshiki" creationdate="20170220T055234Z">
        <seg>Mithrilをインストールするには、&lt;a0&gt;インストール&lt;/a0&gt;ページの解説に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install it, go to its website and use the installer provided.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150117Z" creationid="shibukawa.yoshiki" creationdate="20150412T150117Z">
        <seg>NodeJSをインストールするには、NodeJSのウェブサイトに行き、提供されているインストーラを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install mithril-objectify, NodeJS provides a command-line package manager tool.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T141532Z" creationid="shibukawa.yoshiki" creationdate="20160101T141532Z">
        <seg>mithril-objectifyをインストールするのに使うコマンドラインのパッケージマネージャは、NodeJSが提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To integrate synchronous code, call &lt;c0&gt;m.startComputation&lt;/c0&gt; at the beginning of the method, and &lt;c1&gt;m.endComputation&lt;/c1&gt; at the end.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193105Z" creationid="shibukawa.yoshiki" creationdate="20150411T193105Z">
        <seg>同期処理のコードと統合する場合は、メソッドの先頭で&lt;c0&gt;m.startComputation&lt;/c0&gt;を呼んで、最後に&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To keep this tutorial simple, we'll just use plain CSS with overly explicit class names, so that the styles themselves provide the atomicity of Tachyons, and class name collisions are made unlikely through the verbosity of the class names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T042133Z" creationid="shibukawa.yoshiki" creationdate="20170221T042133Z">
        <seg>チュートリアルでは単純に済ませるために、大げさなぐらい明示的なクラス名を使っています。クラス名自身がTachyonsが提供するようなアトミック性を持っているため、クラス名の衝突は起きないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To maintain the identities of DOM elements, you need to add a &lt;c0&gt;key&lt;/c0&gt; property to the direct children of the array that you're planning to modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142044Z" creationid="shibukawa.yoshiki" creationdate="20150413T142044Z">
        <seg>DOM要素の識別子を維持するには、変更したい配列の子供に、&lt;c0&gt;key&lt;/c0&gt;プロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make JSON-P requests, add the &lt;c0&gt;dataType&lt;/c0&gt; option instead of &lt;c1&gt;method&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234822Z" creationid="shibukawa.yoshiki" creationdate="20150414T234756Z">
        <seg>JSONPリクエストを行うには、&lt;c1&gt;method&lt;/c1&gt;ではなく、&lt;c0&gt;dataType&lt;/c0&gt;を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To optimize rendering, you should add a &lt;c0&gt;m.startComputation&lt;/c0&gt; call before the first widget initialization call, and a &lt;c1&gt;m.endComputation&lt;/c1&gt; after the last widget initialization call in each execution thread.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141303Z" creationid="shibukawa.yoshiki" creationdate="20150412T141303Z">
        <seg>レンダリングを初期化するには、それぞれの実行スレッドの中で、最初のウィジェットの初期化の前に&lt;c0&gt;m.startComputation&lt;/c0&gt;を呼び出し、最後のウィジェットの初期化の後に&lt;c1&gt;m.endComputation&lt;/c1&gt;を呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To override that behavior, define a custom &lt;c0&gt;options.deserialize&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004652Z" creationid="shibukawa.yoshiki" creationdate="20170220T004652Z">
        <seg>この動作を変更するには、カスタムの&lt;c0&gt;options.deserialize&lt;/c0&gt;関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To override the default JSON request type, set &lt;c0&gt;options.headers&lt;/c0&gt; to an object of key-value pairs corresponding to request header names and values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T005654Z" creationid="shibukawa.yoshiki" creationdate="20170220T005654Z">
        <seg>デフォルトではJSONをリクエストしますが、これを上書きするには&lt;c0&gt;options.headers&lt;/c0&gt;にリクエストヘッダーの名前と値が含まれているオブジェクトを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent unloading when attempting to navigate away from a page, you can check the return value of &lt;c1&gt;m.mount&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092352Z" creationid="shibukawa.yoshiki" creationdate="20150502T092352Z">
        <seg>他のページに遷移しようとしたときに、アンロードが中断されたかどうかを知るには、&lt;c1&gt;m.mount&lt;/c1&gt;の返り値をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To render a component asynchronously return a promise that resolves to a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T085613Z" creationid="shibukawa.yoshiki" creationdate="20170207T085613Z">
        <seg>コンポーネントのレンダリングを非同期に行う時は、解決時にコンポーネントが格納されるPromiseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To render a string as HTML, see &lt;a0&gt;&lt;c1&gt;m.trust&lt;/c1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155543Z" creationid="shibukawa.yoshiki" creationdate="20150413T155543Z">
        <seg>文字列をHTMLとしてレンダリングしたい場合は、&lt;a0&gt;&lt;c1&gt;m.trust&lt;/c1&gt;&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To retrieve data from the server without causing side-effects on the server, we need to use the &lt;c2&gt;GET&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T061009Z" creationid="shibukawa.yoshiki" creationdate="20170220T061009Z">
        <seg>サーバーに副作用をあたえずにデータを取得するので、&lt;c2&gt;GET&lt;/c2&gt;メソッドを使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run the execution time tests below, click on their respective links, run the profiler from your desired browser's developer tools and measure the running time of a page refresh (Lower is better).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134936Z" creationid="shibukawa.yoshiki" creationdate="20150407T134936Z">
        <seg>下記の実行時間のテストを行う場合は、それぞれのリンクをクリックして、好きなブラウザの開発者ツールのプロファイラを起動してページリフレッシュの実行時間を計測してください(数値が少ないほうが良い)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run the tests for each framework, click on the respective links.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135234Z" creationid="shibukawa.yoshiki" creationdate="20150407T135234Z">
        <seg>各々のフレームワークのテストを実行する場合は、それぞれのリンクをクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand what that means, let's add some events:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030838Z" creationid="shibukawa.yoshiki" creationdate="20170131T030838Z">
        <seg>この意味を理解するために、イベントを追加してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To unload/unmount a component without loading another component, you can simply call &lt;c0&gt;m.mount&lt;/c0&gt; with a &lt;c1&gt;null&lt;/c1&gt; as the component parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T134258Z" creationid="shibukawa.yoshiki" creationdate="20160101T134258Z">
        <seg>他のコンポーネントをロードせずにコンポーネントをアンロード/アンマウントする場合は、コンポーネントの引数として&lt;c1&gt;null&lt;/c1&gt;を&lt;c0&gt;m.mount&lt;/c0&gt;に渡すと行えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To upload files, first you need to get a reference to a &lt;a0&gt;&lt;c1&gt;File&lt;/c1&gt;&lt;/a0&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155330Z" creationid="shibukawa.yoshiki" creationdate="20170219T155330Z">
        <seg>ファイルをアップロードする時はまず、&lt;a0&gt;&lt;c1&gt;File&lt;/c1&gt;&lt;/a0&gt;オブジェクトの参照を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To upload multiple files, simply append them all to the &lt;c0&gt;FormData&lt;/c0&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T190825Z" creationid="shibukawa.yoshiki" creationdate="20170219T190825Z">
        <seg>複数ファイルをアップロードするのは、&lt;c0&gt;FormData&lt;/c0&gt;オブジェクトに送信したいファイルをすべて登録するだけで行なえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the HTML5 FormData object as the payload for a request, you need to override the &lt;c0&gt;serialize&lt;/c0&gt; option.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175359Z" creationid="shibukawa.yoshiki" creationdate="20150414T175359Z">
        <seg>HTML5 FormDataをリクエストのペイロードとして使うには、&lt;c0&gt;serialize&lt;/c0&gt;をオーバーライドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the bleeding edge version from npm, use the following command:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000846Z" creationid="shibukawa.yoshiki" creationdate="20150408T000833Z">
        <seg>npmを使って最先端のバージョンをインストールするには、次のコマンドを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Todos are self-contained and their data aren't tied to the DOM like in typical jQuery based code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234340Z" creationid="shibukawa.yoshiki" creationdate="20150408T234340Z">
        <seg>Todoのコードは他のコードなどへの依存もなく、疎結合でまとまっています。jQueryベースのコードと違って、DOMと密結合していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tooling</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111908Z" creationid="shibukawa.yoshiki" creationdate="20170206T111908Z">
        <seg>ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tools - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013337Z" creationid="shibukawa.yoshiki" creationdate="20150417T013310Z">
        <seg>便利なツール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis generates new bundles before running tests</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054501Z" creationid="shibukawa.yoshiki" creationdate="20170220T054501Z">
        <seg>Travisはテスト実行前に新しいバンドルを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis lints files (but can't fail build)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054521Z" creationid="shibukawa.yoshiki" creationdate="20170220T054521Z">
        <seg>TravisがLintを実行（ただしビルドを失敗させません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis runs tests</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054507Z" creationid="shibukawa.yoshiki" creationdate="20170220T054507Z">
        <seg>Travisがテストを実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis sees new release, starts build</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054447Z" creationid="shibukawa.yoshiki" creationdate="20170220T054447Z">
        <seg>Travisが新しいリリースを見てビルドを開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis sees that this commit has a tag associated with it</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054707Z" creationid="shibukawa.yoshiki" creationdate="20170220T054644Z">
        <seg>Travisがこのコミットがタグに関連したものであることを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Travis will use the encrypted npm creds in &lt;c0&gt;.travis.yml&lt;/c0&gt; to publish a new version to npm</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054748Z" creationid="shibukawa.yoshiki" creationdate="20170220T054748Z">
        <seg>Travisが&lt;c0&gt;.travis.yml&lt;/c0&gt;内のnpmの暗号化クレデンシャルを使い、新しいバージョンをnpmに公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tree</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143332Z" creationid="shibukawa.yoshiki" creationdate="20160412T143332Z">
        <seg>ツリー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trusted HTML is allowed to render arbitrary, potentially invalid markup, as well as run arbitrary Javascript, and therefore the developer is responsible for either:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013853Z" creationid="shibukawa.yoshiki" creationdate="20150416T013728Z">
        <seg>信用されたHTMLは、そのままレンダリングされます。そのソースは不正なマークアップであったり、そのままJavaScriptとして実行されるものである場合もありますが、この次の項目の責任は開発者が負います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Turns an object into a string of form &lt;c0&gt;a=1&amp;b=2&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133107Z" creationid="shibukawa.yoshiki" creationdate="20170206T133107Z">
        <seg>オブジェクトを&lt;c0&gt;a=1&amp;b=2&lt;/c0&gt;という形式の文字列に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorial</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024652Z" creationid="shibukawa.yoshiki" creationdate="20170131T024652Z">
        <seg>チュートリアル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorials</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024559Z" creationid="shibukawa.yoshiki" creationdate="20170131T024559Z">
        <seg>チュートリアル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133120Z" creationid="shibukawa.yoshiki" creationdate="20170206T133120Z">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typescript Support</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014243Z" creationid="shibukawa.yoshiki" creationdate="20150417T014243Z">
        <seg>TypeScriptサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical usage</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100612Z" creationid="shibukawa.yoshiki" creationdate="20170207T100612Z">
        <seg>一般的な使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically &lt;c4&gt;resolve&lt;/c4&gt;/&lt;c5&gt;reject&lt;/c5&gt; are called asynchronously after the &lt;c6&gt;then&lt;/c6&gt; method is called, so normally this difference does not matter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140610Z" creationid="shibukawa.yoshiki" creationdate="20150415T140533Z">
        <seg>一般的には、&lt;c4&gt;resolve&lt;/c4&gt;/&lt;c5&gt;reject&lt;/c5&gt;は&lt;c6&gt;then&lt;/c6&gt;メソッドが呼ばれた後に非同期で呼ばれます。一般的にはこの差はそれほど大きな問題ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically this is required in three situations:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125458Z" creationid="shibukawa.yoshiki" creationdate="20150410T125447Z">
        <seg>一般的に、この機能は以下の3つの場面で必要となります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, &lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt; don't need to be called from application space.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152936Z" creationid="shibukawa.yoshiki" creationdate="20150416T152936Z">
        <seg>多くの場合、アプリケーション空間から&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;を呼ぶ必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, a component can load data upon initialization.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075942Z" creationid="shibukawa.yoshiki" creationdate="20170208T075942Z">
        <seg>通常はコンポーネントの初期化時にデータをロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, it's used in conjunction with &lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt; to implement data binding in the view-to-model direction.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140249Z" creationid="shibukawa.yoshiki" creationdate="20150414T140249Z">
        <seg>一般的に、この関数は&lt;a0&gt;&lt;c1&gt;m.prop&lt;/c1&gt;&lt;/a0&gt;と組み合わせて、ビューからモデル方向のデータバインディングを作成するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, model entities are reusable and live outside of components (e.g. &lt;c0&gt;var User = ...&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040711Z" creationid="shibukawa.yoshiki" creationdate="20150502T040711Z">
        <seg>モデルの実体は再利用可能なため、コンポーネントの外で定義されることが多いです (例: &lt;c0&gt;var User = ...&lt;/c0&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, this rate is around 60 calls per second.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020327Z" creationid="shibukawa.yoshiki" creationdate="20150421T020327Z">
        <seg>通常は一秒間に60回呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, when separating MVC layers, it's common that the namespace declaration be in the model layer, since this is usually the most used dependency for the other layers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015353Z" creationid="shibukawa.yoshiki" creationdate="20150421T015353Z">
        <seg>一般的に、MVCレイヤーを分割する場合は、モデルレイヤー内で名前空間を定義すべきです。モデルレイヤーは他の全てのレイヤーが依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you should not even be using inline styles to begin with (unless you are dynamically changing them).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013449Z" creationid="shibukawa.yoshiki" creationdate="20150413T013449Z">
        <seg>一般的に動的に値を変更する時以外は、インラインでのスタイル設定は使用すべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unchecked Error Handling</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141001Z" creationid="shibukawa.yoshiki" creationdate="20150415T141001Z">
        <seg>チェックしていないエラーのハンドリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike some frameworks, Mithril tries very hard to avoid locking you into a web of dependencies: you can use as &lt;e0&gt;little&lt;/e0&gt; of the framework as you need.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142104Z" creationid="shibukawa.yoshiki" creationdate="20150407T142104Z">
        <seg>他のフレームワークと異なり、Mithrilはクモの巣のような依存関係にとらわれないようにするために多大な努力を払っています。フレームワーク内の&lt;e0&gt;必要な部分&lt;/e0&gt;だけを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unloading components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050641Z" creationid="shibukawa.yoshiki" creationdate="20150502T050641Z">
        <seg>コンポーネントのアンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unloading/Unmounting components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T134534Z" creationid="shibukawa.yoshiki" creationdate="20160101T134534Z">
        <seg>コンポーネントのアンロード/アンマウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the promise is resolved, the value of the prop will resolve to &lt;c0&gt;undefined&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135403Z" creationid="shibukawa.yoshiki" creationdate="20150414T135403Z">
        <seg>promiseが解決されるまでは、propの値は&lt;c0&gt;undefined&lt;/c0&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unwrapping Response Data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170850Z" creationid="shibukawa.yoshiki" creationdate="20150410T170850Z">
        <seg>レスポンスデータの展開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating &lt;c0&gt;docs/change-log.md&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054816Z" creationid="shibukawa.yoshiki" creationdate="20170220T054816Z">
        <seg>&lt;c0&gt;docs/change-log.md&lt;/c0&gt;を更新する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the value of the description in the model updates the DOM input when Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015040Z" creationid="shibukawa.yoshiki" creationdate="20150408T015040Z">
        <seg>モデルの中のdescriptionの値を更新すると、Mithirlが再描画を行ってDOMのテキスト入力を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154314Z" creationid="shibukawa.yoshiki" creationdate="20150412T154314Z">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage of keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020816Z" creationid="shibukawa.yoshiki" creationdate="20150421T020816Z">
        <seg>キーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage of m.redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015757Z" creationid="shibukawa.yoshiki" creationdate="20150421T015757Z">
        <seg>m.redrawの使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;a0&gt;&lt;c1&gt;m.mount()&lt;/c1&gt;&lt;/a0&gt; or &lt;a2&gt;&lt;c3&gt;m.route()&lt;/c3&gt;&lt;/a2&gt; to activate a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130004Z" creationid="shibukawa.yoshiki" creationdate="20150502T130004Z">
        <seg>コンポーネントのアクティベートには、&lt;a0&gt;&lt;c1&gt;m.mount()&lt;/c1&gt;&lt;/a0&gt;か、&lt;a2&gt;&lt;c3&gt;m.route()&lt;/c3&gt;&lt;/a2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c2&gt;Promise.all&lt;/c2&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T050219Z" creationid="shibukawa.yoshiki" creationdate="20170201T050219Z">
        <seg>&lt;c2&gt;Promise.all&lt;/c2&gt;を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this strategy if you want cleaner-looking URLs and do not need to support IE9.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T095106Z" creationid="shibukawa.yoshiki" creationdate="20170207T095036Z">
        <seg>この戦略はIE9のサポートが必要でなく、なおかつURLの見た目をきれいにしたいときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this strategy if you want to support IE9.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T094541Z" creationid="shibukawa.yoshiki" creationdate="20170207T094541Z">
        <seg>もしIE9をサポートしたいのであればこの戦略を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this strategy if you want to support anchored links and you are not able to make the server-side necessary to support the pathname strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T094816Z" creationid="shibukawa.yoshiki" creationdate="20170207T094816Z">
        <seg>この戦略はアンカーを使ったリンクを使用したいが、サーバー側の都合でパス名戦略が使用できないときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful Tools</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141024Z" creationid="shibukawa.yoshiki" creationdate="20150407T141024Z">
        <seg>便利なツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful for adding request headers and when using XHR2 features, such as the XMLHttpRequest's &lt;c2&gt;upload&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014152Z" creationid="shibukawa.yoshiki" creationdate="20150415T014152Z">
        <seg>この関数を使うと、リクエストヘッダを追加したり、XMLHttpRequestの&lt;c2&gt;upload&lt;/c2&gt;プロパティなどXHR2の機能を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful for reading response headers and cookies.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T074536Z" creationid="shibukawa.yoshiki" creationdate="20170219T074536Z">
        <seg>レスポンスヘッダーやクッキーを読み込んでレスポンスに加えたいときに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Different Data Transfer Formats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174826Z" creationid="shibukawa.yoshiki" creationdate="20150410T174826Z">
        <seg>異なるデータ転送フォーマットを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using HTML entities</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160200Z" creationid="shibukawa.yoshiki" creationdate="20150412T160200Z">
        <seg>HTMLエンティティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using JSON-P</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234820Z" creationid="shibukawa.yoshiki" creationdate="20150414T174700Z">
        <seg>JSONPの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using bleeding edge from NPM</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000758Z" creationid="shibukawa.yoshiki" creationdate="20150408T000758Z">
        <seg>NPMで最先端のバージョンを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;a0&gt;fragment identifier&lt;/a0&gt; (aka the hash) portion of the URL.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092618Z" creationid="shibukawa.yoshiki" creationdate="20170207T092618Z">
        <seg>URLの&lt;a0&gt;フラグメント識別子&lt;/a0&gt;（別名：ハッシュ）部分を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the hash strategy is guaranteed to work in browsers that don't support &lt;c0&gt;history.pushState&lt;/c0&gt; (namely, Internet Explorer 9), because it can fall back to using &lt;c1&gt;onhashchange&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T094511Z" creationid="shibukawa.yoshiki" creationdate="20170207T094511Z">
        <seg>ハッシュ戦略を使うと、&lt;c0&gt;history.pushState&lt;/c0&gt;をサポートしていないブラウザ（名前を挙げるとならInternet Explorer 9）でも&lt;c1&gt;onhashchange&lt;/c1&gt;にフォールバックするため使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the pathname.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T093803Z" creationid="shibukawa.yoshiki" creationdate="20170207T093803Z">
        <seg>パス名の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the querystring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T093623Z" creationid="shibukawa.yoshiki" creationdate="20170207T093623Z">
        <seg>クエリー文字列の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this API, it's possible to programmatically change the URL displayed by the browser after a page has loaded, but it's the application developer's responsibility to ensure that navigating to any given URL from a cold state (e.g. a new tab) will render the appropriate markup.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T092222Z" creationid="shibukawa.yoshiki" creationdate="20170207T092140Z">
        <seg>このAPIを使うと、ページがロードされた後に、プログラムによって新たなリロードを行わずに、ブラウザに表示されるURLを変更できます。しかし、プログラマはそのURLがそのままコピーされて、新しいタブなどの新しい状態で使用されたときにも、適切なマークアップが表示されることを保証しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using variable data formats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174611Z" creationid="shibukawa.yoshiki" creationdate="20150414T174611Z">
        <seg>可変データ・フォーマットの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually it's recommended that you store application state outside of components (either in a &lt;a0&gt;view-model&lt;/a0&gt; or in the top-level component in the case of nested components).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082350Z" creationid="shibukawa.yoshiki" creationdate="20150502T082350Z">
        <seg>通常は、アプリケーションの状態は、&lt;a0&gt;ビューモデル&lt;/a0&gt;か、ネストされたコンポーネントの場合は最上位のコンポーネント以外のコンポーネントに持たせるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utilities</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143429Z" creationid="shibukawa.yoshiki" creationdate="20160412T143429Z">
        <seg>ユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utilities to integrate asynchronous contexts to the rendering system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154215Z" creationid="shibukawa.yoshiki" creationdate="20150412T154215Z">
        <seg>非同期のコンテキストをMithrilのレンダリングシステムに統合するためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values passed to the &lt;c1&gt;options&lt;/c1&gt; argument override options set via this shorthand.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T063223Z" creationid="shibukawa.yoshiki" creationdate="20170219T063223Z">
        <seg>&lt;c1&gt;options&lt;/c1&gt;引数に渡されたオプションは、この短縮形式のデフォルトオプションを上書きします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values' types should match the expected type for the respective attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153600Z" creationid="shibukawa.yoshiki" creationdate="20150413T153600Z">
        <seg>型は値の、それぞれの属性が期待する型とマッチする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152313Z" creationid="shibukawa.yoshiki" creationdate="20150414T152313Z">
        <seg>可変個引数のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version number in package.json is incremented</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054240Z" creationid="shibukawa.yoshiki" creationdate="20170220T054240Z">
        <seg>package.jsonのバージョン番号のインクリメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004128Z" creationid="shibukawa.yoshiki" creationdate="20150408T004128Z">
        <seg>ビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View Layer Paradigm</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145622Z" creationid="shibukawa.yoshiki" creationdate="20150417T145622Z">
        <seg>ビューレイヤーパラダイム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View-Model</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152214Z" creationid="shibukawa.yoshiki" creationdate="20150407T152214Z">
        <seg>ビュー・モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View-models are also responsible for handling business logic that revolves around UI-specific restrictions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T153025Z" creationid="shibukawa.yoshiki" creationdate="20150407T153025Z">
        <seg>ビューモデルはUI固有の制約に関するビジネスロジックを処理する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Views in Mithril use a virtual DOM diff implementation, which sidesteps performance problems related to opaque dirty-checking and excessive browser repaint that are present in some frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021414Z" creationid="shibukawa.yoshiki" creationdate="20150409T014712Z">
        <seg>Mithrilのビューは仮想DOMの差分実装を使用していて、いくつかのフレームワークが持っている不透明要素のダーティチェックやパフォーマンス上の問題といった問題を解決しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtual DOM diffing and compilable templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134014Z" creationid="shibukawa.yoshiki" creationdate="20150407T134014Z">
        <seg>Virtual DOM差分更新と、コンパイル可能なテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtual DOM tree can now contain &lt;a0&gt;components&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140833Z" creationid="shibukawa.yoshiki" creationdate="20160412T140833Z">
        <seg>仮想DOMツリーは&lt;a0&gt;components&lt;/a0&gt;を持つことができるようになった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vnodes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T024732Z" creationid="shibukawa.yoshiki" creationdate="20170131T024732Z">
        <seg>Vノード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vue is a relatively new templating engine, but it boasts impressive results in its performance benchmark.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105928Z" creationid="shibukawa.yoshiki" creationdate="20150420T105928Z">
        <seg>Vueは比較的新しいテンプレートエンジンですが、パフォーマンスのベンチマークでは目覚ましい結果を残しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vue's implementation cleverly hijacks array methods, but it should be noted that Javascript Arrays cannot be truly subclassed and as such, Vue suffers from abstraction leaks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110434Z" creationid="shibukawa.yoshiki" creationdate="20150420T110434Z">
        <seg>Vueの実装は巧妙に配列のメソッドをハイジャックします。JavaScriptの配列をきちんとサブクラス化することが難しくなるため、抽象化の漏れに直面することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warning: this section is likely biased.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015053Z" creationid="shibukawa.yoshiki" creationdate="20150420T015053Z">
        <seg>注意: このセクションの説明にはバイアスがかかっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are now also rendering the value of that variable in the button label.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031354Z" creationid="shibukawa.yoshiki" creationdate="20170131T031354Z">
        <seg>そして、この変数の値をボタンのラベルとして表示するようにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can add routing by changing the &lt;c0&gt;m.mount&lt;/c0&gt; call to a &lt;c1&gt;m.route&lt;/c1&gt; call:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T053104Z" creationid="shibukawa.yoshiki" creationdate="20170221T053104Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;呼び出しを&lt;c1&gt;m.route&lt;/c1&gt;に変更すると、ラウティングを使うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can append an ellipsis (&lt;c0&gt;...&lt;/c0&gt;) to the name of a route argument to allow it to match URL snippets that contain slashes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153907Z" creationid="shibukawa.yoshiki" creationdate="20150414T153907Z">
        <seg>省略記号(&lt;c0&gt;...&lt;/c0&gt;)をラウトの引数の名前に付けると、スラッシュを含むURLにマッチさせることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can verify that both the enter and exit animations work by mounting the &lt;c0&gt;Toggler&lt;/c0&gt; component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110610Z" creationid="shibukawa.yoshiki" creationdate="20170206T110610Z">
        <seg>&lt;c0&gt;Toggler&lt;/c0&gt;コンポーネントをマウントすると、作成時と終了時の両方のアニメーションが動作することが確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could create the entire application in a single Javascript file, but doing so would make it difficult to navigate the codebase later on.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T070949Z" creationid="shibukawa.yoshiki" creationdate="20170207T070949Z">
        <seg>1つのJavaScriptファイルアプリケーション全体を作成することもできますが、将来、コードベースの中を探索するのが難しくなるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We covered how to create and update HTML, how to create components, routes for a Single Page Application, and interacted with a server via XHR.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T153048Z" creationid="shibukawa.yoshiki" creationdate="20170204T153048Z">
        <seg>本チュートリアルではHTMLの作成と更新方法、コンポーネントの作成方法、シングルページアプリケーションのためのラウト。サーバーとのインタラクションを説明してきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We declare this outside of the &lt;c2&gt;select2.view&lt;/c2&gt; function to avoid cluttering the template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133638Z" creationid="shibukawa.yoshiki" creationdate="20150412T133638Z">
        <seg>テンプレートが散乱するのを避けるために、&lt;c2&gt;select2.view&lt;/c2&gt;関数の外側にこの関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We defined an &lt;c0&gt;onclick&lt;/c0&gt; event on the button, which increments a variable &lt;c1&gt;count&lt;/c1&gt; (which was declared at the top).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031010Z" creationid="shibukawa.yoshiki" creationdate="20170131T031010Z">
        <seg>ボタンに対して&lt;c0&gt;onclick&lt;/c0&gt;イベントを追加しました。このイベントは、コードの先頭で宣言されている&lt;c1&gt;count&lt;/c1&gt;変数をインクリメントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We only evaluate the getter-setter to get its value in the controller method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151744Z" creationid="shibukawa.yoshiki" creationdate="20150408T151744Z">
        <seg>Mithrilは、getter-setterをcontrollerメソッド内でしか評価しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the classList API here to add an &lt;c2&gt;exit&lt;/c2&gt; class to &lt;c3&gt;&lt;div class="fancy"&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110349Z" creationid="shibukawa.yoshiki" creationdate="20170206T110349Z">
        <seg>classList APIを使って、&lt;c2&gt;exit&lt;/c2&gt;クラスを&lt;c3&gt;&lt;div class="fancy"&gt;&lt;/c3&gt;に付与しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll see how to define a component in a bit.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135132Z" creationid="shibukawa.yoshiki" creationdate="20150502T135132Z">
        <seg>どのようにコンポーネントを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll see how to define a module in a bit.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002911Z" creationid="shibukawa.yoshiki" creationdate="20150410T002911Z">
        <seg>どのようにモジュールを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Web Services</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140740Z" creationid="shibukawa.yoshiki" creationdate="20150407T140740Z">
        <seg>ウェブサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Web Services - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013833Z" creationid="shibukawa.yoshiki" creationdate="20150410T013833Z">
        <seg>ウェブサービス - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weekly articles on how to use Mithril to its full potential.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135705Z" creationid="shibukawa.yoshiki" creationdate="20150407T135705Z">
        <seg>Mithrilのポテンシャルを引き出す使い方を紹介するブログです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is Mithril?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140447Z" creationid="shibukawa.yoshiki" creationdate="20150407T132200Z">
        <seg>Mithrilとは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;a0&gt;integrating with third party libraries&lt;/a0&gt;, you might find that you need to call asynchronous methods from outside of Mithril's API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004432Z" creationid="shibukawa.yoshiki" creationdate="20150412T004432Z">
        <seg>&lt;a0&gt;サードパーティ製のライブラリを統合する時に&lt;/a0&gt;、MithrilのAPIの外で非同期メソッドが使っているものもあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;m.mount&lt;/c0&gt; is called, the controller function runs, and its return value is returned by the &lt;c1&gt;m.mount&lt;/c1&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125637Z" creationid="shibukawa.yoshiki" creationdate="20150502T125637Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;が呼ばれると、controller関数が実行されて、それが&lt;c1&gt;m.mount&lt;/c1&gt;の返り値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;m.route&lt;/c0&gt; is called at the bottom, the &lt;c1&gt;Todos&lt;/c1&gt; component is initialized.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T143448Z" creationid="shibukawa.yoshiki" creationdate="20170219T143448Z">
        <seg>最後の行で&lt;c0&gt;m.route&lt;/c0&gt;が呼ばれると、&lt;c1&gt;Todos&lt;/c1&gt;コンポーネントが初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;onmatch&lt;/c0&gt; is called, the resolution for this path is not complete and &lt;c1&gt;m.route.get()&lt;/c1&gt; still returns the previous path.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090032Z" creationid="shibukawa.yoshiki" creationdate="20170207T090008Z">
        <seg>&lt;c0&gt;onmatch&lt;/c0&gt;が呼ばれると、パスの解決は延期され、&lt;c1&gt;m.route.get()&lt;/c1&gt;が返すパスも解決されて変更される前のままとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Mithril does not redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121320Z" creationid="shibukawa.yoshiki" creationdate="20170206T121320Z">
        <seg>Mithrilが再描画を行わない時</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a attribute name expects different types for the value in HTML and Javascript, the Javascript type should be used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153800Z" creationid="shibukawa.yoshiki" creationdate="20150413T153800Z">
        <seg>もし、指定された属性名がHTMLとJavaScriptで異なる型を期待している場合は、JavaScriptの型が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a component has asynchronous payloads and they are queued by the &lt;a0&gt;auto-redrawing system&lt;/a0&gt;, its view is NOT rendered until all asynchronous operations complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093644Z" creationid="shibukawa.yoshiki" creationdate="20150502T093644Z">
        <seg>もしコンポーネントが非同期のロードを行っていて、&lt;a0&gt;再描画システム&lt;/a0&gt;のカウンター操作を行っている場合は、非同期操作が完了するまでは再描画が行われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a tag is not specified, &lt;c2&gt;div&lt;/c2&gt; is the default.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T133547Z" creationid="shibukawa.yoshiki" creationdate="20170220T133547Z">
        <seg>タグが指定されないと&lt;c2&gt;div&lt;/c2&gt;がデフォルトで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a user navigates from a parameterized route to the same route with a different parameter (e.g. going from &lt;c0&gt;/page/1&lt;/c0&gt; to &lt;c1&gt;/page/2&lt;/c1&gt; given a route &lt;c2&gt;/page/:id&lt;/c2&gt;, the component would not be recreated from scratch since both routes resolve to the same component, and thus result in a virtual dom in-place diff.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055109Z" creationid="shibukawa.yoshiki" creationdate="20170208T054500Z">
        <seg>もし、ユーザーがパラメータ付きのラウトから、同じラウト定義（&lt;c2&gt;/page/:id&lt;/c2&gt;）のパラメータ違いのラウト（&lt;c0&gt;/page/1&lt;/c0&gt;から&lt;c1&gt;/page/2&lt;/c1&gt;）に遷移しようとした時は、1.0からは同じコンポーネントでラウトの解決が行われるため、コンポーネントの破棄と再作成は行われません。フルスクラッチではなく、その場のdiffによる高速な仮想DOMの更新が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When calling multiple background AJAX requests, it's recommended that you use &lt;a0&gt;&lt;c1&gt;m.sync&lt;/c1&gt;&lt;/a0&gt; to batch redraw once at the end of all requests, as opposed to repeatedly redrawing after every request:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134537Z" creationid="shibukawa.yoshiki" creationdate="20150502T134537Z">
        <seg>複数のバックグラウンドのAJAXリクエストを行った場合は、個別のリクエストの完了後に再描画を行うのではなく、&lt;a0&gt;&lt;c1&gt;m.sync&lt;/c1&gt;&lt;/a0&gt;を使って待ち合わせを行い、一度だけ再描画を行うのが推奨です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When components aren't nested, Mithril waits for all asynchronous tasks to complete, but when components are nested, a component's parent view renders before the component completes its asynchronous tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093241Z" creationid="shibukawa.yoshiki" creationdate="20150502T093241Z">
        <seg>コンポーネントがネストされていないとMithrilはすべての非同期タスクが完了するのを待ちますが、ネストされていると非同期タスクの完了前に親コンポーネントが再描画することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When computation methods are used dilligently and religiously, templates are never redrawn with incomplete data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115359Z" creationid="shibukawa.yoshiki" creationdate="20150502T115359Z">
        <seg>computationメソッドを使うと、未完了のデータをテンプレートが利用することがなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When creating animations, it's recommended that you only use the &lt;c0&gt;opacity&lt;/c0&gt; and &lt;c1&gt;transform&lt;/c1&gt; CSS rules, since these can be hardware-accelerated by modern browsers and yield better performance than animating &lt;c2&gt;top&lt;/c2&gt;, &lt;c3&gt;left&lt;/c3&gt;, &lt;c4&gt;width&lt;/c4&gt;, and &lt;c5&gt;height&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T111431Z" creationid="shibukawa.yoshiki" creationdate="20170206T111431Z">
        <seg>アニメーションを作成する場合は、&lt;c0&gt;opacity&lt;/c0&gt;と&lt;c1&gt;transform&lt;/c1&gt;のCSSルールだけを使うことをおすすめします。現代のブラウザであればハードウェアアクセラレーションが行えるため、&lt;c2&gt;top&lt;/c2&gt;、&lt;c3&gt;left&lt;/c3&gt;、&lt;c4&gt;width&lt;/c4&gt;、&lt;c5&gt;height&lt;/c5&gt;を操作するよりも良いパフォーマンスが得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When dealing with asynchronous functions, you must call [&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;] if you want the asynchronous payload to affect the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135455Z" creationid="shibukawa.yoshiki" creationdate="20150415T135455Z">
        <seg>非同期関数を使用して、その非同期で取得してきた値をビューに反映させたい時は、[&lt;c0&gt;m.startComputation&lt;/c0&gt; / &lt;c1&gt;m.endComputation&lt;/c1&gt;]を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When navigating to routes, there's no need to explicitly specify the router prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053421Z" creationid="shibukawa.yoshiki" creationdate="20170208T053421Z">
        <seg>ラウトにナビゲートする時はラウタープリフィックスを指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When refactoring is unavoidable, the developer can simply replace the &lt;c0&gt;m.prop&lt;/c0&gt; call with an appropriate getter-setter implementation, instead of having to grep for API usage across the entire application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002313Z" creationid="shibukawa.yoshiki" creationdate="20150409T002313Z">
        <seg>リファクタリングが避けられなくなったら、&lt;c0&gt;m.prop&lt;/c0&gt;呼び出しを、適切なgetter-setter実装に置き換えるだけで済みます。プログラム全体をgrepしてAPIを使っている箇所を検索して置き換える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the URL matches a route, the respective component's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135208Z" creationid="shibukawa.yoshiki" creationdate="20150502T135208Z">
        <seg>URLがラウトにマッチすると、対応するコンポーネントのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the URL matches a route, the respective module's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003820Z" creationid="shibukawa.yoshiki" creationdate="20150410T003820Z">
        <seg>URLがラウトにマッチすると、対応するモジュールのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application loads, &lt;c0&gt;onmatch&lt;/c0&gt; is called and since &lt;c1&gt;isLoggedIn&lt;/c1&gt; is false, the application redirects to &lt;c2&gt;/login&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T075121Z" creationid="shibukawa.yoshiki" creationdate="20170208T075121Z">
        <seg>アプリケーションがロードされると、&lt;c0&gt;onmatch&lt;/c0&gt;が呼ばれ、&lt;c1&gt;isLoggedIn&lt;/c1&gt;がfalseになり、&lt;c2&gt;/login&lt;/c2&gt;にリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the component's asynchronous operations complete, another redraw is triggered and the entire template tree is evaluated again.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093753Z" creationid="shibukawa.yoshiki" creationdate="20150502T093753Z">
        <seg>コンポーネントの非同期操作が完了すると、他の再描画が起動されて、テンプレートのツリー全体を再び再評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "all", Mithril throws away the current view and redraws from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140607Z" creationid="shibukawa.yoshiki" creationdate="20150416T140607Z">
        <seg>このフラグが"all"に設定されると、Mithrilは現在のビューをすべて破棄し、ゼロから再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "diff", Mithril performs a diff between the old view and the new view and applies patches to the DOM only where needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143423Z" creationid="shibukawa.yoshiki" creationdate="20150416T143423Z">
        <seg>このフラグが"diff"に設定されると、Mithrilは古いビューと新しいビューの間の差分の検知を行い必要な箇所にだけ差分を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "none", Mithril skips the next redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143445Z" creationid="shibukawa.yoshiki" creationdate="20150416T143445Z">
        <seg>フラグが"none"に設定されるとMithrilは次の再描画をスキップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the server returns a response, &lt;c2&gt;User.list&lt;/c2&gt; gets populated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T145750Z" creationid="shibukawa.yoshiki" creationdate="20170220T145750Z">
        <seg>サーバーがレスポンスを返すと、&lt;c2&gt;User.list&lt;/c2&gt;に値が設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When updates happen, the template is not wholly re-rendered - only the changes are applied.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160905Z" creationid="shibukawa.yoshiki" creationdate="20150408T160905Z">
        <seg>更新が発生した場合は、全体の再描画は行われずに、変更があった箇所だけ更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used idiomatically, Mithril employs an auto-redraw system that synchronizes the DOM whenever changes are made in the data layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T032809Z" creationid="shibukawa.yoshiki" creationdate="20170131T032809Z">
        <seg>慣用的な表現をすると、Mithrilはデータレイヤーの変更をDOMに同期するために、自動再描画システムを利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using a file input, you can get a list of files by adding the &lt;c1&gt;multiple&lt;/c1&gt; attribute to the input:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T190905Z" creationid="shibukawa.yoshiki" creationdate="20170219T190905Z">
        <seg>fileのinputタグを使うのであれば、&lt;c1&gt;multiple&lt;/c1&gt;属性を付与すると、ファイルのリストが得られるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the &lt;a0&gt;router&lt;/a0&gt;, a route change recreates the DOM tree from scratch in order to unload plugins from the previous page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130655Z" creationid="shibukawa.yoshiki" creationdate="20150413T130655Z">
        <seg>&lt;a0&gt;router&lt;/a0&gt;を使用している時は、ラウトが変更されると、前のページで使用されていたプラグインをアンロードするために、DOMツリーがスクラッチから再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we get there, I'll explain why we're passing description as an argument instead of simply using OOP-style member association.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163625Z" creationid="shibukawa.yoshiki" creationdate="20150407T163439Z">
        <seg>準備が整ったところで、なぜこのサンプルではオブジェクト指向プログラミングのスタイルのメンバーの関連付けを行わずに、descriptionを引数として渡すのかを説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we return a promise from &lt;c1&gt;onbeforeremove&lt;/c1&gt;, Mithril waits until the promise is resolved and only then it removes the element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T110453Z" creationid="shibukawa.yoshiki" creationdate="20170206T110453Z">
        <seg>&lt;c1&gt;onbeforeremove&lt;/c1&gt;からPromiseを返すと、MithrilはそのPromiseが解決されるまで要素の削除を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether routing uses location hash, querystring or pathname</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153641Z" creationid="shibukawa.yoshiki" creationdate="20150412T153641Z">
        <seg>ラウティングがハッシュ、クエリー文字列、パス名のどのモードを使用するか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether the request should be asynchronous.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T152422Z" creationid="shibukawa.yoshiki" creationdate="20170219T065737Z">
        <seg>リクエストが非同期であるべきかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether this is the first time we are running this function on this element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155116Z" creationid="shibukawa.yoshiki" creationdate="20150413T155116Z">
        <seg>関数がこのエレメントに対して実行されるのが初回かどうかを表すフラグです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether to create a new history entry or to replace the current one.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080739Z" creationid="shibukawa.yoshiki" creationdate="20170207T080732Z">
        <seg>新しい履歴のエントリーを追加するか、今のエントリーを置き換えるか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether to send cookies to 3rd party domains.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070115Z" creationid="shibukawa.yoshiki" creationdate="20170219T070115Z">
        <seg>サードパーティードメインに対してクッキーを送付するかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Mithril doesn't dictate how to organize your code, it does provide some recommendations for structuring it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T014003Z" creationid="shibukawa.yoshiki" creationdate="20150421T014003Z">
        <seg>Mithrilは、手取り足取りコードを構造化させることはありませんが、アプリケーションの構造として推奨していることがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Mithril technically does support this use case, relying on multiple redraw passes degrades performance and makes it possible to code yourself into an infinite execution loop situation, which is extremely difficult to debug.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135828Z" creationid="shibukawa.yoshiki" creationdate="20150412T135828Z">
        <seg>Mithrilは技術的にこのユースケースをサポートしていないため、再描画が何度も行われてパフォーマンスが低下したりしますし、場合によってはアプリケーションコードが無限ループして、デバッグが極めて難しい状況になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While at first glance, it may seem expensive to run a global redraw every time data changes, Mithril makes it possible to do this efficiently thanks to its fast diffing algorithm, which only updates the DOM where it needs to be updated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184052Z" creationid="shibukawa.yoshiki" creationdate="20150411T184052Z">
        <seg>初めて見るとデータ変更があるたびに全体を再描画するのは高コストに見えると思いますが、変更のあるDOMだけを更新するという高速な差分アルゴリズムを使い、Mithrilでは効率的にこれを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While both basic assignment syntax and thenable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax in the first example whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T140923Z" creationid="shibukawa.yoshiki" creationdate="20160101T140923Z">
        <seg>代入構文も、thenableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While both basic assignment syntax and thennable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174926Z" creationid="shibukawa.yoshiki" creationdate="20150414T174926Z">
        <seg>代入構文も、thennableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While superficially this may seem like an odd design, this actually has a lot of benefits:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013155Z" creationid="shibukawa.yoshiki" creationdate="20150409T013155Z">
        <seg>ぱっと見ると、これはとても奇妙な設計に見えますが、実際には多くのメリットがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this decision allows better API discoverability, the trade-off is that we're largely giving up on custom constraints and behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003021Z" creationid="shibukawa.yoshiki" creationdate="20150409T003021Z">
        <seg>既に慣れ親しんでいるAPIが使えるようになったトレードオフとして、カスタムの動作を行うことができなくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why JSON instead of HTML</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T161038Z" creationid="shibukawa.yoshiki" creationdate="20170219T161038Z">
        <seg>なぜHTMLではなくJSONなのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why XHR instead of fetch</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T161051Z" creationid="shibukawa.yoshiki" creationdate="20170219T161051Z">
        <seg>なぜfetchではなくXHRなのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this, we can make the &lt;c0&gt;onclick&lt;/c0&gt; binding on the template &lt;e1&gt;much&lt;/e1&gt; simpler:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152559Z" creationid="shibukawa.yoshiki" creationdate="20150408T152559Z">
        <seg>これにより、テンプレートの&lt;c0&gt;onclick&lt;/c0&gt;バインディングを&lt;e1&gt;もっとシンプルに&lt;/e1&gt;書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With those methods and properties, it creates a template that can consume model data and call controller methods to affect the model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062103Z" creationid="shibukawa.yoshiki" creationdate="20150502T062103Z">
        <seg>これらのメソッドとプロパティを使い、モデルデータを利用したり、モデルを変化させるコントローラのメソッドを呼んだりするテンプレートを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Word wrap</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T143519Z" creationid="shibukawa.yoshiki" creationdate="20160412T143519Z">
        <seg>ワードラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wrapping a layout component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064928Z" creationid="shibukawa.yoshiki" creationdate="20170208T064928Z">
        <seg>レイアウトコンポーネントのラッピング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes, this is valid HTML 5!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142725Z" creationid="shibukawa.yoshiki" creationdate="20150407T142725Z">
        <seg>そうです。これは完全なHTML5です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are encouraged to use CSS selectors to define virtual elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235303Z" creationid="shibukawa.yoshiki" creationdate="20150412T235303Z">
        <seg>仮想エレメントを定義するときはCSSセレクタを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are responsible for ensuring that templates aren't too big to render efficiently.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020812Z" creationid="shibukawa.yoshiki" creationdate="20150421T020812Z">
        <seg>そのため、テンプレートが大きくなりすぎないようにして、レンダリングを効率よく行うことが大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can &lt;a0&gt;download a zip of the latest version here&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160423T045818Z" creationid="shibukawa.yoshiki" creationdate="20160423T045818Z">
        <seg>&lt;a0&gt;ここから&lt;/a0&gt;最新バージョンのzipアーカイブをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also &lt;a6&gt;learn how the redrawing system works here&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015009Z" creationid="shibukawa.yoshiki" creationdate="20150413T015009Z">
        <seg>また、&lt;a6&gt;こちらのドキュメントで再描画システムがどのように動くのか&lt;/a6&gt;学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also configure individual elements to always be diffed, instead of recreated from scratch (even across route changes), by using the &lt;a0&gt;&lt;c1&gt;ctx.retain&lt;/c1&gt; flag&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133256Z" creationid="shibukawa.yoshiki" creationdate="20150502T133256Z">
        <seg>&lt;a0&gt;&lt;c1&gt;ctx.retain&lt;/c1&gt;フラグ&lt;/a0&gt;を使うと、個別のエレメントに対してラウトの変更であっても、常に差分検知を行わずに再生成させないように指示することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find Mithril in &lt;a0&gt;cdnjs&lt;/a0&gt; and &lt;a1&gt;jsDelivr&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165214Z" creationid="shibukawa.yoshiki" creationdate="20150407T165214Z">
        <seg>&lt;a0&gt;cdnjs&lt;/a0&gt;と&lt;a1&gt;jsDelivr&lt;/a1&gt;の中から取得することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also fork the latest stable project &lt;a0&gt;directly from Github&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000257Z" creationid="shibukawa.yoshiki" creationdate="20150408T000257Z">
        <seg>&lt;a0&gt;Githubから直接&lt;/a0&gt;、最新の安定版のプロジェクトをフォークすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also navigate programmatically, via &lt;c0&gt;m.route.set(route)&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053315Z" creationid="shibukawa.yoshiki" creationdate="20170208T053315Z">
        <seg>これ以外の方法では、&lt;c0&gt;m.route.set(route)&lt;/c0&gt;を使うとソースコードを使ってページの遷移を行わせられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify what attribute to bind.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021800Z" creationid="shibukawa.yoshiki" creationdate="20150408T021800Z">
        <seg>また、どの属性と結びつけるかも自由に設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use it to attach events to other elements (for example, &lt;c0&gt;window.onresize&lt;/c0&gt;), but you should remove such event handlers via &lt;c1&gt;ctx.onunload&lt;/c1&gt; to avoid surprises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124451Z" creationid="shibukawa.yoshiki" creationdate="20150502T124451Z">
        <seg>この機能を使って、&lt;c0&gt;window.onresize&lt;/c0&gt;などのイベントを他のエレメントに付与することもできますが、その場合はトラブルを避けるために&lt;c1&gt;ctx.onunload&lt;/c1&gt; を使って確実にイベントハンドラを削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use more complex CSS selectors:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000233Z" creationid="shibukawa.yoshiki" creationdate="20150413T000233Z">
        <seg>より複雑なCSSセレクタを使用することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use other polyfills to support these features in IE7.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014826Z" creationid="shibukawa.yoshiki" creationdate="20150417T014826Z">
        <seg>IE7をサポートするためには他のPolyfillが使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the &lt;c0&gt;onunload&lt;/c0&gt; function to PREVENT a component from being unloaded in the context of a route change (i.e. to alert a user to save their changes before navigating away from a page)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091917Z" creationid="shibukawa.yoshiki" creationdate="20150502T091917Z">
        <seg>ラウターの変更のコンテキスト内で&lt;c0&gt;onunload&lt;/c0&gt;関数を使うことで、モジュールがアンロードされるのを中断することができます。これはページ移動前にデータ変更することを警告する時などに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the &lt;c1&gt;.&lt;/c1&gt; syntax to add CSS classes and the &lt;c2&gt;#&lt;/c2&gt; to add an id.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004414Z" creationid="shibukawa.yoshiki" creationdate="20150408T004414Z">
        <seg>&lt;c1&gt;.&lt;/c1&gt;文法を使ってCSSのクラスを追加したり、&lt;c2&gt;#&lt;/c2&gt;を使ってidを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can alternatively include only specific polyfills:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014716Z" creationid="shibukawa.yoshiki" creationdate="20150417T014716Z">
        <seg>特定の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can bind a pre-existing getter-setter by passing it in as a parameter to a &lt;c1&gt;.then&lt;/c1&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015957Z" creationid="shibukawa.yoshiki" creationdate="20150410T015957Z">
        <seg>あらかじめ作成したgetter-setterを&lt;c1&gt;.then&lt;/c1&gt;メソッドの引数で渡して束縛することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a non-HTML-standard attribute called &lt;c0&gt;config&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123308Z" creationid="shibukawa.yoshiki" creationdate="20150413T123308Z">
        <seg>&lt;c0&gt;config&lt;/c0&gt;という名前のHTML標準ではない属性を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can disable an auto-redraw for a specific request by setting the &lt;c0&gt;background&lt;/c0&gt; option to true:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T121114Z" creationid="shibukawa.yoshiki" creationdate="20170206T121114Z">
        <seg>特定のサーバーリクエスト処理後に再描画を無効にするには、&lt;c0&gt;background&lt;/c0&gt;オプションをtrueにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can disable an auto-redraw for specific events by setting &lt;c0&gt;e.redraw&lt;/c0&gt; to &lt;c1&gt;false&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T120920Z" creationid="shibukawa.yoshiki" creationdate="20170206T120920Z">
        <seg>特定のイベントの再描画を無効にするには、&lt;c0&gt;e.redraw&lt;/c0&gt;に&lt;c1&gt;false&lt;/c1&gt;を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can even build components that take other components as first-class-citizen parameters!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014444Z" creationid="shibukawa.yoshiki" creationdate="20150409T014444Z">
        <seg>他のコンポーネントを一級市民のパラメータとして受け取るようなコンポーネントも実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find the &lt;a0&gt;Javascript syntax for all the CSS rules here&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013815Z" creationid="shibukawa.yoshiki" creationdate="20150413T013815Z">
        <seg>&lt;a0&gt;JavaScript文法におけるCSSのルールはこちら&lt;/a0&gt;で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get around this issue by using &lt;c0&gt;extract&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175650Z" creationid="shibukawa.yoshiki" creationdate="20150414T175650Z">
        <seg>この問題を回避するには、&lt;c0&gt;extract&lt;/c0&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can learn more about how redrawing heuristics work &lt;a0&gt;here&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161935Z" creationid="shibukawa.yoshiki" creationdate="20150408T161935Z">
        <seg>どのように再描画の仕組みが動作するかは&lt;a0&gt;こちら&lt;/a0&gt;のドキュメントでより詳しく知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can learn more about keys &lt;a1&gt;here&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090840Z" creationid="shibukawa.yoshiki" creationdate="20150502T090840Z">
        <seg>キーについては&lt;a1&gt;ここで&lt;/a1&gt;学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can navigate back and forth to the splash page using the browser's back and next button.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170204T143219Z" creationid="shibukawa.yoshiki" creationdate="20170204T143210Z">
        <seg>ブラウザの「戻る」「進む」ボタンを使って、スプラッシュページにいったりきたりナビゲーションできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now update the label of the button by clicking the button.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031425Z" creationid="shibukawa.yoshiki" creationdate="20170131T031425Z">
        <seg>ボタンをクリックすると、ボタンのラベルが更新されるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only have one &lt;c0&gt;m.route&lt;/c0&gt; call per application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T080129Z" creationid="shibukawa.yoshiki" creationdate="20170207T080129Z">
        <seg>アプリケーションごとに1回だけ&lt;c0&gt;m.route&lt;/c0&gt;呼び出しが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can optionally pre-compile templates that use &lt;c0&gt;m()&lt;/c0&gt; by using &lt;a1&gt;mithril-objectify&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T141443Z" creationid="shibukawa.yoshiki" creationdate="20160101T141443Z">
        <seg>オプションの機能としては、&lt;a1&gt;mithril-objectify&lt;/a1&gt;を使用すると、&lt;c0&gt;m()&lt;/c0&gt;を使ったテンプレートを事前にコンパイルすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override this by providing &lt;c1&gt;serialize&lt;/c1&gt; and &lt;c2&gt;deserialize&lt;/c2&gt; options:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174941Z" creationid="shibukawa.yoshiki" creationdate="20150410T174941Z">
        <seg>&lt;c1&gt;serialize&lt;/c1&gt;オプションと、&lt;c2&gt;deserialize&lt;/c2&gt;オプションを提供すると、この動作を変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass a constructor as the &lt;c0&gt;options.type&lt;/c0&gt; parameter and Mithril will instantiate it for each object in the HTTP response.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004130Z" creationid="shibukawa.yoshiki" creationdate="20170220T004130Z">
        <seg>&lt;c0&gt;options.type&lt;/c0&gt;パラメータにコンストラクタを渡すと、MithrilがHTTPレスポンスの各オブジェクトからインスタンス化を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pre-compile Mithril templates to make them run faster.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014212Z" creationid="shibukawa.yoshiki" creationdate="20150417T014212Z">
        <seg>Mithirlのテンプレートは事前にコンパイルすることでさらに高速にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can programmatically redirect to another page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012943Z" creationid="shibukawa.yoshiki" creationdate="20150410T012943Z">
        <seg>APIを使用して他のページにリダイレクトすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read about how to use the optional Streams module in &lt;a2&gt;the documentation&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T034756Z" creationid="shibukawa.yoshiki" creationdate="20170131T034756Z">
        <seg>オプションであるストリームモジュールの使用方法は、こちらの&lt;a2&gt;ドキュメント&lt;/a2&gt;で読むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read more about the &lt;a0&gt;promise exception monitor here&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181922Z" creationid="shibukawa.yoshiki" creationdate="20150414T181922Z">
        <seg>詳細については、&lt;a0&gt;こちらのpromiseの例外モニタ&lt;/a0&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read more about the &lt;a2&gt;&lt;c3&gt;m.prop&lt;/c3&gt; getter-setter utility here&lt;/a2&gt; and the &lt;a4&gt;&lt;c5&gt;m.withAttr&lt;/c5&gt; event handler factory here&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014927Z" creationid="shibukawa.yoshiki" creationdate="20150413T014927Z">
        <seg>詳細の情報は&lt;a2&gt;こちらの&lt;c3&gt;m.prop&lt;/c3&gt; getter-setterユーティリティ&lt;/a2&gt;と、&lt;a4&gt;こちらの&lt;c5&gt;m.withAttr&lt;/c5&gt;イベントハンドラ&lt;/a4&gt;で読むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see that our classes above fit the criteria: they have all the methods and properties that they need to be assembled into a meaningful state.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151742Z" creationid="shibukawa.yoshiki" creationdate="20150407T151742Z">
        <seg>上記のサンプルのモデルクラスは、この基準を満たしていることがわかるでしょう。意味のある状態を構成するのに必要なメソッドとプロパティを十分に備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set inline styles like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013132Z" creationid="shibukawa.yoshiki" creationdate="20150413T013132Z">
        <seg>次のようにインラインでスタイルを設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify an initial value for the &lt;c2&gt;m.request&lt;/c2&gt; getter-setter in order to avoid having to write defensive code against potential null reference exceptions:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001757Z" creationid="shibukawa.yoshiki" creationdate="20150415T001757Z">
        <seg>&lt;c2&gt;m.request&lt;/c2&gt;に渡すgetter-setterに初期値を渡すという防衛的なコーディングを行えば、null参照例外が発生する可能性を抑えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify that their &lt;c1&gt;href&lt;/c1&gt; attribute is a route URL (rather than being a regular link that navigates away from the current page), by adding the hook &lt;c2&gt;{oncreate: m.route.link}&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053238Z" creationid="shibukawa.yoshiki" creationdate="20170208T053238Z">
        <seg>&lt;c1&gt;href&lt;/c1&gt;にはラウターURLを指定できます。&lt;c2&gt;{oncreate: m.route.link}&lt;/c2&gt;を付与すると、通常のリンクではなく、現在のページから指定ページに遷移するナビゲーションになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can take that idea further to create components that recreate themselves when reloaded:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T055646Z" creationid="shibukawa.yoshiki" creationdate="20170208T055646Z">
        <seg>この機能を使うと、リロード時に完全に再作成されるコンポーネントを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can unescape trusted HTML strings by using &lt;a0&gt;&lt;c1&gt;m.trust&lt;/c1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020947Z" creationid="shibukawa.yoshiki" creationdate="20150413T020947Z">
        <seg>信頼できるHTML文字列をエスケープを抑える時は&lt;a0&gt;&lt;c1&gt;m.trust&lt;/c1&gt;&lt;/a0&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use Mithril to create SVG documents (as long as you don't need to support browsers that don't support SVG natively).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140726Z" creationid="shibukawa.yoshiki" creationdate="20150413T140726Z">
        <seg>ネイティブでSVGをサポートしていないブラウザをサポートしたくないと思わない限り、Mithrilを使ってSVGドキュメントを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use both HTML and Javascript attribute names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153453Z" creationid="shibukawa.yoshiki" creationdate="20150413T153453Z">
        <seg>HTMLとJavaScriptの両方の属性名を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use it by adding a reference to your Typescript files.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014336Z" creationid="shibukawa.yoshiki" creationdate="20150417T014336Z">
        <seg>これを使用するには、TypeScriptファイルに参照を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use simple tag selectors to make templates resemble HTML:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000004Z" creationid="shibukawa.yoshiki" creationdate="20150413T000004Z">
        <seg>シンプルなタグセレクタを使って、HTMLに似たテンプレートを作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use task automation tools such as GruntJS to concatenate the files back together for production.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015208Z" creationid="shibukawa.yoshiki" creationdate="20150421T015208Z">
        <seg>GruntJSのようなタスク自動化ツールを使って、リリース環境向けにファイルを1つにまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the view-model like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163701Z" creationid="shibukawa.yoshiki" creationdate="20150407T163701Z">
        <seg>ビュー・モデルは次のように使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this mechanism to attach custom event listeners to controller methods (for example, when integrating with third party libraries), but you are responsible for making sure the integration with Mithril's autoredrawing system is in place.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125403Z" creationid="shibukawa.yoshiki" creationdate="20150413T125403Z">
        <seg>この機能を使うと、サードパーティのライブラリを統合する時などに、コントローラのメソッドを呼び出すようなカスタムのイベントハンドラを登録できます。ただし、Mithrilの自動描画システムがきちんと働くようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can, however, use CSS syntax when defining style rules as inline strings:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013928Z" creationid="shibukawa.yoshiki" creationdate="20150413T013928Z">
        <seg>インラインの文字列を使うことで、CSS文法を使ってスタイルルールを定義することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can, of course, nest virtual elements:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000541Z" creationid="shibukawa.yoshiki" creationdate="20150413T000541Z">
        <seg>もちろん、ネストされた仮想エレメントも作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't need to call &lt;a1&gt;&lt;c2&gt;m.mount&lt;/c2&gt;&lt;/a1&gt; to initialize your components if you define a list of routes - &lt;c3&gt;m.route&lt;/c3&gt; calls it for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135114Z" creationid="shibukawa.yoshiki" creationdate="20150502T135114Z">
        <seg>ラウトのリストを定義した場合は、モジュールの初期化をするために&lt;a1&gt;&lt;c2&gt;m.mount&lt;/c2&gt;&lt;/a1&gt;を呼ぶ必要はありません。&lt;c3&gt;m.route&lt;/c3&gt;が代わりに呼んでくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't need to change this flag to something else again later, since Mithril does that for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143529Z" creationid="shibukawa.yoshiki" creationdate="20150416T143529Z">
        <seg>繰り返しになりますが、このフラグを設定する必要はありません。Mithrilが自動で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get the ability to automate linting, unit testing and minifying of the entire view layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014412Z" creationid="shibukawa.yoshiki" creationdate="20150409T014304Z">
        <seg>自動文法チェック(lint)、ユニットテスト、ビューレイヤーのminifyといったことも可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may choose to declare the namespace in a separate file or have the build system generate it on demand, instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015503Z" creationid="shibukawa.yoshiki" creationdate="20150421T015503Z">
        <seg>ファイルごとに名前空間を用意するか、あるいはビルドシステムに名前空間を作らせるかは開発者の自由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may override this behavior by calling &lt;c2&gt;.catch&lt;/c2&gt; on the promise chain before returning it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T090628Z" creationid="shibukawa.yoshiki" creationdate="20170207T090628Z">
        <seg>この動作を回避するには、Promiseのチェーンを返す前に&lt;c2&gt;.catch&lt;/c2&gt;を呼び出して動作を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may return an XHR-like object (e.g. a XDomainRequest instance) to override the provided XHR instance altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014402Z" creationid="shibukawa.yoshiki" creationdate="20150415T014402Z">
        <seg>この関数を使うと、Mithrilが生成したXHRインスタンスの代わりに、XDomainRequestインスタンスなど、XHRのように動作するまったく別のオブジェクトに置き換えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also elect to maintain component state when it's not meaningful outside the scope of a single component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083740Z" creationid="shibukawa.yoshiki" creationdate="20150502T083740Z">
        <seg>コンポーネント外で管理する意味がない場合は、コンポーネントの状態を維持することを選ぶことになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must add a pair of these calls for each asynchronous execution thread, unless the thread is already integrated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134545Z" creationid="shibukawa.yoshiki" creationdate="20150412T134545Z">
        <seg>もしスレッドの統合が終わっていなければ、これらの関数のペアをすべての非同期実行スレッドのコードに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should always document integration components so that others can find out what attribute parameters can be used to initialize the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140339Z" creationid="shibukawa.yoshiki" creationdate="20150412T140339Z">
        <seg>統合コンポーネントを作成するときは、常にドキュメントを作成し、他の人がコンポーネントの初期化時にどの属性パラメータが使用できるか分かるようにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should always use keys if you need to sort lists, remove items from them or splice them in any way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150421Z" creationid="shibukawa.yoshiki" creationdate="20150413T150421Z">
        <seg>リストをソートしたり、要素を削除したり、スプライスする場合は常にキーを使用すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should avoid grouping classes by the MVC layer they belong to, i.e. don't create three files called model.js, controllers.js and views.js.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015612Z" creationid="shibukawa.yoshiki" creationdate="20150421T015612Z">
        <seg>MVCレイヤーそのものでクラスをグループ化するのはやめましょう。model.js、controllers.js、views.jsという名前のファイルは作ってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should avoid instantiating controller classes from views.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033729Z" creationid="shibukawa.yoshiki" creationdate="20150421T033729Z">
        <seg>ビューからコントr−ラのクラスのインスタンスを作成するのは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should avoid trying to render server-generated dynamic HTML with Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T022809Z" creationid="shibukawa.yoshiki" creationdate="20170220T022809Z">
        <seg>サーバーで動的に生成したHTMLをMithrilでレンダリングしようとするのは避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not add the &lt;c2&gt;callback&lt;/c2&gt; querystring parameter; Mithril already does that internally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234856Z" creationid="shibukawa.yoshiki" creationdate="20150414T234818Z">
        <seg>通常のJSONPリクエストで必要になる&lt;c2&gt;callback&lt;/c2&gt;クエリー文字列パラメータを設定する必要はありません。Mithrilが内部で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use these methods if your code is intended to run repeatedly (e.g. by using &lt;c0&gt;setInterval&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193428Z" creationid="shibukawa.yoshiki" creationdate="20150411T193428Z">
        <seg>&lt;c0&gt;setInterval&lt;/c0&gt;を使う場合など、コードが別々に呼ばれるような場合はこれらのメソッドは使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should use this method and implement similar ones when extracting values from a browser's Event object, instead of hard-coding the extraction code into controllers (or model methods).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140631Z" creationid="shibukawa.yoshiki" creationdate="20150414T140631Z">
        <seg>Mithrilを使う場合には、このメソッドを使うか似たような機能を実装して、ブラウザのイベントオブジェクトからプログラムに使う値を取り出す操作を、コントローラやモデルにハードコードしないコーディングをしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You're probably starting to notice that Javascript has strong support for functional programming and that it allows us to naturally do things that can be clunky in other frameworks (e.g. looping inside a &lt;c0&gt;&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;&lt;/c0&gt; construct).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153457Z" creationid="shibukawa.yoshiki" creationdate="20150408T153457Z">
        <seg>ここまでの説明でお気づきの通り、JavaScriptには、関数型プログラミングに対する強力なサポートが備わっています。これを使うと、他のフレームワークではなかなかうまく表現しづらいコードを、とても自然な形で記述することができます。例えば、&lt;c0&gt;&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;&lt;/c0&gt;を構成するためにループを使うといったことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>])
}
//a configuration that persists across route changes
function persistent(el, isInit, context) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135053Z" creationid="shibukawa.yoshiki" creationdate="20150413T135053Z">
        <seg>])
}
//ラウトが変更されてもエレメントを保持する設定
function persistent(el, isInit, context) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`id` is the the same as `value`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132826Z" creationid="shibukawa.yoshiki" creationdate="20160101T132826Z">
        <seg>`id`は`value`と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acknowledging that the string is authorized to run any code that may be contained within it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014058Z" creationid="shibukawa.yoshiki" creationdate="20150416T014058Z">
        <seg>文字列の中にどのような処理も可能なコードがある可能性があり、それに実行権限を与えることを認める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>added &lt;c0&gt;catch&lt;/c0&gt; to promises</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140053Z" creationid="shibukawa.yoshiki" creationdate="20160412T140040Z">
        <seg>&lt;c0&gt;catch&lt;/c0&gt;をpromiseに追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after saving the contact, it reloads the list (&lt;c0&gt;.then(update.bind(this))&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003126Z" creationid="shibukawa.yoshiki" creationdate="20150502T003126Z">
        <seg>保存が完了したらリストのリロードをする(&lt;c0&gt;.then(update.bind(this))&lt;/c0&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an anchor element &lt;c0&gt;&lt;a&gt;&lt;/c0&gt; with an &lt;c1&gt;href&lt;/c1&gt; attribute that points to a route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172255Z" creationid="shibukawa.yoshiki" creationdate="20150414T172255Z">
        <seg>ラウトを指す&lt;c1&gt;href&lt;/c1&gt;属性を持つ&lt;c0&gt;&lt;a&gt;&lt;/c0&gt;エレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an object that retains its state across redraws</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140024Z" creationid="shibukawa.yoshiki" creationdate="20150502T140024Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>becomes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002445Z" creationid="shibukawa.yoshiki" creationdate="20150409T002445Z">
        <seg>変更後:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("list of users:", users)
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T053544Z" creationid="shibukawa.yoshiki" creationdate="20170220T053544Z">
        <seg>console.log("ユーザーのリスト:", users)
})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloaded the div");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124516Z" creationid="shibukawa.yoshiki" creationdate="20150502T124516Z">
        <seg>console.log("divをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloaded!")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092744Z" creationid="shibukawa.yoshiki" creationdate="20150502T092744Z">
        <seg>console.log("アンロード!")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloading home component");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135632Z" creationid="shibukawa.yoshiki" creationdate="20150502T135632Z">
        <seg>console.log("ホームをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloading my component");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091634Z" creationid="shibukawa.yoshiki" creationdate="20150502T091634Z">
        <seg>console.log("MyComponentコンポーネントを削除しています");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log(data) // note: not a getter-setter
}, 1000)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T045445Z" creationid="shibukawa.yoshiki" creationdate="20170201T045445Z">
        <seg>console.log(data) // note: これはゲッター・セッターではありません
}, 1000)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log(users[0].name) // logs a name
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T004154Z" creationid="shibukawa.yoshiki" creationdate="20170220T004154Z">
        <seg>console.log(users[0].name) // 名前をログに出力
})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.warn('ERROR: You need jquery and Select2 in the page');</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160101T132957Z" creationid="shibukawa.yoshiki" creationdate="20160101T132957Z">
        <seg>console.warn('ERROR: ページにjqueryとSelect2がロードされていません');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctrl.contact = m.prop(new Contact()) //reset to empty contact</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141941Z" creationid="shibukawa.yoshiki" creationdate="20160412T141941Z">
        <seg>ctrl.contact = m.prop(new Contact()) //連絡先を空にリセットする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defining a list of routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162201Z" creationid="shibukawa.yoshiki" creationdate="20150409T162201Z">
        <seg>ラウトのリストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else m.redraw.strategy("none") //otherwise, ignore
}})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150258Z" creationid="shibukawa.yoshiki" creationdate="20150416T150258Z">
        <seg>else m.redraw.strategy("none") //そうでなければ無視する
}})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>errors thrown from the exception monitor no longer freeze redrawing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140331Z" creationid="shibukawa.yoshiki" creationdate="20160412T140331Z">
        <seg>例外モニターの中から例外を投げても、再描画をフリーズすることがなくなった</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix ReferenceError when calling an event handler via mithril-query without an event argument</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160425T035843Z" creationid="shibukawa.yoshiki" creationdate="20160425T035843Z">
        <seg>event引数を与えずにmithril-query経由でイベントハンドラを呼ぶとReferenceErrorが発生する問題を修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix active form element syncing &lt;a0&gt;#691&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T052053Z" creationid="shibukawa.yoshiki" creationdate="20170201T052053Z">
        <seg>アクティブなフォーム要素の同期の修正&lt;a0&gt;#691&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix controller prototype inheritance in component controllers</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140430Z" creationid="shibukawa.yoshiki" creationdate="20160412T140430Z">
        <seg>コンポーネントコントローラ内でのコントローラプロトタイプの継承を修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix diff edge case in &lt;c0&gt;&lt;select&gt;&lt;/c0&gt; &lt;a1&gt;#569&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141414Z" creationid="shibukawa.yoshiki" creationdate="20160412T141414Z">
        <seg>&lt;c0&gt;&lt;select&gt;&lt;/c0&gt;のエッジケースの問題を修正 &lt;a1&gt;#569&lt;/a1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix double unloading issue &lt;a0&gt;#931&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135431Z" creationid="shibukawa.yoshiki" creationdate="20160412T135431Z">
        <seg>二重のアンロードの問題の修正 &lt;a0&gt;#931&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix edge case with falsy keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140403Z" creationid="shibukawa.yoshiki" creationdate="20160412T140403Z">
        <seg>偽のキーのエッジケースの問題を修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix handling of read-only attributes &lt;a0&gt;#925&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135411Z" creationid="shibukawa.yoshiki" creationdate="20160412T135411Z">
        <seg>読み込み専用属性の取り扱いの修正&lt;a0&gt;#925&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix regression that caused errors to be swallowed in promises returned by m.request &lt;a0&gt;#968&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160425T035806Z" creationid="shibukawa.yoshiki" creationdate="20160425T035806Z">
        <seg>m.requestの返り値のpromiseがエラーを飲み込んでしまうというリグレッションの修正&lt;a0&gt;#968&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix regression that prevented string keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135339Z" creationid="shibukawa.yoshiki" creationdate="20160412T135339Z">
        <seg>文字列キーの動作を無効にしていたリグレッションの修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix return value of &lt;c0&gt;parseQueryString&lt;/c0&gt; if input is empty string</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140655Z" creationid="shibukawa.yoshiki" creationdate="20160412T140655Z">
        <seg>入力が空文字列だった場合の&lt;c0&gt;parseQueryString&lt;/c0&gt;の返り値の修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fix support for arrays in template compiler</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T141429Z" creationid="shibukawa.yoshiki" creationdate="20160412T141429Z">
        <seg>テンプレートコンパイラの配列サポートを修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fixed native promise absorption in &lt;c0&gt;m.prop&lt;/c0&gt; &lt;a1&gt;#1076&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T052314Z" creationid="shibukawa.yoshiki" creationdate="20170201T052314Z">
        <seg>ネイティブのPromiseを&lt;c0&gt;m.prop&lt;/c0&gt;に渡した時のデータの吸収を修正 &lt;a1&gt;#1076&lt;/a1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://en.wikipedia.org/wiki/Observer_pattern</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025157Z" creationid="shibukawa.yoshiki" creationdate="20150502T025157Z">
        <seg>http://ja.wikipedia.org/wiki/Observer_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://mithril.js.org/archive/v0.2.5/change-log.html</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T052624Z" creationid="shibukawa.yoshiki" creationdate="20170201T051834Z">
        <seg>./archive/v0.2.5/index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024724Z" creationid="shibukawa.yoshiki" creationdate="20170220T024724Z">
        <seg>https://developer.mozilla.org/ja/docs/Web/API/Fetch_API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://developer.mozilla.org/en/docs/Web/API/File</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155333Z" creationid="shibukawa.yoshiki" creationdate="20170219T155333Z">
        <seg>https://developer.mozilla.org/ja/docs/Web/API/File</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://developer.mozilla.org/en/docs/Web/API/FormData</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T155526Z" creationid="shibukawa.yoshiki" creationdate="20170219T155526Z">
        <seg>https://developer.mozilla.org/ja/docs/Web/API/FormData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T060659Z" creationid="shibukawa.yoshiki" creationdate="20170220T060659Z">
        <seg>https://ja.wikipedia.org/wiki/Hypertext_Transfer_Protocol#.E3.83.A1.E3.82.BD.E3.83.83.E3.83.89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://en.wikipedia.org/wiki/Identity_function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T070329Z" creationid="shibukawa.yoshiki" creationdate="20170219T070329Z">
        <seg>https://ja.wikipedia.org/wiki/%E6%81%92%E7%AD%89%E5%86%99%E5%83%8F</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://en.wikipedia.org/wiki/Representational_state_transfer</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024445Z" creationid="shibukawa.yoshiki" creationdate="20170220T024445Z">
        <seg>https://ja.wikipedia.org/wiki/REST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://en.wikipedia.org/wiki/Service-oriented_architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T024521Z" creationid="shibukawa.yoshiki" creationdate="20170220T024521Z">
        <seg>https://ja.wikipedia.org/wiki/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E6%8C%87%E5%90%91%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!isInit) ctx.data = "foo" //we wish to initialize this only once, even if the route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130727Z" creationid="shibukawa.yoshiki" creationdate="20150502T130727Z">
        <seg>if (!isInit) ctx.data = "foo" //この初期化はラウトの変更に関わらず一度だけ実行したい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!user.isAdmin) throw new Error("Sorry, you don't have permissions")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173404Z" creationid="shibukawa.yoshiki" creationdate="20150415T173404Z">
        <seg>if (!user.isAdmin) throw new Error("もうしわけありません。権限がありません。")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (e.keyCode == 13) vm.save() //do things and re-render only if the `enter` key was pressed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150248Z" creationid="shibukawa.yoshiki" creationdate="20150416T150248Z">
        <seg>if (e.keyCode == 13) vm.save() //`enter`キーが押された時だけ再描画をする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ignore url interpolations without value in m.request &lt;a0&gt;#1039&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T052228Z" creationid="shibukawa.yoshiki" creationdate="20170201T052228Z">
        <seg>m.requestで値を伴わない項目をURLに挿入せずに無視する&lt;a0&gt;#1039&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>improvements and fixes in the documentation and wiki</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140118Z" creationid="shibukawa.yoshiki" creationdate="20160412T140046Z">
        <seg>
ドキュメントとWikiの改善や修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in model-level methods if client-side processing is needed to make the data useful for a controller or view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175047Z" creationid="shibukawa.yoshiki" creationdate="20150414T175047Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in order to avoid the full-page recreation when changing routes, for the sake of performance of global 3rd party components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130757Z" creationid="shibukawa.yoshiki" creationdate="20150502T130757Z">
        <seg>ラウト変更時に全画面の再構築を避けて、サードパーティのコンポーネントのパフォーマンス劣化を避ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in order to prevent redraw when dealing with &lt;c0&gt;keypress&lt;/c0&gt; events where the event's keyCode is not of interest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144741Z" creationid="shibukawa.yoshiki" creationdate="20150416T144741Z">
        <seg>&lt;c0&gt;keypress&lt;/c0&gt;イベントで受け取ったキーコードが処理対象外だったので再描画を避けたい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller layer: to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174946Z" creationid="shibukawa.yoshiki" creationdate="20150414T174946Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174942Z" creationid="shibukawa.yoshiki" creationdate="20150414T174942Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller, to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175057Z" creationid="shibukawa.yoshiki" creationdate="20150414T175057Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller, to redirect after a model service resolves.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175053Z" creationid="shibukawa.yoshiki" creationdate="20150414T175053Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174936Z" creationid="shibukawa.yoshiki" creationdate="20150414T174936Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it integrates to the &lt;a0&gt;Service Worker API&lt;/a0&gt;, which provides an extra layer of control over how and when network requests happen.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034051Z" creationid="shibukawa.yoshiki" creationdate="20170220T034051Z">
        <seg>また、これは &lt;a0&gt;Service Worker API&lt;/a0&gt;と統合されています。これはネットワークリクエストを制御する追加のレイヤーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it provides a streaming API (in the "video streaming" sense, not in the reactive programming sense), which enables better latency and memory consumption for very large responses (at the cost of code complexity).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T034024Z" creationid="shibukawa.yoshiki" creationdate="20170220T034024Z">
        <seg>fetch()はストリーミングAPIを提供しています。これは「ビデオストリーミング」と同じ用法であって、リアクティブプログラミング用語とは異なります。この機能を使用すると、少ないコードの行数と複雑さで、よりレイテンシーが優れていて、消費メモリが少ないコードが書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>item.foreach(doSomething) //programmer error: typo will throw runtime error to the console</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173033Z" creationid="shibukawa.yoshiki" creationdate="20150415T173033Z">
        <seg>item.foreach(doSomething) //プログラマのエラー: タイプミスによって実行時エラーがログに出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jQuery is ubiquitous and has a large ecosystem, but it's not an MVC framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015221Z" creationid="shibukawa.yoshiki" creationdate="20150420T015221Z">
        <seg>jQueryはどこでも使われ、巨大なエコシステムを構築しましたが、それ自身はMVCフレームワークではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>large refactor to take better advantage of Chrome js optimizations and improve source code readability (thanks to @isiahmeadows)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T140032Z" creationid="shibukawa.yoshiki" creationdate="20160412T135738Z">
        <seg>ChromeのJavaScriptオプティマイザの恩恵を得られるように改善し、ソースコードの読みやすさを改善するリファクタリングを行った(@isiahmeadows ありがとう)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m(".container"); //yields &lt;div class="container"&gt;&lt;/div&gt;

m("#layout"); //yields &lt;div id="layout"&gt;&lt;/div&gt;

m("a[name=top]"); //yields &lt;a name="top"&gt;&lt;/a&gt;

m("[contenteditable]"); //yields &lt;div contenteditable&gt;&lt;/div&gt;

m("a#google.external[href='http://google.com']", "Google"); //yields &lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000407Z" creationid="shibukawa.yoshiki" creationdate="20150413T000407Z">
        <seg>m(".container"); //&lt;div class="container"&gt;&lt;/div&gt;を作成

m("#layout"); //&lt;div id="layout"&gt;&lt;/div&gt;を作成

m("a[name=top]"); //&lt;a name="top"&gt;&lt;/a&gt;を作成

m("[contenteditable]"); //&lt;div contenteditable&gt;&lt;/div&gt;を作成

m("a#google.external[href='http://google.com']", "Google"); //&lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("a[href='/Home']", {oncreate: m.route.link}, "Go to home page")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T112131Z" creationid="shibukawa.yoshiki" creationdate="20170206T112131Z">
        <seg>m("a[href='/Home']", {oncreate: m.route.link}, "ホームに戻る")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("a[href=/]", {oncreate: m.route.link}, "Home"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100927Z" creationid="shibukawa.yoshiki" creationdate="20170207T100927Z">
        <seg>m("a[href=/]", {oncreate: m.route.link}, "ホーム"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("a[href=/page1]", {oncreate: m.route.link}, "Page 1"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100935Z" creationid="shibukawa.yoshiki" creationdate="20170207T100935Z">
        <seg>m("a[href=/page1]", {oncreate: m.route.link}, "ページ 1"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("br"); //yields a virtual element that represents &lt;br&gt;

m("div", "Hello"); //yields &lt;div&gt;Hello&lt;/div&gt;

m("div", {class: "container"}, "Hello"); //yields &lt;div class="container"&gt;Hello&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000106Z" creationid="shibukawa.yoshiki" creationdate="20150413T000040Z">
        <seg>m("br"); //&lt;br&gt;を表現する仮想エレメントを作成

m("div", "Hello"); //&lt;div&gt;Hello&lt;/div&gt;を作成

m("div", {class: "container"}, "Hello"); //&lt;div class="container"&gt;Hello&lt;/div&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", "A button"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030603Z" creationid="shibukawa.yoshiki" creationdate="20170131T030603Z">
        <seg>m("button", "ボタン"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", "A button"),
]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030256Z" creationid="shibukawa.yoshiki" creationdate="20170131T030256Z">
        <seg>m("button", "ボタン"),
]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", "A button"),
])</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030340Z" creationid="shibukawa.yoshiki" creationdate="20170131T030340Z">
        <seg>m("button", "ボタン"),
])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", "Add"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013733Z" creationid="shibukawa.yoshiki" creationdate="20150408T013733Z">
        <seg>m("button", "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", {onclick: function() {count++}}, count + " clicks"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030925Z" creationid="shibukawa.yoshiki" creationdate="20170131T030907Z">
        <seg>m("button", {onclick: function() {count++}}, count + " クリック"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152603Z" creationid="shibukawa.yoshiki" creationdate="20150408T152603Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153600Z" creationid="shibukawa.yoshiki" creationdate="20150408T153600Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button.button[type=submit]", "Save"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120725Z" creationid="shibukawa.yoshiki" creationdate="20170221T120725Z">
        <seg>m("button.button[type=submit]", "保存"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002039Z" creationid="shibukawa.yoshiki" creationdate="20150502T002039Z">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013724Z" creationid="shibukawa.yoshiki" creationdate="20150502T013724Z">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "Upload")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034926Z" creationid="shibukawa.yoshiki" creationdate="20150502T034926Z">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "アップロード")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onkeypress: save}, "Save"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144902Z" creationid="shibukawa.yoshiki" creationdate="20150416T144902Z">
        <seg>m("button[type=button]", {onkeypress: save}, "保存"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("canvas", {config: draw})
]

//this creates the canvas element, and therefore, `isInitialized` is false
m.render(document.body, view);

//here, isInitialized is `true`
m.render(document.body, view);</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123656Z" creationid="shibukawa.yoshiki" creationdate="20150413T123637Z">
        <seg>m("canvas", {config: draw})
]

//このメソッド呼び出しをすると、canvasエレメントが作られ、`initialized`がfalseに設定される
m.render(document.body, view);

//ここではisInitializedは`true`になる
m.render(document.body, view);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", "&amp;times;") //becomes &lt;div&gt;&amp;amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020917Z" creationid="shibukawa.yoshiki" creationdate="20150413T020917Z">
        <seg>m("div", "&amp;times;") //&lt;div&gt;&amp;amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", "loading contacts...") //waiting for promise to resolve</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T142023Z" creationid="shibukawa.yoshiki" creationdate="20160412T142023Z">
        <seg>m("div", "連絡先をロード中...") //Promiseが解決されるのを待つ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", data) : null&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121036Z" creationid="shibukawa.yoshiki" creationdate="20150502T121036Z">
        <seg>m("div", data) : null&lt;/c3&gt;)を行う方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", m.trust("&amp;times;")) //becomes &lt;div&gt;&amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020953Z" creationid="shibukawa.yoshiki" creationdate="20150413T020953Z">
        <seg>m("div", m.trust("&amp;times;")) //&lt;div&gt;&amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {"data-index": 1}); //yields &lt;div data-index="1"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013113Z" creationid="shibukawa.yoshiki" creationdate="20150413T013113Z">
        <seg>m("div", {"data-index": 1}); //&lt;div data-index="1"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {class: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("div", {className: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("button", {onclick: alert}); //yields &lt;button&gt;&lt;/button&gt;, which alerts its event argument when clicked

//note this uses the Javascript syntax (uppercase "O") for `readonly`
//in order to set the boolean javascript property instead of the HTML attribute
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//using the HTML attribute name will call `setAttribute`, which may not be what you want
m("input", {readonly: false}); //yields &lt;input readonly="false" /&gt;, which is still readonly</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013004Z" creationid="shibukawa.yoshiki" creationdate="20150413T012502Z">
        <seg>m("div", {class: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("div", {className: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("button", {onclick: alert}); //押されるとアラートを表示する&lt;button&gt;&lt;/button&gt;を生成

//`readonly`の設定にJavaScript文法(大文字の"O"になる)を使用
//HTML属性とは異なり、JavaScriptのプロパティではboolean型を使用する
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//HTML属性名は`setAttribute`が使われるため期待と異なることがある
m("input", {readonly: false}); //&lt;input readonly="false" /&gt;は属性が存在するので読み込み専用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {style: {border: "1px solid red"}}); //yields &lt;div style="border:1px solid red;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013140Z" creationid="shibukawa.yoshiki" creationdate="20150413T013140Z">
        <seg>m("div", {style: {border: "1px solid red"}}); //&lt;div style="border:1px solid red;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {style: {textAlign: "center"}}); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;
m("div", {style: {cssFloat: "left"}}); //yields &lt;div style="float:left;"&gt;&lt;/div&gt;

//this does not work
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013720Z" creationid="shibukawa.yoshiki" creationdate="20150413T013711Z">
        <seg>m("div", {style: {textAlign: "center"}}); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成
m("div", {style: {cssFloat: "left"}}); //&lt;div style="float:left;"&gt;&lt;/div&gt;を生成

//これは動作しない
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div[style='text-align:center']"); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013936Z" creationid="shibukawa.yoshiki" creationdate="20150413T013936Z">
        <seg>m("div[style='text-align:center']"); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", "Editing " + vnode.attrs.id)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T053723Z" creationid="shibukawa.yoshiki" creationdate="20170208T053723Z">
        <seg>m("h1", vnode.attrs.id + "を編集中")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", "Home")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100658Z" creationid="shibukawa.yoshiki" creationdate="20170207T100658Z">
        <seg>m("h1", "ホーム")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", "Page 1")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170207T100707Z" creationid="shibukawa.yoshiki" creationdate="20170207T100707Z">
        <seg>m("h1", "ページ 1")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", "Uploader demo"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034737Z" creationid="shibukawa.yoshiki" creationdate="20150502T034737Z">
        <seg>m("h1", "アップローダデモ"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", {class: "title"}, "My first app")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030149Z" creationid="shibukawa.yoshiki" creationdate="20170131T030149Z">
        <seg>m("h1", {class: "title"}, "最初のMithrilアプリケーション")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", {class: "title"}, "My first app"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030249Z" creationid="shibukawa.yoshiki" creationdate="20170131T030249Z">
        <seg>m("h1", {class: "title"}, "最初のMithrilアプリケーション"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("input", {config: plugin}) //assuming `plugin` initializes a 3rd party library</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144635Z" creationid="shibukawa.yoshiki" creationdate="20150416T144635Z">
        <seg>m("input", {config: plugin}) //`plugin`がサードパーティのライブラリを初期化するものとする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("input.input[placeholder=Last name]"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120715Z" creationid="shibukawa.yoshiki" creationdate="20170221T120715Z">
        <seg>m("input.input[placeholder=名字]"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("input.input[type=text][placeholder=First name]"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120647Z" creationid="shibukawa.yoshiki" creationdate="20170221T120647Z">
        <seg>m("input.input[type=text][placeholder=名前]"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "Email"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013644Z" creationid="shibukawa.yoshiki" creationdate="20150502T013644Z">
        <seg>m("label", "Eメール"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "Name"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013638Z" creationid="shibukawa.yoshiki" creationdate="20150502T013638Z">
        <seg>m("label", "名前"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "User:"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045319Z" creationid="shibukawa.yoshiki" creationdate="20150502T045319Z">
        <seg>m("label", "ユーザ:"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label.label", "First name"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120719Z" creationid="shibukawa.yoshiki" creationdate="20170221T120719Z">
        <seg>m("label.label", "名前"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label.label", "Last name"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170221T120703Z" creationid="shibukawa.yoshiki" creationdate="20170221T120703Z">
        <seg>m("label.label", "名字"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("li", "item 1"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000609Z" creationid="shibukawa.yoshiki" creationdate="20150413T000609Z">
        <seg>m("li", "アイテム 1"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("li", "item 2"),
]);

/*
yields
&lt;ul&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000638Z" creationid="shibukawa.yoshiki" creationdate="20150413T000614Z">
        <seg>m("li", "アイテム 2"),
]);

/*
これが作成される:
&lt;ul&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("p", "Drag and drop a file below.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034853Z" creationid="shibukawa.yoshiki" creationdate="20150502T034853Z">
        <seg>m("p", "ファイルをここにドロップしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("td", "task description"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004223Z" creationid="shibukawa.yoshiki" creationdate="20150408T004223Z">
        <seg>m("td", "タスクの説明"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of everything</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010827Z" creationid="shibukawa.yoshiki" creationdate="20150412T010827Z">
        <seg>m.endComputation(); //すべての処理の後に`endComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of the callback</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193004Z" creationid="shibukawa.yoshiki" creationdate="20150411T193004Z">
        <seg>m.endComputation(); //`endComputation`はコールバックの最後で呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193139Z" creationid="shibukawa.yoshiki" creationdate="20150411T193139Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175402Z" creationid="shibukawa.yoshiki" creationdate="20150501T175402Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //redraw regardless of whether `doStuff` threw errors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153543Z" creationid="shibukawa.yoshiki" creationdate="20150416T153543Z">
        <seg>m.endComputation(); //`doStuff`が例外を投げたとしても再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw() // schedules a redraw on the next requestAnimationFrame tick</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121423Z" creationid="shibukawa.yoshiki" creationdate="20170131T121423Z">
        <seg>m.redraw() // 次のrequestAnimationFrame呼び出し時に再描画が行われるように予約する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw() // tell Mithril that data changed and a re-render is needed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170219T191238Z" creationid="shibukawa.yoshiki" creationdate="20170219T191238Z">
        <seg>m.redraw() // Mithrilに再描画が必要なことを伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw(true) // force</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151342Z" creationid="shibukawa.yoshiki" creationdate="20150416T151342Z">
        <seg>m.redraw(true) // 強制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw(true) // redraws immediately &amp; synchronously</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121355Z" creationid="shibukawa.yoshiki" creationdate="20170131T121355Z">
        <seg>m.redraw(true) // 即座に再描画を行って同期する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render(document.body, m("br")); //puts a &lt;br&gt; in &lt;body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000216Z" creationid="shibukawa.yoshiki" creationdate="20150413T000216Z">
        <seg>m.render(document.body, m("br")); //&lt;br&gt;タグを&lt;body&gt;に出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render(root, "My first app")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030017Z" creationid="shibukawa.yoshiki" creationdate="20170131T030017Z">
        <seg>m.render(root, "最初のMithrilアプリケーション")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render(root, m("h1", "My first app"))</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030032Z" creationid="shibukawa.yoshiki" creationdate="20170131T030032Z">
        <seg>m.render(root, m("h1", "最初のMithrilアプリケーション"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.request now has a &lt;c0&gt;callbackName&lt;/c0&gt; option to specify the name of the javascript function that gets called on JSONP response &lt;a1&gt;#1072&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T052058Z" creationid="shibukawa.yoshiki" creationdate="20170201T052023Z">
        <seg>m.requestに&lt;c0&gt;callbackName&lt;/c0&gt;オプションが追加されました。JSONPレスポンス時に呼び出すJavaScript関数名を指定します&lt;a1&gt;#1072&lt;/a1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before everything else</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010808Z" creationid="shibukawa.yoshiki" creationdate="20150412T010808Z">
        <seg>m.startComputation(); //すべての処理の前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous AJAX request</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010127Z" creationid="shibukawa.yoshiki" creationdate="20150412T010127Z">
        <seg>m.startComputation(); //`startComputation`は非同期のAJAXリクエスト前に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous `setTimeout`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192949Z" creationid="shibukawa.yoshiki" creationdate="20150411T192949Z">
        <seg>m.startComputation(); //`startComputation`は非同期の`setTimeout`の前に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous synchronization method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010333Z" creationid="shibukawa.yoshiki" creationdate="20150412T010333Z">
        <seg>m.startComputation(); //非同期の同期メソッドの前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call before everything else in the event handler</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193124Z" creationid="shibukawa.yoshiki" creationdate="20150411T193124Z">
        <seg>m.startComputation(); //イベントハンドラの先頭で、他の処理よりも先に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>making links in templates routed transparently and unobtrusively</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162425Z" creationid="shibukawa.yoshiki" creationdate="20150409T162425Z">
        <seg>テンプレート内でリンクを作ると、透過的であまり主張しないリンクが作成できる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on initialization, it fetches the list of contacts (&lt;c0&gt;this.contacts = Contact.list&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002640Z" creationid="shibukawa.yoshiki" creationdate="20150502T002640Z">
        <seg>初期化時に連絡先のリストを取得します(&lt;c0&gt;this.contacts = Contact.list()&lt;/c0&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onclick: ctrl.increment //view calls controller method on click</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071323Z" creationid="shibukawa.yoshiki" creationdate="20150502T071323Z">
        <seg>onclick: ctrl.increment //ビューはクリック時にコントローラメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performance improvements in IE (thanks to @gyandeeps)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170201T051936Z" creationid="shibukawa.yoshiki" creationdate="20170201T051936Z">
        <seg>IEのパフォーマンス改善 (thanks to @gyandeeps)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>previous commit is tagged using new version number</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170220T054401Z" creationid="shibukawa.yoshiki" creationdate="20170220T054401Z">
        <seg>１つ前のコミットに対し、新しいバージョン番号でタグ付けを行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>programmatically redirecting between routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162257Z" creationid="shibukawa.yoshiki" creationdate="20150409T162257Z">
        <seg>ソースコードによる、ラウト間のリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redirects to &lt;c0&gt;http://server/#/dashboard/marysue&lt;/c0&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013048Z" creationid="shibukawa.yoshiki" creationdate="20150410T013048Z">
        <seg>このコードを実行すると、&lt;c0&gt;http://server/#/dashboard/marysue&lt;/c0&gt;にリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return "Are you sure you want to leave?"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092416Z" creationid="shibukawa.yoshiki" creationdate="20150502T092416Z">
        <seg>return "本当に移動しますか？"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return deferred.promise;
};

//asynchronous consumer
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - because `deferred.resolve` has not been called yet

setTimeout(function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135253Z" creationid="shibukawa.yoshiki" creationdate="20150415T135234Z">
        <seg>return deferred.promise;
};

//非同期の消費者
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - `deferred.resolve`がまだ呼ばれてない

setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return description;
}

//make it serializable
this.description.toJSON = function() {return description}

//set the value
this.description(data.description)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002550Z" creationid="shibukawa.yoshiki" creationdate="20150409T002550Z">
        <seg>return description;
}

//シリアライズ可能にする
this.description.toJSON = function() {return description}

//値を設定
this.description(data.description)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("a", {href: "#!/hello"}, "Enter!")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T031934Z" creationid="shibukawa.yoshiki" creationdate="20170131T031934Z">
        <seg>return m("a", {href: "#!/hello"}, "ようこそ!")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("h1", ctrl.greeting)
}

//render
m.mount(document.body, {controller: controller, view: view}) // renders &lt;h1&gt;Hello&lt;/h1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071612Z" creationid="shibukawa.yoshiki" creationdate="20150502T071612Z">
        <seg>return m("h1", ctrl.greeting)
}

//レンダリング
m.mount(document.body, {controller: controller, view: view}) // 表示: &lt;h1&gt;Hello&lt;/h1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("h1", {config: Component1.config}, "test") //assume all routes display the same thing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130704Z" creationid="shibukawa.yoshiki" creationdate="20150502T130704Z">
        <seg>return m("h1", {config: Component1.config}, "test") //すべてのラウトが同じコンテンツを表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//a data store
var name = m.prop("")

//binding the data store in a view
input(name)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015709Z" creationid="shibukawa.yoshiki" creationdate="20150413T015709Z">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインディング
input(name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), `users` will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170827Z" creationid="shibukawa.yoshiki" creationdate="20150410T170827Z">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` はUserインスタンスのリストを格納します
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return value
}

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130409Z" creationid="shibukawa.yoshiki" creationdate="20150410T130334Z">
        <seg>return value
}

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return vm
}())

//the controller defines what part of the model is relevant for the current page
//in our case, there's only one view-model that handles everything
todo.controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163341Z" creationid="shibukawa.yoshiki" creationdate="20150408T163303Z">
        <seg>return vm
}())

//コントローラは、モデルの中のどの部分が、現在のページと関連するのかを定義している
//この場合は１つのビュー・モデルですべてを取り仕切っている
todo.controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return vnode // equivalent to m(Home)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T064837Z" creationid="shibukawa.yoshiki" creationdate="20170208T064837Z">
        <seg>return vnode // m(Home)と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//a data store
var name = m.prop("")

//binding the data store in a view
m("input", binds(name))</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015607Z" creationid="shibukawa.yoshiki" creationdate="20150413T015549Z">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインド
m("input", binds(name))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a promise that can bind callbacks which get called on completion of the AJAX request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014442Z" creationid="shibukawa.yoshiki" creationdate="20150415T014442Z">
        <seg>AJAXリクエストが完了したときに呼ばれるコールバックをバインドすることが可能なpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172212Z" creationid="shibukawa.yoshiki" creationdate="20150414T172212Z">
        <seg>現在アクティブなラウトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>revert &lt;c0&gt;finally&lt;/c0&gt; because it's not in the ES6 promise spec</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135552Z" creationid="shibukawa.yoshiki" creationdate="20160412T135552Z">
        <seg>ES6のPromiseの仕様にないため、&lt;c0&gt;finally&lt;/c0&gt;を戻した</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>revert regressions from 0.2.1 refactor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20160412T135741Z" creationid="shibukawa.yoshiki" creationdate="20160412T135454Z">
        <seg>0.2.1のリファクタリングによるリグレッションを修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sanitizing the markup contained in the string, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013916Z" creationid="shibukawa.yoshiki" creationdate="20150416T013916Z">
        <seg>サニタイズされたマークアップが文字列の中に含まれる、もしくは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state.term = vnode.attrs.term || "" // populated from the `history.state` property if the user presses the back button</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T062013Z" creationid="shibukawa.yoshiki" creationdate="20170208T062013Z">
        <seg>state.term = vnode.attrs.term || "" // ユーザーが戻るボタンを操作したときは`history.state`プロパティを復元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temp: m.prop(10) // kelvin</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081105Z" creationid="shibukawa.yoshiki" creationdate="20150502T081105Z">
        <seg>temp: m.prop(10) // ケルビン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the list of HTML attributes changes, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135406Z" creationid="shibukawa.yoshiki" creationdate="20150413T135406Z">
        <seg>HTML属性のリストが変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the method does not run if this flag is set to true.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172328Z" creationid="shibukawa.yoshiki" creationdate="20150414T172328Z">
        <seg>このフラグがtrueの場合はこのメソッドは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the tag name changes, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135356Z" creationid="shibukawa.yoshiki" creationdate="20150413T135356Z">
        <seg>タグ名が変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of the element's id attribute changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135422Z" creationid="shibukawa.yoshiki" creationdate="20150413T135422Z">
        <seg>エレメントのid属性が変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //slice the data in some way</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084532Z" creationid="shibukawa.yoshiki" creationdate="20150502T084532Z">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //何らかのルールでデータの一部を切り出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150427Z" creationid="shibukawa.yoshiki" creationdate="20150407T150427Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはTodoのリスト
todo.TodoList = Array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;

//the view-model tracks a running list of todos,
//stores a description for new todos before they are created
//and takes care of the logic surrounding when adding is permitted
//and clearing the input after adding a todo to the list
todo.vm = (function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162616Z" creationid="shibukawa.yoshiki" creationdate="20150408T162616Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはtodoの配列
todo.TodoList = Array;

//ビュー・モデルは表示されているTodoのリストを管理し、
//作成が完了する前のTodoの説明を格納したり、
//作成が可能かどうかを判定するロジックや、
//Todoが追加された後にテキスト入力をクリアする責務を持つ
todo.vm = (function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>throw new Error("Server is offline")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181844Z" creationid="shibukawa.yoshiki" creationdate="20150414T181844Z">
        <seg>throw new Error("サーバがオフラインです")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>todo.vm.init()
}

//here's the view
todo.view = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163358Z" creationid="shibukawa.yoshiki" creationdate="20150408T163358Z">
        <seg>todo.vm.init()
}

//これがビュー
todo.view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>todo.vm.init();

todo.vm.description(); // empty string
m.render(document, todo.view()); // input is blank

todo.vm.description("Write code"); //set the description in the controller
m.render(document, todo.view()); // input now says "Write code"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015242Z" creationid="shibukawa.yoshiki" creationdate="20150408T015204Z">
        <seg>todo.vm.init();

todo.vm.description(); // 空文字列
m.render(document, todo.view()); // テキスト入力もブランク

todo.vm.description("コードを書く"); // ビュー・モデルのdescriptionに値を設定
m.render(document, todo.view()); // テキスト入力に「コードを書く」が表示される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var app = {}

//here's an example plugin that determines whether data has changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124526Z" creationid="shibukawa.yoshiki" creationdate="20150416T124526Z">
        <seg>var app = {}

//どこのデータが変更されているかを決定するサンプルプラグイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var count = 0 // added a variable

var Hello = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T030846Z" creationid="shibukawa.yoshiki" creationdate="20170131T030846Z">
        <seg>var count = 0 // 変数を追加
var Hello = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//wait for next tick for Q's A+ compliant promise to actually resolve
setTimeout(function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135547Z" creationid="shibukawa.yoshiki" creationdate="20150414T135547Z">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//QのA+互換のPromiseが次のtickで解決するのを待つ
setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var isDone = myTask.done(); //isDone == false

//mark as done
myTask.done(true); //true

//now it's done
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150958Z" creationid="shibukawa.yoshiki" creationdate="20150407T150958Z">
        <seg>var isDone = myTask.done(); //isDone == false

//完了にする
myTask.done(true); //true

//ここでは完了している
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var myTask = new todo.Todo({description: "Write code"});

//read the description
myTask.description(); //Write code

//is it done?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150920Z" creationid="shibukawa.yoshiki" creationdate="20150407T150920Z">
        <seg>var myTask = new todo.Todo({description: "コードを書く"});

//descriptionを取得する
myTask.description(); //コードを書く

//完了しているか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var querystring = m.buildQueryString({a: 1, b: 2})

// querystring is "a=1&amp;b=2"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133322Z" creationid="shibukawa.yoshiki" creationdate="20170206T133322Z">
        <seg>var querystring = m.buildQueryString({a: 1, b: 2})

// クエリー文字列は"a=1&amp;b=2"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var querystring = m.buildQueryString({a: ["hello", "world"]})

// querystring is "a[0]=hello&amp;a[1]=world"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170206T133448Z" creationid="shibukawa.yoshiki" creationdate="20170206T133448Z">
        <seg>var querystring = m.buildQueryString({a: ["hello", "world"]})

// クエリー文字列は"a[0]=hello&amp;a[1]=world"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var state = this  // this is bound to vnode.state by default</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121659Z" creationid="shibukawa.yoshiki" creationdate="20170131T121659Z">
        <seg>var state = this  // thisはデフォルトでvnode.stateがバインドされています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var state = this // this is bound to vnode.state by default</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170131T121733Z" creationid="shibukawa.yoshiki" creationdate="20170131T121733Z">
        <seg>var state = this  // thisはデフォルトでvnode.stateがバインドされています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var todo = {};

//for simplicity, we use this component to namespace the model classes

//the Todo class has two properties
todo.Todo = function(data) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040737Z" creationid="shibukawa.yoshiki" creationdate="20150502T040737Z">
        <seg>var todo = {};

//例をシンプルにするために、このコンポーネントをモデルクラスの名前空間として利用する

//Todoクラスはプロパティを2つ持つ
todo.Todo = function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//the `transport` getter-setter contains an instance of XMLHttpRequest
transport().abort();</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182405Z" creationid="shibukawa.yoshiki" creationdate="20150414T182405Z">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//`transport` getter-setterにはXMLHttpRequestのインスタンスが含まれる。
transport().abort();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020018Z" creationid="shibukawa.yoshiki" creationdate="20150410T020018Z">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.prop([]); //default value
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020302Z" creationid="shibukawa.yoshiki" creationdate="20150410T020302Z">
        <seg>var users = m.prop([]); //デフォルト値
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.request({method: "GET", url: "/user"});

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015137Z" creationid="shibukawa.yoshiki" creationdate="20150410T015137Z">
        <seg>var users = m.request({method: "GET", url: "/user"});

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "Add")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151232Z" creationid="shibukawa.yoshiki" creationdate="20150408T151232Z">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>view: function() {}
};

//go to the default route (home)
m.route(document.body, "/", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135334Z" creationid="shibukawa.yoshiki" creationdate="20150502T135334Z">
        <seg>view: function() {}
};

//デフォルトラウト(home)に移動
m.route(document.body, "/", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when &lt;c0&gt;save&lt;/c0&gt; is called, it saves a contact (&lt;c1&gt;Contact.save(contact)&lt;/c1&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003052Z" creationid="shibukawa.yoshiki" creationdate="20150502T003052Z">
        <seg>&lt;c0&gt;save&lt;/c0&gt;が呼ばれると、連絡先を保存する(&lt;c1&gt;Contact.save(contact)&lt;/c1&gt;)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when a new call to &lt;c0&gt;m.mount&lt;/c0&gt; updates the root DOM element of the component in question</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091104Z" creationid="shibukawa.yoshiki" creationdate="20150502T091104Z">
        <seg>&lt;c0&gt;m.mount&lt;/c0&gt;関数が当たらたに呼ばれ、指定されたコンポーネントのルートのDOMエレメントが更新された時</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when a route changes (if you are using &lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt;)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091125Z" creationid="shibukawa.yoshiki" creationdate="20150502T091125Z">
        <seg>&lt;a0&gt;&lt;c1&gt;m.route&lt;/c1&gt;&lt;/a0&gt;を使ってラウトが変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yields:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002425Z" creationid="shibukawa.yoshiki" creationdate="20150413T002425Z">
        <seg>生成される結果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ onclick: function(e) { /*do stuff*/ } }</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154827Z" creationid="shibukawa.yoshiki" creationdate="20150413T154827Z">
        <seg>{ onclick: function(e) { /*ハンドラの処理コード*/ } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{class: "active"} : {})

//use this idiom instead
m("li", {class: selected ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144400Z" creationid="shibukawa.yoshiki" creationdate="20150413T144400Z">
        <seg>{class: "active"} : {})

//代わりにこのイディオムを使う
m("li", {class: selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{id: 2, name: "Mary"}
]

//ajax and display a list of projects for John
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//ajax and display a list of projects for Mary
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085750Z" creationid="shibukawa.yoshiki" creationdate="20150502T085737Z">
        <seg>{id: 2, name: "Mary"}
]

//AJAXでデータを取得し、Johnのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//AJAXでデータを取得し、Maryのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123335Z" creationid="shibukawa.yoshiki" creationdate="20150416T123335Z">
        <seg>{title: "アイテム 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 1", url: "/item1"},</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002436Z" creationid="shibukawa.yoshiki" creationdate="20150413T002436Z">
        <seg>{title: "アイテム 1", url: "/item1"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 2", url: "/item2"},</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002438Z" creationid="shibukawa.yoshiki" creationdate="20150413T002438Z">
        <seg>{title: "アイテム 2", url: "/item2"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002442Z" creationid="shibukawa.yoshiki" creationdate="20150413T002442Z">
        <seg>{title: "アイテム 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//ContactList is the same as before
var ContactList = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031334Z" creationid="shibukawa.yoshiki" creationdate="20150502T031334Z">
        <seg>}
}

//ContactListは前の実装と同じ
var ContactList = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//components that use the menu above
var Home = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124906Z" creationid="shibukawa.yoshiki" creationdate="20150502T124906Z">
        <seg>}
}

//上記のメニューを使用するコンポーネント
var Home = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//create a component whose controller and view functions receive some arguments
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // logs "world", "this is a test"

m.render(document.body, component.view(ctrl)) // render the virtual DOM tree manually

//&lt;body&gt;&lt;h1&gt;Hello world this is a test&lt;/h1&gt;&lt;/body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075939Z" creationid="shibukawa.yoshiki" creationdate="20150502T075909Z">
        <seg>}
}

//controllerとviewが同じ値を受け取るコンポーネントを作成する
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // 表示: "world", "this is a test"

m.render(document.body, component.view(ctrl)) // 手動で仮想DOMツリーをレンダリング

//&lt;body&gt;&lt;h1&gt;Hello world this is a test&lt;/h1&gt;&lt;/body&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//in the view
demo.view = function(ctrl) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001806Z" creationid="shibukawa.yoshiki" creationdate="20150415T001806Z">
        <seg>}
}

//ビュー内
demo.view = function(ctrl) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//setup routes to start w/ the `#` symbol
m.route.mode = "hash";

//define a route
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003247Z" creationid="shibukawa.yoshiki" creationdate="20150410T003247Z">
        <seg>}
}

//#記号から始まるラウトを使用するための設定
m.route.mode = "hash";

//ラウトの定義
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//view
var view = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144844Z" creationid="shibukawa.yoshiki" creationdate="20150416T144844Z">
        <seg>}
}

//ビュー
var view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent)

//renders:
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//the number increments when the link is clicked</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071359Z" creationid="shibukawa.yoshiki" creationdate="20150502T071338Z">
        <seg>}
}

m.mount(document.body, MyComponent)

//以下のようにレンダリングされる
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//リンクがクリックされるたびにカウンタがインクリメントされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders &lt;h1&gt;Hello&lt;/h1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072121Z" creationid="shibukawa.yoshiki" creationdate="20150502T072121Z">
        <seg>}
}

m.mount(document.body, MyComponent) // 表示: &lt;h1&gt;Hello&lt;/h1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders &lt;h1&gt;Hello&lt;/h1&gt; into &lt;body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061408Z" creationid="shibukawa.yoshiki" creationdate="20150502T061408Z">
        <seg>}
}

m.mount(document.body, MyComponent) // &lt;body&gt;に&lt;h1&gt;Hello&lt;/h1&gt;と表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
});

//assuming the response is: `{data: [{name: "John"}, {name: "Mary"}], count: 2}`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174638Z" creationid="shibukawa.yoshiki" creationdate="20150410T174638Z">
        <seg>}
});

//レスポンスには`{data: [{name: "John"}, {name: "Mary"}], count: 2}`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
};

// mount on the same DOM element, replacing MyComponent
m.mount(document.body, AnotherComponent); // logs "unloading my component"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091736Z" creationid="shibukawa.yoshiki" creationdate="20150502T091736Z">
        <seg>}
};

// 同じDOMエレメントに対してマウントし、MyComponentを置き換え
m.mount(document.body, AnotherComponent); // ログ: "MyComponentコンポーネントを削除しています"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //logs `unloaded the div` and `alert` never gets called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124538Z" creationid="shibukawa.yoshiki" creationdate="20150413T130519Z">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //`divをアンロード`とログに表示されるが、`alert`は呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>})

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175232Z" creationid="shibukawa.yoshiki" creationdate="20150414T175232Z">
        <seg>})

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}) : "loading"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20170208T080035Z" creationid="shibukawa.yoshiki" creationdate="20170208T080025Z">
        <seg>}) : "ロード中"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>});
}

//controller
var controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124220Z" creationid="shibukawa.yoshiki" creationdate="20150410T124220Z">
        <seg>});
}

//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
